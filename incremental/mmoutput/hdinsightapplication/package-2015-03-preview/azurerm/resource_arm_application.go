// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmApplication() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmApplicationCreateUpdate,
        Read: resourceArmApplicationRead,
        Update: resourceArmApplicationCreateUpdate,
        Delete: resourceArmApplicationDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "cluster_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "application_type": {
                Type: schema.TypeString,
                Optional: true,
            },

            "compute_profile": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "roles": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "autoscale": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "capacity": {
                                                    Type: schema.TypeList,
                                                    Optional: true,
                                                    MaxItems: 1,
                                                    Elem: &schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                            "max_instance_count": {
                                                                Type: schema.TypeInt,
                                                                Optional: true,
                                                            },
                                                            "min_instance_count": {
                                                                Type: schema.TypeInt,
                                                                Optional: true,
                                                            },
                                                        },
                                                    },
                                                },
                                                "recurrence": {
                                                    Type: schema.TypeList,
                                                    Optional: true,
                                                    MaxItems: 1,
                                                    Elem: &schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                            "schedule": {
                                                                Type: schema.TypeList,
                                                                Optional: true,
                                                                Elem: &schema.Resource{
                                                                    Schema: map[string]*schema.Schema{
                                                                        "days": {
                                                                            Type: schema.TypeList,
                                                                            Optional: true,
                                                                            Elem: &schema.Schema{
                                                                                Type: schema.TypeString,
                                                                                ValidateFunc: validation.StringInSlice([]string{
                                                                                    string(hdinsight.Monday),
                                                                                    string(hdinsight.Tuesday),
                                                                                    string(hdinsight.Wednesday),
                                                                                    string(hdinsight.Thursday),
                                                                                    string(hdinsight.Friday),
                                                                                    string(hdinsight.Saturday),
                                                                                    string(hdinsight.Sunday),
                                                                               }, false),
                                                                            },
                                                                        },
                                                                        "time_and_capacity": {
                                                                            Type: schema.TypeList,
                                                                            Optional: true,
                                                                            MaxItems: 1,
                                                                            Elem: &schema.Resource{
                                                                                Schema: map[string]*schema.Schema{
                                                                                    "max_instance_count": {
                                                                                        Type: schema.TypeInt,
                                                                                        Optional: true,
                                                                                    },
                                                                                    "min_instance_count": {
                                                                                        Type: schema.TypeInt,
                                                                                        Optional: true,
                                                                                    },
                                                                                    "time": {
                                                                                        Type: schema.TypeString,
                                                                                        Optional: true,
                                                                                    },
                                                                                },
                                                                            },
                                                                        },
                                                                    },
                                                                },
                                                            },
                                                            "time_zone": {
                                                                Type: schema.TypeString,
                                                                Optional: true,
                                                            },
                                                        },
                                                    },
                                                },
                                            },
                                        },
                                    },
                                    "data_disks_groups": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "disks_per_node": {
                                                    Type: schema.TypeInt,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "hardware_profile": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "vm_size": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "min_instance_count": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "name": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "os_profile": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "linux_operating_system_profile": {
                                                    Type: schema.TypeList,
                                                    Optional: true,
                                                    MaxItems: 1,
                                                    Elem: &schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                            "password": {
                                                                Type: schema.TypeString,
                                                                Optional: true,
                                                            },
                                                            "ssh_profile": {
                                                                Type: schema.TypeList,
                                                                Optional: true,
                                                                MaxItems: 1,
                                                                Elem: &schema.Resource{
                                                                    Schema: map[string]*schema.Schema{
                                                                        "public_keys": {
                                                                            Type: schema.TypeList,
                                                                            Optional: true,
                                                                            Elem: &schema.Resource{
                                                                                Schema: map[string]*schema.Schema{
                                                                                    "certificate_data": {
                                                                                        Type: schema.TypeString,
                                                                                        Optional: true,
                                                                                    },
                                                                                },
                                                                            },
                                                                        },
                                                                    },
                                                                },
                                                            },
                                                            "username": {
                                                                Type: schema.TypeString,
                                                                Optional: true,
                                                            },
                                                        },
                                                    },
                                                },
                                            },
                                        },
                                    },
                                    "script_actions": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "name": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "parameters": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "uri": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                            },
                                        },
                                    },
                                    "target_instance_count": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "virtual_network_profile": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "id": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "subnet": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "errors": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "code": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "message": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "etag": {
                Type: schema.TypeString,
                Optional: true,
                ForceNew: true,
            },

            "https_endpoints": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "access_modes": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Schema{
                                Type: schema.TypeString,
                            },
                        },
                        "destination_port": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "disable_gateway_auth": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "location": azure.SchemaLocation(),
                        "public_port": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "sub_domain_suffix": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "install_script_actions": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "roles": {
                            Type: schema.TypeList,
                            Required: true,
                            Elem: &schema.Schema{
                                Type: schema.TypeString,
                            },
                        },
                        "uri": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "parameters": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "ssh_endpoints": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "destination_port": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "location": azure.SchemaLocation(),
                        "public_port": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                    },
                },
            },

            "uninstall_script_actions": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "roles": {
                            Type: schema.TypeList,
                            Required: true,
                            Elem: &schema.Schema{
                                Type: schema.TypeString,
                            },
                        },
                        "uri": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "parameters": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "application_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "created_date": {
                Type: schema.TypeString,
                Computed: true,
            },

            "marketplace_identifier": {
                Type: schema.TypeString,
                Computed: true,
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmApplicationCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).applicationsClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    clusterName := d.Get("cluster_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, clusterName, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Application %q (Cluster Name %q / Resource Group %q): %+v", name, clusterName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_application", *existing.ID)
        }
    }

    applicationType := d.Get("application_type").(string)
    computeProfile := d.Get("compute_profile").([]interface{})
    errors := d.Get("errors").([]interface{})
    etag := d.Get("etag").(string)
    httpsEndpoints := d.Get("https_endpoints").([]interface{})
    installScriptActions := d.Get("install_script_actions").([]interface{})
    sshEndpoints := d.Get("ssh_endpoints").([]interface{})
    uninstallScriptActions := d.Get("uninstall_script_actions").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    parameters := hdinsight.Application{
        Etag: utils.String(etag),
        ApplicationProperties: &hdinsight.ApplicationProperties{
            ApplicationType: utils.String(applicationType),
            ComputeProfile: expandArmApplicationComputeProfile(computeProfile),
            Errors: expandArmApplicationErrors(errors),
            HttpsEndpoints: expandArmApplicationApplicationGetHttpsEndpoint(httpsEndpoints),
            InstallScriptActions: expandArmApplicationRuntimeScriptAction(installScriptActions),
            SshEndpoints: expandArmApplicationApplicationGetEndpoint(sshEndpoints),
            UninstallScriptActions: expandArmApplicationRuntimeScriptAction(uninstallScriptActions),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.Create(ctx, resourceGroup, clusterName, name, parameters)
    if err != nil {
        return fmt.Errorf("Error creating Application %q (Cluster Name %q / Resource Group %q): %+v", name, clusterName, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Application %q (Cluster Name %q / Resource Group %q): %+v", name, clusterName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, clusterName, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Application %q (Cluster Name %q / Resource Group %q): %+v", name, clusterName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Application %q (Cluster Name %q / Resource Group %q) ID", name, clusterName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmApplicationRead(d, meta)
}

func resourceArmApplicationRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).applicationsClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    clusterName := id.Path["clusters"]
    name := id.Path["applications"]

    resp, err := client.Get(ctx, resourceGroup, clusterName, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Application %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Application %q (Cluster Name %q / Resource Group %q): %+v", name, clusterName, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if applicationProperties := resp.ApplicationProperties; applicationProperties != nil {
        d.Set("application_state", applicationProperties.ApplicationState)
        d.Set("application_type", applicationProperties.ApplicationType)
        if err := d.Set("compute_profile", flattenArmApplicationComputeProfile(applicationProperties.ComputeProfile)); err != nil {
            return fmt.Errorf("Error setting `compute_profile`: %+v", err)
        }
        d.Set("created_date", applicationProperties.CreatedDate)
        if err := d.Set("errors", flattenArmApplicationErrors(applicationProperties.Errors)); err != nil {
            return fmt.Errorf("Error setting `errors`: %+v", err)
        }
        if err := d.Set("https_endpoints", flattenArmApplicationApplicationGetHttpsEndpoint(applicationProperties.HttpsEndpoints)); err != nil {
            return fmt.Errorf("Error setting `https_endpoints`: %+v", err)
        }
        if err := d.Set("install_script_actions", flattenArmApplicationRuntimeScriptAction(applicationProperties.InstallScriptActions)); err != nil {
            return fmt.Errorf("Error setting `install_script_actions`: %+v", err)
        }
        d.Set("marketplace_identifier", applicationProperties.MarketplaceIdentifier)
        d.Set("provisioning_state", applicationProperties.ProvisioningState)
        if err := d.Set("ssh_endpoints", flattenArmApplicationApplicationGetEndpoint(applicationProperties.SshEndpoints)); err != nil {
            return fmt.Errorf("Error setting `ssh_endpoints`: %+v", err)
        }
        if err := d.Set("uninstall_script_actions", flattenArmApplicationRuntimeScriptAction(applicationProperties.UninstallScriptActions)); err != nil {
            return fmt.Errorf("Error setting `uninstall_script_actions`: %+v", err)
        }
    }
    d.Set("cluster_name", clusterName)
    d.Set("etag", resp.Etag)
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}


func resourceArmApplicationDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).applicationsClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    clusterName := id.Path["clusters"]
    name := id.Path["applications"]

    future, err := client.Delete(ctx, resourceGroup, clusterName, name)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Application %q (Cluster Name %q / Resource Group %q): %+v", name, clusterName, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Application %q (Cluster Name %q / Resource Group %q): %+v", name, clusterName, resourceGroup, err)
        }
    }

    return nil
}

func expandArmApplicationComputeProfile(input []interface{}) *hdinsight.ComputeProfile {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    roles := v["roles"].([]interface{})

    result := hdinsight.ComputeProfile{
        Roles: expandArmApplicationRole(roles),
    }
    return &result
}

func expandArmApplicationErrors(input []interface{}) *[]hdinsight.Errors {
    results := make([]hdinsight.Errors, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        code := v["code"].(string)
        message := v["message"].(string)

        result := hdinsight.Errors{
            Code: utils.String(code),
            Message: utils.String(message),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmApplicationApplicationGetHttpsEndpoint(input []interface{}) *[]hdinsight.ApplicationGetHttpsEndpoint {
    results := make([]hdinsight.ApplicationGetHttpsEndpoint, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        accessModes := v["access_modes"].([]interface{})
        location := azure.NormalizeLocation(v["location"].(string))
        destinationPort := v["destination_port"].(int)
        publicPort := v["public_port"].(int)
        subDomainSuffix := v["sub_domain_suffix"].(string)
        disableGatewayAuth := v["disable_gateway_auth"].(bool)

        result := hdinsight.ApplicationGetHttpsEndpoint{
            AccessModes: utils.ExpandStringSlice(accessModes),
            DestinationPort: utils.Int32(int32(destinationPort)),
            DisableGatewayAuth: utils.Bool(disableGatewayAuth),
            Location: utils.String(location),
            PublicPort: utils.Int32(int32(publicPort)),
            SubDomainSuffix: utils.String(subDomainSuffix),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmApplicationRuntimeScriptAction(input []interface{}) *[]hdinsight.RuntimeScriptAction {
    results := make([]hdinsight.RuntimeScriptAction, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        uri := v["uri"].(string)
        parameters := v["parameters"].(string)
        roles := v["roles"].([]interface{})

        result := hdinsight.RuntimeScriptAction{
            Name: utils.String(name),
            Parameters: utils.String(parameters),
            Roles: utils.ExpandStringSlice(roles),
            Uri: utils.String(uri),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmApplicationApplicationGetEndpoint(input []interface{}) *[]hdinsight.ApplicationGetEndpoint {
    results := make([]hdinsight.ApplicationGetEndpoint, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        location := azure.NormalizeLocation(v["location"].(string))
        destinationPort := v["destination_port"].(int)
        publicPort := v["public_port"].(int)

        result := hdinsight.ApplicationGetEndpoint{
            DestinationPort: utils.Int32(int32(destinationPort)),
            Location: utils.String(location),
            PublicPort: utils.Int32(int32(publicPort)),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmApplicationRole(input []interface{}) *[]hdinsight.Role {
    results := make([]hdinsight.Role, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        minInstanceCount := v["min_instance_count"].(int)
        targetInstanceCount := v["target_instance_count"].(int)
        autoscale := v["autoscale"].([]interface{})
        hardwareProfile := v["hardware_profile"].([]interface{})
        osProfile := v["os_profile"].([]interface{})
        virtualNetworkProfile := v["virtual_network_profile"].([]interface{})
        dataDisksGroups := v["data_disks_groups"].([]interface{})
        scriptActions := v["script_actions"].([]interface{})

        result := hdinsight.Role{
            Autoscale: expandArmApplicationAutoscale(autoscale),
            DataDisksGroups: expandArmApplicationDataDisksGroups(dataDisksGroups),
            HardwareProfile: expandArmApplicationHardwareProfile(hardwareProfile),
            MinInstanceCount: utils.Int32(int32(minInstanceCount)),
            Name: utils.String(name),
            OsProfile: expandArmApplicationOsProfile(osProfile),
            ScriptActions: expandArmApplicationScriptAction(scriptActions),
            TargetInstanceCount: utils.Int32(int32(targetInstanceCount)),
            VirtualNetworkProfile: expandArmApplicationVirtualNetworkProfile(virtualNetworkProfile),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmApplicationAutoscale(input []interface{}) *hdinsight.Autoscale {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    capacity := v["capacity"].([]interface{})
    recurrence := v["recurrence"].([]interface{})

    result := hdinsight.Autoscale{
        Capacity: expandArmApplicationAutoscaleCapacity(capacity),
        Recurrence: expandArmApplicationAutoscaleRecurrence(recurrence),
    }
    return &result
}

func expandArmApplicationDataDisksGroups(input []interface{}) *[]hdinsight.DataDisksGroups {
    results := make([]hdinsight.DataDisksGroups, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        disksPerNode := v["disks_per_node"].(int)

        result := hdinsight.DataDisksGroups{
            DisksPerNode: utils.Int32(int32(disksPerNode)),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmApplicationHardwareProfile(input []interface{}) *hdinsight.HardwareProfile {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    vmSize := v["vm_size"].(string)

    result := hdinsight.HardwareProfile{
        VmSize: utils.String(vmSize),
    }
    return &result
}

func expandArmApplicationOsProfile(input []interface{}) *hdinsight.OsProfile {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    linuxOperatingSystemProfile := v["linux_operating_system_profile"].([]interface{})

    result := hdinsight.OsProfile{
        LinuxOperatingSystemProfile: expandArmApplicationLinuxOperatingSystemProfile(linuxOperatingSystemProfile),
    }
    return &result
}

func expandArmApplicationScriptAction(input []interface{}) *[]hdinsight.ScriptAction {
    results := make([]hdinsight.ScriptAction, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        uri := v["uri"].(string)
        parameters := v["parameters"].(string)

        result := hdinsight.ScriptAction{
            Name: utils.String(name),
            Parameters: utils.String(parameters),
            Uri: utils.String(uri),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmApplicationVirtualNetworkProfile(input []interface{}) *hdinsight.VirtualNetworkProfile {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    id := v["id"].(string)
    subnet := v["subnet"].(string)

    result := hdinsight.VirtualNetworkProfile{
        ID: utils.String(id),
        Subnet: utils.String(subnet),
    }
    return &result
}

func expandArmApplicationAutoscaleCapacity(input []interface{}) *hdinsight.AutoscaleCapacity {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    minInstanceCount := v["min_instance_count"].(int)
    maxInstanceCount := v["max_instance_count"].(int)

    result := hdinsight.AutoscaleCapacity{
        MaxInstanceCount: utils.Int32(int32(maxInstanceCount)),
        MinInstanceCount: utils.Int32(int32(minInstanceCount)),
    }
    return &result
}

func expandArmApplicationAutoscaleRecurrence(input []interface{}) *hdinsight.AutoscaleRecurrence {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    timeZone := v["time_zone"].(string)
    schedule := v["schedule"].([]interface{})

    result := hdinsight.AutoscaleRecurrence{
        Schedule: expandArmApplicationAutoscaleSchedule(schedule),
        TimeZone: utils.String(timeZone),
    }
    return &result
}

func expandArmApplicationLinuxOperatingSystemProfile(input []interface{}) *hdinsight.LinuxOperatingSystemProfile {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    username := v["username"].(string)
    password := v["password"].(string)
    sshProfile := v["ssh_profile"].([]interface{})

    result := hdinsight.LinuxOperatingSystemProfile{
        Password: utils.String(password),
        SshProfile: expandArmApplicationSshProfile(sshProfile),
        Username: utils.String(username),
    }
    return &result
}

func expandArmApplicationAutoscaleSchedule(input []interface{}) *[]hdinsight.AutoscaleSchedule {
    results := make([]hdinsight.AutoscaleSchedule, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        days := v["days"].([]interface{})
        timeAndCapacity := v["time_and_capacity"].([]interface{})

        result := hdinsight.AutoscaleSchedule{
            Days: expandArmApplication(days),
            TimeAndCapacity: expandArmApplicationAutoscaleTimeAndCapacity(timeAndCapacity),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmApplicationSshProfile(input []interface{}) *hdinsight.SshProfile {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    publicKeys := v["public_keys"].([]interface{})

    result := hdinsight.SshProfile{
        PublicKeys: expandArmApplicationSshPublicKey(publicKeys),
    }
    return &result
}

func expandArmApplication(input []interface{}) *[]hdinsight. {
    results := make([]hdinsight., 0)
    for _, item := range input {
        v := item.(string)
        result := hdinsight.(v)
        results = append(results, result)
    }
    return &results
}

func expandArmApplicationAutoscaleTimeAndCapacity(input []interface{}) *hdinsight.AutoscaleTimeAndCapacity {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    time := v["time"].(string)
    minInstanceCount := v["min_instance_count"].(int)
    maxInstanceCount := v["max_instance_count"].(int)

    result := hdinsight.AutoscaleTimeAndCapacity{
        MaxInstanceCount: utils.Int32(int32(maxInstanceCount)),
        MinInstanceCount: utils.Int32(int32(minInstanceCount)),
        Time: utils.String(time),
    }
    return &result
}

func expandArmApplicationSshPublicKey(input []interface{}) *[]hdinsight.SshPublicKey {
    results := make([]hdinsight.SshPublicKey, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        certificateData := v["certificate_data"].(string)

        result := hdinsight.SshPublicKey{
            CertificateData: utils.String(certificateData),
        }

        results = append(results, result)
    }
    return &results
}


func flattenArmApplicationComputeProfile(input *hdinsight.ComputeProfile) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["roles"] = flattenArmApplicationRole(input.Roles)

    return []interface{}{result}
}

func flattenArmApplicationErrors(input *[]hdinsight.Errors) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if code := item.Code; code != nil {
            v["code"] = *code
        }
        if message := item.Message; message != nil {
            v["message"] = *message
        }

        results = append(results, v)
    }

    return results
}

func flattenArmApplicationApplicationGetHttpsEndpoint(input *[]hdinsight.ApplicationGetHttpsEndpoint) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if location := item.Location; location != nil {
            v["location"] = azure.NormalizeLocation(*location)
        }
        v["access_modes"] = utils.FlattenStringSlice(item.AccessModes)
        if destinationPort := item.DestinationPort; destinationPort != nil {
            v["destination_port"] = int(*destinationPort)
        }
        if disableGatewayAuth := item.DisableGatewayAuth; disableGatewayAuth != nil {
            v["disable_gateway_auth"] = *disableGatewayAuth
        }
        if publicPort := item.PublicPort; publicPort != nil {
            v["public_port"] = int(*publicPort)
        }
        if subDomainSuffix := item.SubDomainSuffix; subDomainSuffix != nil {
            v["sub_domain_suffix"] = *subDomainSuffix
        }

        results = append(results, v)
    }

    return results
}

func flattenArmApplicationRuntimeScriptAction(input *[]hdinsight.RuntimeScriptAction) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if parameters := item.Parameters; parameters != nil {
            v["parameters"] = *parameters
        }
        v["roles"] = utils.FlattenStringSlice(item.Roles)
        if uri := item.Uri; uri != nil {
            v["uri"] = *uri
        }

        results = append(results, v)
    }

    return results
}

func flattenArmApplicationApplicationGetEndpoint(input *[]hdinsight.ApplicationGetEndpoint) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if location := item.Location; location != nil {
            v["location"] = azure.NormalizeLocation(*location)
        }
        if destinationPort := item.DestinationPort; destinationPort != nil {
            v["destination_port"] = int(*destinationPort)
        }
        if publicPort := item.PublicPort; publicPort != nil {
            v["public_port"] = int(*publicPort)
        }

        results = append(results, v)
    }

    return results
}

func flattenArmApplicationRole(input *[]hdinsight.Role) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        v["autoscale"] = flattenArmApplicationAutoscale(item.Autoscale)
        v["data_disks_groups"] = flattenArmApplicationDataDisksGroups(item.DataDisksGroups)
        v["hardware_profile"] = flattenArmApplicationHardwareProfile(item.HardwareProfile)
        if minInstanceCount := item.MinInstanceCount; minInstanceCount != nil {
            v["min_instance_count"] = int(*minInstanceCount)
        }
        v["os_profile"] = flattenArmApplicationOsProfile(item.OsProfile)
        v["script_actions"] = flattenArmApplicationScriptAction(item.ScriptActions)
        if targetInstanceCount := item.TargetInstanceCount; targetInstanceCount != nil {
            v["target_instance_count"] = int(*targetInstanceCount)
        }
        v["virtual_network_profile"] = flattenArmApplicationVirtualNetworkProfile(item.VirtualNetworkProfile)

        results = append(results, v)
    }

    return results
}

func flattenArmApplicationAutoscale(input *hdinsight.Autoscale) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["capacity"] = flattenArmApplicationAutoscaleCapacity(input.Capacity)
    result["recurrence"] = flattenArmApplicationAutoscaleRecurrence(input.Recurrence)

    return []interface{}{result}
}

func flattenArmApplicationDataDisksGroups(input *[]hdinsight.DataDisksGroups) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if disksPerNode := item.DisksPerNode; disksPerNode != nil {
            v["disks_per_node"] = int(*disksPerNode)
        }

        results = append(results, v)
    }

    return results
}

func flattenArmApplicationHardwareProfile(input *hdinsight.HardwareProfile) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if vmSize := input.VmSize; vmSize != nil {
        result["vm_size"] = *vmSize
    }

    return []interface{}{result}
}

func flattenArmApplicationOsProfile(input *hdinsight.OsProfile) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["linux_operating_system_profile"] = flattenArmApplicationLinuxOperatingSystemProfile(input.LinuxOperatingSystemProfile)

    return []interface{}{result}
}

func flattenArmApplicationScriptAction(input *[]hdinsight.ScriptAction) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if parameters := item.Parameters; parameters != nil {
            v["parameters"] = *parameters
        }
        if uri := item.Uri; uri != nil {
            v["uri"] = *uri
        }

        results = append(results, v)
    }

    return results
}

func flattenArmApplicationVirtualNetworkProfile(input *hdinsight.VirtualNetworkProfile) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if id := input.ID; id != nil {
        result["id"] = *id
    }
    if subnet := input.Subnet; subnet != nil {
        result["subnet"] = *subnet
    }

    return []interface{}{result}
}

func flattenArmApplicationAutoscaleCapacity(input *hdinsight.AutoscaleCapacity) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if maxInstanceCount := input.MaxInstanceCount; maxInstanceCount != nil {
        result["max_instance_count"] = int(*maxInstanceCount)
    }
    if minInstanceCount := input.MinInstanceCount; minInstanceCount != nil {
        result["min_instance_count"] = int(*minInstanceCount)
    }

    return []interface{}{result}
}

func flattenArmApplicationAutoscaleRecurrence(input *hdinsight.AutoscaleRecurrence) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["schedule"] = flattenArmApplicationAutoscaleSchedule(input.Schedule)
    if timeZone := input.TimeZone; timeZone != nil {
        result["time_zone"] = *timeZone
    }

    return []interface{}{result}
}

func flattenArmApplicationLinuxOperatingSystemProfile(input *hdinsight.LinuxOperatingSystemProfile) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if password := input.Password; password != nil {
        result["password"] = *password
    }
    result["ssh_profile"] = flattenArmApplicationSshProfile(input.SshProfile)
    if username := input.Username; username != nil {
        result["username"] = *username
    }

    return []interface{}{result}
}

func flattenArmApplicationAutoscaleSchedule(input *[]hdinsight.AutoscaleSchedule) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        v["days"] = flattenArmApplication(string(item.Days))
        v["time_and_capacity"] = flattenArmApplicationAutoscaleTimeAndCapacity(item.TimeAndCapacity)

        results = append(results, v)
    }

    return results
}

func flattenArmApplicationSshProfile(input *hdinsight.SshProfile) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["public_keys"] = flattenArmApplicationSshPublicKey(input.PublicKeys)

    return []interface{}{result}
}

func flattenArmApplication(input *[]hdinsight.) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        result := string(item)
        results = append(results, result)
    }

    return results
}

func flattenArmApplicationAutoscaleTimeAndCapacity(input *hdinsight.AutoscaleTimeAndCapacity) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if maxInstanceCount := input.MaxInstanceCount; maxInstanceCount != nil {
        result["max_instance_count"] = int(*maxInstanceCount)
    }
    if minInstanceCount := input.MinInstanceCount; minInstanceCount != nil {
        result["min_instance_count"] = int(*minInstanceCount)
    }
    if time := input.Time; time != nil {
        result["time"] = *time
    }

    return []interface{}{result}
}

func flattenArmApplicationSshPublicKey(input *[]hdinsight.SshPublicKey) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if certificateData := item.CertificateData; certificateData != nil {
            v["certificate_data"] = *certificateData
        }

        results = append(results, v)
    }

    return results
}
