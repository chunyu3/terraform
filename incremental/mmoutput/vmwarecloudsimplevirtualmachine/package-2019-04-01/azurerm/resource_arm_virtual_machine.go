// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmVirtualMachine() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmVirtualMachineCreate,
        Read: resourceArmVirtualMachineRead,
        Update: resourceArmVirtualMachineUpdate,
        Delete: resourceArmVirtualMachineDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "amount_of_ram": {
                Type: schema.TypeInt,
                Required: true,
            },

            "number_of_cores": {
                Type: schema.TypeInt,
                Required: true,
            },

            "private_cloud_id": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "referer": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "customization": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "dns_servers": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Schema{
                                Type: schema.TypeString,
                            },
                        },
                        "host_name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "password": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "policy_id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "username": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "disks": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "controller_id": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "independence_mode": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(vmwarecloudsimple.persistent),
                                string(vmwarecloudsimple.independent_persistent),
                                string(vmwarecloudsimple.independent_nonpersistent),
                            }, false),
                        },
                        "total_size": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "virtual_disk_id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "expose_to_guest_vm": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "nics": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "network": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                },
                            },
                        },
                        "nic_type": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(vmwarecloudsimple.E1000),
                                string(vmwarecloudsimple.E1000E),
                                string(vmwarecloudsimple.PCNET32),
                                string(vmwarecloudsimple.VMXNET),
                                string(vmwarecloudsimple.VMXNET2),
                                string(vmwarecloudsimple.VMXNET3),
                            }, false),
                        },
                        "customization": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "allocation": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(vmwarecloudsimple.static),
                                            string(vmwarecloudsimple.dynamic),
                                        }, false),
                                        Default: string(vmwarecloudsimple.static),
                                    },
                                    "dns_servers": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                    "gateway": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                    "ip_address": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "mask": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "primary_wins_server": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "secondary_wins_server": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "ip_addresses": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Schema{
                                Type: schema.TypeString,
                            },
                        },
                        "mac_address": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "power_on_boot": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "virtual_nic_id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "password": {
                Type: schema.TypeString,
                Optional: true,
            },

            "resource_pool": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "id": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "template_id": {
                Type: schema.TypeString,
                Optional: true,
            },

            "username": {
                Type: schema.TypeString,
                Optional: true,
            },

            "v_sphere_networks": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Schema{
                    Type: schema.TypeString,
                },
            },

            "controllers": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "sub_type": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "type": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "dnsname": {
                Type: schema.TypeString,
                Computed: true,
            },

            "folder": {
                Type: schema.TypeString,
                Computed: true,
            },

            "guest_os": {
                Type: schema.TypeString,
                Computed: true,
            },

            "guest_ostype": {
                Type: schema.TypeString,
                Computed: true,
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "public_ip": {
                Type: schema.TypeString,
                Computed: true,
            },

            "status": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "vm_id": {
                Type: schema.TypeString,
                Computed: true,
            },

            "vmwaretools": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmVirtualMachineCreate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).virtualMachinesClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    referer := d.Get("referer").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Virtual Machine %q (Resource Group %q): %+v", name, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_virtual_machine", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    amountOfRam := d.Get("amount_of_ram").(int)
    customization := d.Get("customization").([]interface{})
    disks := d.Get("disks").([]interface{})
    exposeToGuestVm := d.Get("expose_to_guest_vm").(bool)
    nics := d.Get("nics").([]interface{})
    numberOfCores := d.Get("number_of_cores").(int)
    password := d.Get("password").(string)
    privateCloudId := d.Get("private_cloud_id").(string)
    resourcePool := d.Get("resource_pool").([]interface{})
    templateId := d.Get("template_id").(string)
    username := d.Get("username").(string)
    vSphereNetworks := d.Get("v_sphere_networks").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    virtualMachineRequest := vmwarecloudsimple.VirtualMachine{
        Location: utils.String(location),
        VirtualMachineProperties: &vmwarecloudsimple.VirtualMachineProperties{
            AmountOfRam: utils.Int(amountOfRam),
            Customization: expandArmVirtualMachineGuestOSCustomization(customization),
            Disks: expandArmVirtualMachineVirtualDisk(disks),
            ExposeToGuestVm: utils.Bool(exposeToGuestVm),
            Nics: expandArmVirtualMachineVirtualNic(nics),
            NumberOfCores: utils.Int(numberOfCores),
            Password: utils.String(password),
            PrivateCloudID: utils.String(privateCloudId),
            ResourcePool: expandArmVirtualMachineResourcePool(resourcePool),
            TemplateID: utils.String(templateId),
            Username: utils.String(username),
            VSphereNetworks: utils.ExpandStringSlice(vSphereNetworks),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.CreateOrUpdate(ctx, resourceGroup, name, virtualMachineRequest, referer)
    if err != nil {
        return fmt.Errorf("Error creating Virtual Machine %q (Referer %q / Resource Group %q): %+v", name, referer, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Virtual Machine %q (Referer %q / Resource Group %q): %+v", name, referer, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Virtual Machine %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Virtual Machine %q (Resource Group %q) ID", name, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmVirtualMachineRead(d, meta)
}

func resourceArmVirtualMachineRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).virtualMachinesClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["virtualMachines"]

    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Virtual Machine %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Virtual Machine %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    if virtualMachineProperties := resp.VirtualMachineProperties; virtualMachineProperties != nil {
        d.Set("amount_of_ram", virtualMachineProperties.AmountOfRam)
        if err := d.Set("controllers", flattenArmVirtualMachineVirtualDiskController(virtualMachineProperties.Controllers)); err != nil {
            return fmt.Errorf("Error setting `controllers`: %+v", err)
        }
        if err := d.Set("customization", flattenArmVirtualMachineGuestOSCustomization(virtualMachineProperties.Customization)); err != nil {
            return fmt.Errorf("Error setting `customization`: %+v", err)
        }
        if err := d.Set("disks", flattenArmVirtualMachineVirtualDisk(virtualMachineProperties.Disks)); err != nil {
            return fmt.Errorf("Error setting `disks`: %+v", err)
        }
        d.Set("dnsname", virtualMachineProperties.Dnsname)
        d.Set("expose_to_guest_vm", virtualMachineProperties.ExposeToGuestVm)
        d.Set("folder", virtualMachineProperties.Folder)
        d.Set("guest_os", virtualMachineProperties.GuestOs)
        d.Set("guest_ostype", string(virtualMachineProperties.GuestOstype))
        if err := d.Set("nics", flattenArmVirtualMachineVirtualNic(virtualMachineProperties.Nics)); err != nil {
            return fmt.Errorf("Error setting `nics`: %+v", err)
        }
        d.Set("number_of_cores", virtualMachineProperties.NumberOfCores)
        d.Set("password", virtualMachineProperties.Password)
        d.Set("private_cloud_id", virtualMachineProperties.PrivateCloudID)
        d.Set("provisioning_state", virtualMachineProperties.ProvisioningState)
        d.Set("public_ip", virtualMachineProperties.PublicIp)
        if err := d.Set("resource_pool", flattenArmVirtualMachineResourcePool(virtualMachineProperties.ResourcePool)); err != nil {
            return fmt.Errorf("Error setting `resource_pool`: %+v", err)
        }
        d.Set("status", string(virtualMachineProperties.Status))
        d.Set("template_id", virtualMachineProperties.TemplateID)
        d.Set("username", virtualMachineProperties.Username)
        d.Set("v_sphere_networks", utils.FlattenStringSlice(virtualMachineProperties.VSphereNetworks))
        d.Set("vm_id", virtualMachineProperties.VmID)
        d.Set("vmwaretools", virtualMachineProperties.Vmwaretools)
    }
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}

func resourceArmVirtualMachineUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).virtualMachinesClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    amountOfRam := d.Get("amount_of_ram").(int)
    customization := d.Get("customization").([]interface{})
    disks := d.Get("disks").([]interface{})
    exposeToGuestVm := d.Get("expose_to_guest_vm").(bool)
    nics := d.Get("nics").([]interface{})
    numberOfCores := d.Get("number_of_cores").(int)
    password := d.Get("password").(string)
    privateCloudId := d.Get("private_cloud_id").(string)
    resourcePool := d.Get("resource_pool").([]interface{})
    templateId := d.Get("template_id").(string)
    username := d.Get("username").(string)
    vSphereNetworks := d.Get("v_sphere_networks").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    virtualMachineRequest := vmwarecloudsimple.VirtualMachine{
        Location: utils.String(location),
        VirtualMachineProperties: &vmwarecloudsimple.VirtualMachineProperties{
            AmountOfRam: utils.Int(amountOfRam),
            Customization: expandArmVirtualMachineGuestOSCustomization(customization),
            Disks: expandArmVirtualMachineVirtualDisk(disks),
            ExposeToGuestVm: utils.Bool(exposeToGuestVm),
            Nics: expandArmVirtualMachineVirtualNic(nics),
            NumberOfCores: utils.Int(numberOfCores),
            Password: utils.String(password),
            PrivateCloudID: utils.String(privateCloudId),
            ResourcePool: expandArmVirtualMachineResourcePool(resourcePool),
            TemplateID: utils.String(templateId),
            Username: utils.String(username),
            VSphereNetworks: utils.ExpandStringSlice(vSphereNetworks),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.Update(ctx, resourceGroup, name, virtualMachineRequest)
    if err != nil {
        return fmt.Errorf("Error updating Virtual Machine %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for update of Virtual Machine %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    return resourceArmVirtualMachineRead(d, meta)
}

func resourceArmVirtualMachineDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).virtualMachinesClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["virtualMachines"]

    future, err := client.Delete(ctx, resourceGroup, name, referer)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Virtual Machine %q (Referer %q / Resource Group %q): %+v", name, referer, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Virtual Machine %q (Referer %q / Resource Group %q): %+v", name, referer, resourceGroup, err)
        }
    }

    return nil
}

func expandArmVirtualMachineGuestOSCustomization(input []interface{}) *vmwarecloudsimple.GuestOSCustomization {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    dnsServers := v["dns_servers"].([]interface{})
    hostName := v["host_name"].(string)
    password := v["password"].(string)
    policyId := v["policy_id"].(string)
    username := v["username"].(string)

    result := vmwarecloudsimple.GuestOSCustomization{
        DnsServers: utils.ExpandStringSlice(dnsServers),
        HostName: utils.String(hostName),
        Password: utils.String(password),
        PolicyID: utils.String(policyId),
        Username: utils.String(username),
    }
    return &result
}

func expandArmVirtualMachineVirtualDisk(input []interface{}) *[]vmwarecloudsimple.VirtualDisk {
    results := make([]vmwarecloudsimple.VirtualDisk, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        controllerId := v["controller_id"].(string)
        independenceMode := v["independence_mode"].(string)
        totalSize := v["total_size"].(int)
        virtualDiskId := v["virtual_disk_id"].(string)

        result := vmwarecloudsimple.VirtualDisk{
            ControllerID: utils.String(controllerId),
            IndependenceMode: vmwarecloudsimple.DiskIndependenceMode(independenceMode),
            TotalSize: utils.Int(totalSize),
            VirtualDiskID: utils.String(virtualDiskId),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmVirtualMachineVirtualNic(input []interface{}) *[]vmwarecloudsimple.VirtualNic {
    results := make([]vmwarecloudsimple.VirtualNic, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        customization := v["customization"].([]interface{})
        ipAddresses := v["ip_addresses"].([]interface{})
        macAddress := v["mac_address"].(string)
        network := v["network"].([]interface{})
        nicType := v["nic_type"].(string)
        powerOnBoot := v["power_on_boot"].(bool)
        virtualNicId := v["virtual_nic_id"].(string)

        result := vmwarecloudsimple.VirtualNic{
            Customization: expandArmVirtualMachineGuestOSNICCustomization(customization),
            IpAddresses: utils.ExpandStringSlice(ipAddresses),
            MacAddress: utils.String(macAddress),
            Network: expandArmVirtualMachineVirtualNetwork(network),
            NicType: vmwarecloudsimple.NICType(nicType),
            PowerOnBoot: utils.Bool(powerOnBoot),
            VirtualNicID: utils.String(virtualNicId),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmVirtualMachineResourcePool(input []interface{}) *vmwarecloudsimple.ResourcePool {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    id := v["id"].(string)

    result := vmwarecloudsimple.ResourcePool{
        ID: utils.String(id),
    }
    return &result
}

func expandArmVirtualMachineGuestOSNICCustomization(input []interface{}) *vmwarecloudsimple.GuestOSNICCustomization {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    allocation := v["allocation"].(string)
    dnsServers := v["dns_servers"].([]interface{})
    gateway := v["gateway"].([]interface{})
    ipAddress := v["ip_address"].(string)
    mask := v["mask"].(string)
    primaryWinsServer := v["primary_wins_server"].(string)
    secondaryWinsServer := v["secondary_wins_server"].(string)

    result := vmwarecloudsimple.GuestOSNICCustomization{
        Allocation: vmwarecloudsimple.(allocation),
        DnsServers: utils.ExpandStringSlice(dnsServers),
        Gateway: utils.ExpandStringSlice(gateway),
        IpAddress: utils.String(ipAddress),
        Mask: utils.String(mask),
        PrimaryWinsServer: utils.String(primaryWinsServer),
        SecondaryWinsServer: utils.String(secondaryWinsServer),
    }
    return &result
}

func expandArmVirtualMachineVirtualNetwork(input []interface{}) *vmwarecloudsimple.VirtualNetwork {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    id := v["id"].(string)

    result := vmwarecloudsimple.VirtualNetwork{
        ID: utils.String(id),
    }
    return &result
}


func flattenArmVirtualMachineVirtualDiskController(input *[]vmwarecloudsimple.VirtualDiskController) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})


        results = append(results, v)
    }

    return results
}

func flattenArmVirtualMachineGuestOSCustomization(input *vmwarecloudsimple.GuestOSCustomization) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["dns_servers"] = utils.FlattenStringSlice(input.DnsServers)
    if hostName := input.HostName; hostName != nil {
        result["host_name"] = *hostName
    }
    if password := input.Password; password != nil {
        result["password"] = *password
    }
    if policyId := input.PolicyID; policyId != nil {
        result["policy_id"] = *policyId
    }
    if username := input.Username; username != nil {
        result["username"] = *username
    }

    return []interface{}{result}
}

func flattenArmVirtualMachineVirtualDisk(input *[]vmwarecloudsimple.VirtualDisk) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if controllerId := item.ControllerID; controllerId != nil {
            v["controller_id"] = *controllerId
        }
        v["independence_mode"] = string(item.IndependenceMode)
        if totalSize := item.TotalSize; totalSize != nil {
            v["total_size"] = *totalSize
        }
        if virtualDiskId := item.VirtualDiskID; virtualDiskId != nil {
            v["virtual_disk_id"] = *virtualDiskId
        }

        results = append(results, v)
    }

    return results
}

func flattenArmVirtualMachineVirtualNic(input *[]vmwarecloudsimple.VirtualNic) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        v["customization"] = flattenArmVirtualMachineGuestOSNICCustomization(item.Customization)
        v["ip_addresses"] = utils.FlattenStringSlice(item.IpAddresses)
        if macAddress := item.MacAddress; macAddress != nil {
            v["mac_address"] = *macAddress
        }
        v["network"] = flattenArmVirtualMachineVirtualNetwork(item.Network)
        v["nic_type"] = string(item.NicType)
        if powerOnBoot := item.PowerOnBoot; powerOnBoot != nil {
            v["power_on_boot"] = *powerOnBoot
        }
        if virtualNicId := item.VirtualNicID; virtualNicId != nil {
            v["virtual_nic_id"] = *virtualNicId
        }

        results = append(results, v)
    }

    return results
}

func flattenArmVirtualMachineResourcePool(input *vmwarecloudsimple.ResourcePool) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if id := input.ID; id != nil {
        result["id"] = *id
    }

    return []interface{}{result}
}

func flattenArmVirtualMachineGuestOSNICCustomization(input *vmwarecloudsimple.GuestOSNICCustomization) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["allocation"] = string(input.Allocation)
    result["dns_servers"] = utils.FlattenStringSlice(input.DnsServers)
    result["gateway"] = utils.FlattenStringSlice(input.Gateway)
    if ipAddress := input.IpAddress; ipAddress != nil {
        result["ip_address"] = *ipAddress
    }
    if mask := input.Mask; mask != nil {
        result["mask"] = *mask
    }
    if primaryWinsServer := input.PrimaryWinsServer; primaryWinsServer != nil {
        result["primary_wins_server"] = *primaryWinsServer
    }
    if secondaryWinsServer := input.SecondaryWinsServer; secondaryWinsServer != nil {
        result["secondary_wins_server"] = *secondaryWinsServer
    }

    return []interface{}{result}
}

func flattenArmVirtualMachineVirtualNetwork(input *vmwarecloudsimple.VirtualNetwork) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if id := input.ID; id != nil {
        result["id"] = *id
    }

    return []interface{}{result}
}
