// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmCluster() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmClusterCreate,
        Read: resourceArmClusterRead,
        Update: resourceArmClusterUpdate,
        Delete: resourceArmClusterDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "management_endpoint": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "node_types": {
                Type: schema.TypeList,
                Required: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "client_connection_endpoint_port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "http_gateway_endpoint_port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "is_primary": {
                            Type: schema.TypeBool,
                            Required: true,
                        },
                        "name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "vm_instance_count": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "application_ports": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "end_port": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "start_port": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                },
                            },
                        },
                        "capacities": {
                            Type: schema.TypeMap,
                            Optional: true,
                            Elem: &schema.Schema{Type: schema.TypeString},
                        },
                        "durability_level": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(servicefabric.Bronze),
                                string(servicefabric.Silver),
                                string(servicefabric.Gold),
                            }, false),
                            Default: string(servicefabric.Bronze),
                        },
                        "ephemeral_ports": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "end_port": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "start_port": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                },
                            },
                        },
                        "placement_properties": {
                            Type: schema.TypeMap,
                            Optional: true,
                            Elem: &schema.Schema{Type: schema.TypeString},
                        },
                        "reverse_proxy_endpoint_port": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                    },
                },
            },

            "azure_active_directory": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "client_application": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "cluster_application": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "tenant_id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "certificate": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "thumbprint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "thumbprint_secondary": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "x509store_name": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(servicefabric.AddressBook),
                                string(servicefabric.AuthRoot),
                                string(servicefabric.CertificateAuthority),
                                string(servicefabric.Disallowed),
                                string(servicefabric.My),
                                string(servicefabric.Root),
                                string(servicefabric.TrustedPeople),
                                string(servicefabric.TrustedPublisher),
                            }, false),
                            Default: string(servicefabric.AddressBook),
                        },
                    },
                },
            },

            "client_certificate_common_names": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "certificate_common_name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "certificate_issuer_thumbprint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "is_admin": {
                            Type: schema.TypeBool,
                            Required: true,
                        },
                    },
                },
            },

            "client_certificate_thumbprints": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "certificate_thumbprint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "is_admin": {
                            Type: schema.TypeBool,
                            Required: true,
                        },
                    },
                },
            },

            "cluster_code_version": {
                Type: schema.TypeString,
                Optional: true,
            },

            "diagnostics_storage_account_config": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "blob_endpoint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "protected_account_key_name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "queue_endpoint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "storage_account_name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "table_endpoint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "fabric_settings": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "parameters": {
                            Type: schema.TypeList,
                            Required: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "value": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "reliability_level": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(servicefabric.Bronze),
                    string(servicefabric.Silver),
                    string(servicefabric.Gold),
                    string(servicefabric.Platinum),
                }, false),
                Default: string(servicefabric.Bronze),
            },

            "reverse_proxy_certificate": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "thumbprint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "thumbprint_secondary": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "x509store_name": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(servicefabric.AddressBook),
                                string(servicefabric.AuthRoot),
                                string(servicefabric.CertificateAuthority),
                                string(servicefabric.Disallowed),
                                string(servicefabric.My),
                                string(servicefabric.Root),
                                string(servicefabric.TrustedPeople),
                                string(servicefabric.TrustedPublisher),
                            }, false),
                            Default: string(servicefabric.AddressBook),
                        },
                    },
                },
            },

            "upgrade_description": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "health_check_retry_timeout": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "health_check_stable_duration": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "health_check_wait_duration": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "health_policy": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "max_percent_unhealthy_applications": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "max_percent_unhealthy_nodes": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "upgrade_domain_timeout": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "upgrade_replica_set_check_timeout": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "upgrade_timeout": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "delta_health_policy": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "max_percent_delta_unhealthy_applications": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "max_percent_delta_unhealthy_nodes": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "max_percent_upgrade_domain_delta_unhealthy_nodes": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                },
                            },
                        },
                        "force_restart": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "override_user_upgrade_policy": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                    },
                },
            },

            "upgrade_mode": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(servicefabric.Automatic),
                    string(servicefabric.Manual),
                }, false),
                Default: string(servicefabric.Automatic),
            },

            "vm_image": {
                Type: schema.TypeString,
                Optional: true,
            },

            "available_cluster_versions": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "code_version": {
                            Type: schema.TypeString,
                            Computed: true,
                        },
                        "environment": {
                            Type: schema.TypeString,
                            Computed: true,
                        },
                        "support_expiry_utc": {
                            Type: schema.TypeString,
                            Computed: true,
                        },
                    },
                },
            },

            "cluster_endpoint": {
                Type: schema.TypeString,
                Computed: true,
            },

            "cluster_id": {
                Type: schema.TypeString,
                Computed: true,
            },

            "cluster_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmClusterCreate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_cluster", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    azureActiveDirectory := d.Get("azure_active_directory").([]interface{})
    certificate := d.Get("certificate").([]interface{})
    clientCertificateCommonNames := d.Get("client_certificate_common_names").([]interface{})
    clientCertificateThumbprints := d.Get("client_certificate_thumbprints").([]interface{})
    clusterCodeVersion := d.Get("cluster_code_version").(string)
    diagnosticsStorageAccountConfig := d.Get("diagnostics_storage_account_config").([]interface{})
    fabricSettings := d.Get("fabric_settings").([]interface{})
    managementEndpoint := d.Get("management_endpoint").(string)
    nodeTypes := d.Get("node_types").([]interface{})
    reliabilityLevel := d.Get("reliability_level").(string)
    reverseProxyCertificate := d.Get("reverse_proxy_certificate").([]interface{})
    upgradeDescription := d.Get("upgrade_description").([]interface{})
    upgradeMode := d.Get("upgrade_mode").(string)
    vmImage := d.Get("vm_image").(string)
    t := d.Get("tags").(map[string]interface{})

    parameters := servicefabric.Cluster{
        Location: utils.String(location),
        ClusterProperties: &servicefabric.ClusterProperties{
            AzureActiveDirectory: expandArmClusterAzureActiveDirectory(azureActiveDirectory),
            Certificate: expandArmClusterCertificateDescription(certificate),
            ClientCertificateCommonNames: expandArmClusterClientCertificateCommonName(clientCertificateCommonNames),
            ClientCertificateThumbprints: expandArmClusterClientCertificateThumbprint(clientCertificateThumbprints),
            ClusterCodeVersion: utils.String(clusterCodeVersion),
            DiagnosticsStorageAccountConfig: expandArmClusterDiagnosticsStorageAccountConfig(diagnosticsStorageAccountConfig),
            FabricSettings: expandArmClusterSettingsSectionDescription(fabricSettings),
            ManagementEndpoint: utils.String(managementEndpoint),
            NodeTypes: expandArmClusterNodeTypeDescription(nodeTypes),
            ReliabilityLevel: servicefabric.(reliabilityLevel),
            ReverseProxyCertificate: expandArmClusterCertificateDescription(reverseProxyCertificate),
            UpgradeDescription: expandArmClusterClusterUpgradePolicy(upgradeDescription),
            UpgradeMode: servicefabric.(upgradeMode),
            VMImage: utils.String(vmImage),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.Create(ctx, resourceGroup, name, parameters)
    if err != nil {
        return fmt.Errorf("Error creating Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Cluster %q (Resource Group %q) ID", name, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmClusterRead(d, meta)
}

func resourceArmClusterRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.Path["resourcegroups"]
    name := id.Path["clusters"]

    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Cluster %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    if clusterProperties := resp.ClusterProperties; clusterProperties != nil {
        if err := d.Set("available_cluster_versions", flattenArmClusterClusterVersionDetails(clusterProperties.AvailableClusterVersions)); err != nil {
            return fmt.Errorf("Error setting `available_cluster_versions`: %+v", err)
        }
        if err := d.Set("azure_active_directory", flattenArmClusterAzureActiveDirectory(clusterProperties.AzureActiveDirectory)); err != nil {
            return fmt.Errorf("Error setting `azure_active_directory`: %+v", err)
        }
        if err := d.Set("certificate", flattenArmClusterCertificateDescription(clusterProperties.Certificate)); err != nil {
            return fmt.Errorf("Error setting `certificate`: %+v", err)
        }
        if err := d.Set("client_certificate_common_names", flattenArmClusterClientCertificateCommonName(clusterProperties.ClientCertificateCommonNames)); err != nil {
            return fmt.Errorf("Error setting `client_certificate_common_names`: %+v", err)
        }
        if err := d.Set("client_certificate_thumbprints", flattenArmClusterClientCertificateThumbprint(clusterProperties.ClientCertificateThumbprints)); err != nil {
            return fmt.Errorf("Error setting `client_certificate_thumbprints`: %+v", err)
        }
        d.Set("cluster_code_version", clusterProperties.ClusterCodeVersion)
        d.Set("cluster_endpoint", clusterProperties.ClusterEndpoint)
        d.Set("cluster_id", clusterProperties.ClusterID)
        d.Set("cluster_state", string(clusterProperties.ClusterState))
        if err := d.Set("diagnostics_storage_account_config", flattenArmClusterDiagnosticsStorageAccountConfig(clusterProperties.DiagnosticsStorageAccountConfig)); err != nil {
            return fmt.Errorf("Error setting `diagnostics_storage_account_config`: %+v", err)
        }
        if err := d.Set("fabric_settings", flattenArmClusterSettingsSectionDescription(clusterProperties.FabricSettings)); err != nil {
            return fmt.Errorf("Error setting `fabric_settings`: %+v", err)
        }
        d.Set("management_endpoint", clusterProperties.ManagementEndpoint)
        if err := d.Set("node_types", flattenArmClusterNodeTypeDescription(clusterProperties.NodeTypes)); err != nil {
            return fmt.Errorf("Error setting `node_types`: %+v", err)
        }
        d.Set("provisioning_state", string(clusterProperties.ProvisioningState))
        d.Set("reliability_level", string(clusterProperties.ReliabilityLevel))
        if err := d.Set("reverse_proxy_certificate", flattenArmClusterCertificateDescription(clusterProperties.ReverseProxyCertificate)); err != nil {
            return fmt.Errorf("Error setting `reverse_proxy_certificate`: %+v", err)
        }
        if err := d.Set("upgrade_description", flattenArmClusterClusterUpgradePolicy(clusterProperties.UpgradeDescription)); err != nil {
            return fmt.Errorf("Error setting `upgrade_description`: %+v", err)
        }
        d.Set("upgrade_mode", string(clusterProperties.UpgradeMode))
        d.Set("vm_image", clusterProperties.VMImage)
    }
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}

func resourceArmClusterUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    azureActiveDirectory := d.Get("azure_active_directory").([]interface{})
    certificate := d.Get("certificate").([]interface{})
    clientCertificateCommonNames := d.Get("client_certificate_common_names").([]interface{})
    clientCertificateThumbprints := d.Get("client_certificate_thumbprints").([]interface{})
    clusterCodeVersion := d.Get("cluster_code_version").(string)
    diagnosticsStorageAccountConfig := d.Get("diagnostics_storage_account_config").([]interface{})
    fabricSettings := d.Get("fabric_settings").([]interface{})
    managementEndpoint := d.Get("management_endpoint").(string)
    nodeTypes := d.Get("node_types").([]interface{})
    reliabilityLevel := d.Get("reliability_level").(string)
    reverseProxyCertificate := d.Get("reverse_proxy_certificate").([]interface{})
    upgradeDescription := d.Get("upgrade_description").([]interface{})
    upgradeMode := d.Get("upgrade_mode").(string)
    vmImage := d.Get("vm_image").(string)
    t := d.Get("tags").(map[string]interface{})

    parameters := servicefabric.Cluster{
        ClusterProperties: &servicefabric.ClusterProperties{
            AzureActiveDirectory: expandArmClusterAzureActiveDirectory(azureActiveDirectory),
            Certificate: expandArmClusterCertificateDescription(certificate),
            ClientCertificateCommonNames: expandArmClusterClientCertificateCommonName(clientCertificateCommonNames),
            ClientCertificateThumbprints: expandArmClusterClientCertificateThumbprint(clientCertificateThumbprints),
            ClusterCodeVersion: utils.String(clusterCodeVersion),
            DiagnosticsStorageAccountConfig: expandArmClusterDiagnosticsStorageAccountConfig(diagnosticsStorageAccountConfig),
            FabricSettings: expandArmClusterSettingsSectionDescription(fabricSettings),
            ManagementEndpoint: utils.String(managementEndpoint),
            NodeTypes: expandArmClusterNodeTypeDescription(nodeTypes),
            ReliabilityLevel: servicefabric.(reliabilityLevel),
            ReverseProxyCertificate: expandArmClusterCertificateDescription(reverseProxyCertificate),
            UpgradeDescription: expandArmClusterClusterUpgradePolicy(upgradeDescription),
            UpgradeMode: servicefabric.(upgradeMode),
            VMImage: utils.String(vmImage),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.Update(ctx, resourceGroup, name, parameters)
    if err != nil {
        return fmt.Errorf("Error updating Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for update of Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    return resourceArmClusterRead(d, meta)
}

func resourceArmClusterDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.Path["resourcegroups"]
    name := id.Path["clusters"]

    if _, err := client.Delete(ctx, resourceGroup, name); err != nil {
        return fmt.Errorf("Error deleting Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    return nil
}

func expandArmClusterAzureActiveDirectory(input []interface{}) *servicefabric.AzureActiveDirectory {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    tenantId := v["tenant_id"].(string)
    clusterApplication := v["cluster_application"].(string)
    clientApplication := v["client_application"].(string)

    result := servicefabric.AzureActiveDirectory{
        ClientApplication: utils.String(clientApplication),
        ClusterApplication: utils.String(clusterApplication),
        TenantID: utils.String(tenantId),
    }
    return &result
}

func expandArmClusterCertificateDescription(input []interface{}) *servicefabric.CertificateDescription {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    thumbprint := v["thumbprint"].(string)
    thumbprintSecondary := v["thumbprint_secondary"].(string)
    x509storeName := v["x509store_name"].(string)

    result := servicefabric.CertificateDescription{
        Thumbprint: utils.String(thumbprint),
        ThumbprintSecondary: utils.String(thumbprintSecondary),
        X509StoreName: servicefabric.(x509storeName),
    }
    return &result
}

func expandArmClusterClientCertificateCommonName(input []interface{}) *[]servicefabric.ClientCertificateCommonName {
    results := make([]servicefabric.ClientCertificateCommonName, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        isAdmin := v["is_admin"].(bool)
        certificateCommonName := v["certificate_common_name"].(string)
        certificateIssuerThumbprint := v["certificate_issuer_thumbprint"].(string)

        result := servicefabric.ClientCertificateCommonName{
            CertificateCommonName: utils.String(certificateCommonName),
            CertificateIssuerThumbprint: utils.String(certificateIssuerThumbprint),
            IsAdmin: utils.Bool(isAdmin),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterClientCertificateThumbprint(input []interface{}) *[]servicefabric.ClientCertificateThumbprint {
    results := make([]servicefabric.ClientCertificateThumbprint, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        isAdmin := v["is_admin"].(bool)
        certificateThumbprint := v["certificate_thumbprint"].(string)

        result := servicefabric.ClientCertificateThumbprint{
            CertificateThumbprint: utils.String(certificateThumbprint),
            IsAdmin: utils.Bool(isAdmin),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterDiagnosticsStorageAccountConfig(input []interface{}) *servicefabric.DiagnosticsStorageAccountConfig {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    storageAccountName := v["storage_account_name"].(string)
    protectedAccountKeyName := v["protected_account_key_name"].(string)
    blobEndpoint := v["blob_endpoint"].(string)
    queueEndpoint := v["queue_endpoint"].(string)
    tableEndpoint := v["table_endpoint"].(string)

    result := servicefabric.DiagnosticsStorageAccountConfig{
        BlobEndpoint: utils.String(blobEndpoint),
        ProtectedAccountKeyName: utils.String(protectedAccountKeyName),
        QueueEndpoint: utils.String(queueEndpoint),
        StorageAccountName: utils.String(storageAccountName),
        TableEndpoint: utils.String(tableEndpoint),
    }
    return &result
}

func expandArmClusterSettingsSectionDescription(input []interface{}) *[]servicefabric.SettingsSectionDescription {
    results := make([]servicefabric.SettingsSectionDescription, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        parameters := v["parameters"].([]interface{})

        result := servicefabric.SettingsSectionDescription{
            Name: utils.String(name),
            Parameters: expandArmClusterSettingsParameterDescription(parameters),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterNodeTypeDescription(input []interface{}) *[]servicefabric.NodeTypeDescription {
    results := make([]servicefabric.NodeTypeDescription, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        placementProperties := v["placement_properties"].(map[string]interface{})
        capacities := v["capacities"].(map[string]interface{})
        clientConnectionEndpointPort := v["client_connection_endpoint_port"].(int)
        httpGatewayEndpointPort := v["http_gateway_endpoint_port"].(int)
        durabilityLevel := v["durability_level"].(string)
        applicationPorts := v["application_ports"].([]interface{})
        ephemeralPorts := v["ephemeral_ports"].([]interface{})
        isPrimary := v["is_primary"].(bool)
        vmInstanceCount := v["vm_instance_count"].(int)
        reverseProxyEndpointPort := v["reverse_proxy_endpoint_port"].(int)

        result := servicefabric.NodeTypeDescription{
            ApplicationPorts: expandArmClusterEndpointRangeDescription(applicationPorts),
            Capacities: utils.ExpandKeyValuePairs(capacities),
            ClientConnectionEndpointPort: utils.Int(clientConnectionEndpointPort),
            DurabilityLevel: servicefabric.(durabilityLevel),
            EphemeralPorts: expandArmClusterEndpointRangeDescription(ephemeralPorts),
            HTTPGatewayEndpointPort: utils.Int(httpGatewayEndpointPort),
            IsPrimary: utils.Bool(isPrimary),
            Name: utils.String(name),
            PlacementProperties: utils.ExpandKeyValuePairs(placementProperties),
            ReverseProxyEndpointPort: utils.Int(reverseProxyEndpointPort),
            VMInstanceCount: utils.Int(vmInstanceCount),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterClusterUpgradePolicy(input []interface{}) *servicefabric.ClusterUpgradePolicy {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    overrideUserUpgradePolicy := v["override_user_upgrade_policy"].(bool)
    forceRestart := v["force_restart"].(bool)
    upgradeReplicaSetCheckTimeout := v["upgrade_replica_set_check_timeout"].(string)
    healthCheckWaitDuration := v["health_check_wait_duration"].(string)
    healthCheckStableDuration := v["health_check_stable_duration"].(string)
    healthCheckRetryTimeout := v["health_check_retry_timeout"].(string)
    upgradeTimeout := v["upgrade_timeout"].(string)
    upgradeDomainTimeout := v["upgrade_domain_timeout"].(string)
    healthPolicy := v["health_policy"].([]interface{})
    deltaHealthPolicy := v["delta_health_policy"].([]interface{})

    result := servicefabric.ClusterUpgradePolicy{
        DeltaHealthPolicy: expandArmClusterClusterUpgradeDeltaHealthPolicy(deltaHealthPolicy),
        ForceRestart: utils.Bool(forceRestart),
        HealthCheckRetryTimeout: utils.String(healthCheckRetryTimeout),
        HealthCheckStableDuration: utils.String(healthCheckStableDuration),
        HealthCheckWaitDuration: utils.String(healthCheckWaitDuration),
        HealthPolicy: expandArmClusterClusterHealthPolicy(healthPolicy),
        OverrideUserUpgradePolicy: utils.Bool(overrideUserUpgradePolicy),
        UpgradeDomainTimeout: utils.String(upgradeDomainTimeout),
        UpgradeReplicaSetCheckTimeout: utils.String(upgradeReplicaSetCheckTimeout),
        UpgradeTimeout: utils.String(upgradeTimeout),
    }
    return &result
}

func expandArmClusterSettingsParameterDescription(input []interface{}) *[]servicefabric.SettingsParameterDescription {
    results := make([]servicefabric.SettingsParameterDescription, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        value := v["value"].(string)

        result := servicefabric.SettingsParameterDescription{
            Name: utils.String(name),
            Value: utils.String(value),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterEndpointRangeDescription(input []interface{}) *servicefabric.EndpointRangeDescription {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    startPort := v["start_port"].(int)
    endPort := v["end_port"].(int)

    result := servicefabric.EndpointRangeDescription{
        EndPort: utils.Int(endPort),
        StartPort: utils.Int(startPort),
    }
    return &result
}

func expandArmClusterClusterUpgradeDeltaHealthPolicy(input []interface{}) *servicefabric.ClusterUpgradeDeltaHealthPolicy {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    maxPercentDeltaUnhealthyNodes := v["max_percent_delta_unhealthy_nodes"].(int)
    maxPercentUpgradeDomainDeltaUnhealthyNodes := v["max_percent_upgrade_domain_delta_unhealthy_nodes"].(int)
    maxPercentDeltaUnhealthyApplications := v["max_percent_delta_unhealthy_applications"].(int)

    result := servicefabric.ClusterUpgradeDeltaHealthPolicy{
        MaxPercentDeltaUnhealthyApplications: utils.Int(maxPercentDeltaUnhealthyApplications),
        MaxPercentDeltaUnhealthyNodes: utils.Int(maxPercentDeltaUnhealthyNodes),
        MaxPercentUpgradeDomainDeltaUnhealthyNodes: utils.Int(maxPercentUpgradeDomainDeltaUnhealthyNodes),
    }
    return &result
}

func expandArmClusterClusterHealthPolicy(input []interface{}) *servicefabric.ClusterHealthPolicy {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    maxPercentUnhealthyNodes := v["max_percent_unhealthy_nodes"].(int)
    maxPercentUnhealthyApplications := v["max_percent_unhealthy_applications"].(int)

    result := servicefabric.ClusterHealthPolicy{
        MaxPercentUnhealthyApplications: utils.Int(maxPercentUnhealthyApplications),
        MaxPercentUnhealthyNodes: utils.Int(maxPercentUnhealthyNodes),
    }
    return &result
}


func flattenArmClusterClusterVersionDetails(input *[]servicefabric.ClusterVersionDetails) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if codeVersion := item.CodeVersion; codeVersion != nil {
            v["code_version"] = *codeVersion
        }
        v["environment"] = string(item.Environment)
        if supportExpiryUtc := item.SupportExpiryUtc; supportExpiryUtc != nil {
            v["support_expiry_utc"] = *supportExpiryUtc
        }

        results = append(results, v)
    }

    return results
}

func flattenArmClusterAzureActiveDirectory(input *servicefabric.AzureActiveDirectory) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if clientApplication := input.ClientApplication; clientApplication != nil {
        result["client_application"] = *clientApplication
    }
    if clusterApplication := input.ClusterApplication; clusterApplication != nil {
        result["cluster_application"] = *clusterApplication
    }
    if tenantId := input.TenantID; tenantId != nil {
        result["tenant_id"] = *tenantId
    }

    return []interface{}{result}
}

func flattenArmClusterCertificateDescription(input *servicefabric.CertificateDescription) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if thumbprint := input.Thumbprint; thumbprint != nil {
        result["thumbprint"] = *thumbprint
    }
    if thumbprintSecondary := input.ThumbprintSecondary; thumbprintSecondary != nil {
        result["thumbprint_secondary"] = *thumbprintSecondary
    }
    result["x509store_name"] = string(input.X509StoreName)

    return []interface{}{result}
}

func flattenArmClusterClientCertificateCommonName(input *[]servicefabric.ClientCertificateCommonName) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if certificateCommonName := item.CertificateCommonName; certificateCommonName != nil {
            v["certificate_common_name"] = *certificateCommonName
        }
        if certificateIssuerThumbprint := item.CertificateIssuerThumbprint; certificateIssuerThumbprint != nil {
            v["certificate_issuer_thumbprint"] = *certificateIssuerThumbprint
        }
        if isAdmin := item.IsAdmin; isAdmin != nil {
            v["is_admin"] = *isAdmin
        }

        results = append(results, v)
    }

    return results
}

func flattenArmClusterClientCertificateThumbprint(input *[]servicefabric.ClientCertificateThumbprint) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if certificateThumbprint := item.CertificateThumbprint; certificateThumbprint != nil {
            v["certificate_thumbprint"] = *certificateThumbprint
        }
        if isAdmin := item.IsAdmin; isAdmin != nil {
            v["is_admin"] = *isAdmin
        }

        results = append(results, v)
    }

    return results
}

func flattenArmClusterDiagnosticsStorageAccountConfig(input *servicefabric.DiagnosticsStorageAccountConfig) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if blobEndpoint := input.BlobEndpoint; blobEndpoint != nil {
        result["blob_endpoint"] = *blobEndpoint
    }
    if protectedAccountKeyName := input.ProtectedAccountKeyName; protectedAccountKeyName != nil {
        result["protected_account_key_name"] = *protectedAccountKeyName
    }
    if queueEndpoint := input.QueueEndpoint; queueEndpoint != nil {
        result["queue_endpoint"] = *queueEndpoint
    }
    if storageAccountName := input.StorageAccountName; storageAccountName != nil {
        result["storage_account_name"] = *storageAccountName
    }
    if tableEndpoint := input.TableEndpoint; tableEndpoint != nil {
        result["table_endpoint"] = *tableEndpoint
    }

    return []interface{}{result}
}

func flattenArmClusterSettingsSectionDescription(input *[]servicefabric.SettingsSectionDescription) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        v["parameters"] = flattenArmClusterSettingsParameterDescription(item.Parameters)

        results = append(results, v)
    }

    return results
}

func flattenArmClusterNodeTypeDescription(input *[]servicefabric.NodeTypeDescription) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        v["application_ports"] = flattenArmClusterEndpointRangeDescription(item.ApplicationPorts)
        v["capacities"] = utils.FlattenKeyValuePairs(item.Capacities)
        if clientConnectionEndpointPort := item.ClientConnectionEndpointPort; clientConnectionEndpointPort != nil {
            v["client_connection_endpoint_port"] = *clientConnectionEndpointPort
        }
        v["durability_level"] = string(item.DurabilityLevel)
        v["ephemeral_ports"] = flattenArmClusterEndpointRangeDescription(item.EphemeralPorts)
        if httpGatewayEndpointPort := item.HTTPGatewayEndpointPort; httpGatewayEndpointPort != nil {
            v["http_gateway_endpoint_port"] = *httpGatewayEndpointPort
        }
        if isPrimary := item.IsPrimary; isPrimary != nil {
            v["is_primary"] = *isPrimary
        }
        v["placement_properties"] = utils.FlattenKeyValuePairs(item.PlacementProperties)
        if reverseProxyEndpointPort := item.ReverseProxyEndpointPort; reverseProxyEndpointPort != nil {
            v["reverse_proxy_endpoint_port"] = *reverseProxyEndpointPort
        }
        if vmInstanceCount := item.VMInstanceCount; vmInstanceCount != nil {
            v["vm_instance_count"] = *vmInstanceCount
        }

        results = append(results, v)
    }

    return results
}

func flattenArmClusterClusterUpgradePolicy(input *servicefabric.ClusterUpgradePolicy) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["delta_health_policy"] = flattenArmClusterClusterUpgradeDeltaHealthPolicy(input.DeltaHealthPolicy)
    if forceRestart := input.ForceRestart; forceRestart != nil {
        result["force_restart"] = *forceRestart
    }
    if healthCheckRetryTimeout := input.HealthCheckRetryTimeout; healthCheckRetryTimeout != nil {
        result["health_check_retry_timeout"] = *healthCheckRetryTimeout
    }
    if healthCheckStableDuration := input.HealthCheckStableDuration; healthCheckStableDuration != nil {
        result["health_check_stable_duration"] = *healthCheckStableDuration
    }
    if healthCheckWaitDuration := input.HealthCheckWaitDuration; healthCheckWaitDuration != nil {
        result["health_check_wait_duration"] = *healthCheckWaitDuration
    }
    result["health_policy"] = flattenArmClusterClusterHealthPolicy(input.HealthPolicy)
    if overrideUserUpgradePolicy := input.OverrideUserUpgradePolicy; overrideUserUpgradePolicy != nil {
        result["override_user_upgrade_policy"] = *overrideUserUpgradePolicy
    }
    if upgradeDomainTimeout := input.UpgradeDomainTimeout; upgradeDomainTimeout != nil {
        result["upgrade_domain_timeout"] = *upgradeDomainTimeout
    }
    if upgradeReplicaSetCheckTimeout := input.UpgradeReplicaSetCheckTimeout; upgradeReplicaSetCheckTimeout != nil {
        result["upgrade_replica_set_check_timeout"] = *upgradeReplicaSetCheckTimeout
    }
    if upgradeTimeout := input.UpgradeTimeout; upgradeTimeout != nil {
        result["upgrade_timeout"] = *upgradeTimeout
    }

    return []interface{}{result}
}

func flattenArmClusterSettingsParameterDescription(input *[]servicefabric.SettingsParameterDescription) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if value := item.Value; value != nil {
            v["value"] = *value
        }

        results = append(results, v)
    }

    return results
}

func flattenArmClusterEndpointRangeDescription(input *servicefabric.EndpointRangeDescription) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if endPort := input.EndPort; endPort != nil {
        result["end_port"] = *endPort
    }
    if startPort := input.StartPort; startPort != nil {
        result["start_port"] = *startPort
    }

    return []interface{}{result}
}

func flattenArmClusterClusterUpgradeDeltaHealthPolicy(input *servicefabric.ClusterUpgradeDeltaHealthPolicy) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if maxPercentDeltaUnhealthyApplications := input.MaxPercentDeltaUnhealthyApplications; maxPercentDeltaUnhealthyApplications != nil {
        result["max_percent_delta_unhealthy_applications"] = *maxPercentDeltaUnhealthyApplications
    }
    if maxPercentDeltaUnhealthyNodes := input.MaxPercentDeltaUnhealthyNodes; maxPercentDeltaUnhealthyNodes != nil {
        result["max_percent_delta_unhealthy_nodes"] = *maxPercentDeltaUnhealthyNodes
    }
    if maxPercentUpgradeDomainDeltaUnhealthyNodes := input.MaxPercentUpgradeDomainDeltaUnhealthyNodes; maxPercentUpgradeDomainDeltaUnhealthyNodes != nil {
        result["max_percent_upgrade_domain_delta_unhealthy_nodes"] = *maxPercentUpgradeDomainDeltaUnhealthyNodes
    }

    return []interface{}{result}
}

func flattenArmClusterClusterHealthPolicy(input *servicefabric.ClusterHealthPolicy) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if maxPercentUnhealthyApplications := input.MaxPercentUnhealthyApplications; maxPercentUnhealthyApplications != nil {
        result["max_percent_unhealthy_applications"] = *maxPercentUnhealthyApplications
    }
    if maxPercentUnhealthyNodes := input.MaxPercentUnhealthyNodes; maxPercentUnhealthyNodes != nil {
        result["max_percent_unhealthy_nodes"] = *maxPercentUnhealthyNodes
    }

    return []interface{}{result}
}
