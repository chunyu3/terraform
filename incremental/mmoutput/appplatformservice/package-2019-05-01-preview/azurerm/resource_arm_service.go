// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmService() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmServiceCreate,
        Read: resourceArmServiceRead,
        Update: resourceArmServiceUpdate,
        Delete: resourceArmServiceDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "config_server_properties": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "config_server": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "git_property": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "uri": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "host_key": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "host_key_algorithm": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "password": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "private_key": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "search_paths": {
                                                    Type: schema.TypeList,
                                                    Optional: true,
                                                    Elem: &schema.Schema{
                                                        Type: schema.TypeString,
                                                    },
                                                },
                                                "strict_host_key_checking": {
                                                    Type: schema.TypeBool,
                                                    Optional: true,
                                                },
                                                "username": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "error": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "code": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "message": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "trace": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "app_insight_instrumentation_key": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "enabled": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "error": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "code": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "message": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "service_id": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "version": {
                Type: schema.TypeInt,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmServiceCreate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).servicesClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Service %q (Resource Group %q): %+v", name, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_service", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    configServerProperties := d.Get("config_server_properties").([]interface{})
    trace := d.Get("trace").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    resource := appplatform.ServiceResource{
        Location: utils.String(location),
        ClusterResourceProperties: &appplatform.ClusterResourceProperties{
            ConfigServerProperties: expandArmServiceConfigServerProperties(configServerProperties),
            Trace: expandArmServiceTraceProperties(trace),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.CreateOrUpdate(ctx, resourceGroup, name, resource)
    if err != nil {
        return fmt.Errorf("Error creating Service %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Service %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Service %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Service %q (Resource Group %q) ID", name, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmServiceRead(d, meta)
}

func resourceArmServiceRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).servicesClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["Spring"]

    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Service %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Service %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    if clusterResourceProperties := resp.ClusterResourceProperties; clusterResourceProperties != nil {
        if err := d.Set("config_server_properties", flattenArmServiceConfigServerProperties(clusterResourceProperties.ConfigServerProperties)); err != nil {
            return fmt.Errorf("Error setting `config_server_properties`: %+v", err)
        }
        d.Set("provisioning_state", string(clusterResourceProperties.ProvisioningState))
        d.Set("service_id", clusterResourceProperties.ServiceID)
        if err := d.Set("trace", flattenArmServiceTraceProperties(clusterResourceProperties.Trace)); err != nil {
            return fmt.Errorf("Error setting `trace`: %+v", err)
        }
        d.Set("version", int(*clusterResourceProperties.Version))
    }
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}

func resourceArmServiceUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).servicesClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    configServerProperties := d.Get("config_server_properties").([]interface{})
    trace := d.Get("trace").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    resource := appplatform.ServiceResource{
        Location: utils.String(location),
        ClusterResourceProperties: &appplatform.ClusterResourceProperties{
            ConfigServerProperties: expandArmServiceConfigServerProperties(configServerProperties),
            Trace: expandArmServiceTraceProperties(trace),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.Update(ctx, resourceGroup, name, resource)
    if err != nil {
        return fmt.Errorf("Error updating Service %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for update of Service %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    return resourceArmServiceRead(d, meta)
}

func resourceArmServiceDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).servicesClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["Spring"]

    future, err := client.Delete(ctx, resourceGroup, name)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Service %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Service %q (Resource Group %q): %+v", name, resourceGroup, err)
        }
    }

    return nil
}

func expandArmServiceConfigServerProperties(input []interface{}) *appplatform.ConfigServerProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    error := v["error"].([]interface{})
    configServer := v["config_server"].([]interface{})

    result := appplatform.ConfigServerProperties{
        ConfigServer: expandArmServiceConfigServerSettings(configServer),
        Error: expandArmServiceError(error),
    }
    return &result
}

func expandArmServiceTraceProperties(input []interface{}) *appplatform.TraceProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    error := v["error"].([]interface{})
    enabled := v["enabled"].(bool)
    appInsightInstrumentationKey := v["app_insight_instrumentation_key"].(string)

    result := appplatform.TraceProperties{
        AppInsightInstrumentationKey: utils.String(appInsightInstrumentationKey),
        Enabled: utils.Bool(enabled),
        Error: expandArmServiceError(error),
    }
    return &result
}

func expandArmServiceConfigServerSettings(input []interface{}) *appplatform.ConfigServerSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    gitProperty := v["git_property"].([]interface{})

    result := appplatform.ConfigServerSettings{
        GitProperty: expandArmServiceConfigServerGitProperty(gitProperty),
    }
    return &result
}

func expandArmServiceError(input []interface{}) *appplatform.Error {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    code := v["code"].(string)
    message := v["message"].(string)

    result := appplatform.Error{
        Code: utils.String(code),
        Message: utils.String(message),
    }
    return &result
}

func expandArmServiceConfigServerGitProperty(input []interface{}) *appplatform.ConfigServerGitProperty {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    uri := v["uri"].(string)
    label := v["label"].(string)
    searchPaths := v["search_paths"].([]interface{})
    username := v["username"].(string)
    password := v["password"].(string)
    hostKey := v["host_key"].(string)
    hostKeyAlgorithm := v["host_key_algorithm"].(string)
    privateKey := v["private_key"].(string)
    strictHostKeyChecking := v["strict_host_key_checking"].(bool)

    result := appplatform.ConfigServerGitProperty{
        HostKey: utils.String(hostKey),
        HostKeyAlgorithm: utils.String(hostKeyAlgorithm),
        Label: utils.String(label),
        Password: utils.String(password),
        PrivateKey: utils.String(privateKey),
        SearchPaths: utils.ExpandStringSlice(searchPaths),
        StrictHostKeyChecking: utils.Bool(strictHostKeyChecking),
        Uri: utils.String(uri),
        Username: utils.String(username),
    }
    return &result
}


func flattenArmServiceConfigServerProperties(input *appplatform.ConfigServerProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["config_server"] = flattenArmServiceConfigServerSettings(input.ConfigServer)
    result["error"] = flattenArmServiceError(input.Error)

    return []interface{}{result}
}

func flattenArmServiceTraceProperties(input *appplatform.TraceProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if appInsightInstrumentationKey := input.AppInsightInstrumentationKey; appInsightInstrumentationKey != nil {
        result["app_insight_instrumentation_key"] = *appInsightInstrumentationKey
    }
    if enabled := input.Enabled; enabled != nil {
        result["enabled"] = *enabled
    }
    result["error"] = flattenArmServiceError(input.Error)

    return []interface{}{result}
}

func flattenArmServiceConfigServerSettings(input *appplatform.ConfigServerSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["git_property"] = flattenArmServiceConfigServerGitProperty(input.GitProperty)

    return []interface{}{result}
}

func flattenArmServiceError(input *appplatform.Error) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if code := input.Code; code != nil {
        result["code"] = *code
    }
    if message := input.Message; message != nil {
        result["message"] = *message
    }

    return []interface{}{result}
}

func flattenArmServiceConfigServerGitProperty(input *appplatform.ConfigServerGitProperty) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if hostKey := input.HostKey; hostKey != nil {
        result["host_key"] = *hostKey
    }
    if hostKeyAlgorithm := input.HostKeyAlgorithm; hostKeyAlgorithm != nil {
        result["host_key_algorithm"] = *hostKeyAlgorithm
    }
    if label := input.Label; label != nil {
        result["label"] = *label
    }
    if password := input.Password; password != nil {
        result["password"] = *password
    }
    if privateKey := input.PrivateKey; privateKey != nil {
        result["private_key"] = *privateKey
    }
    result["search_paths"] = utils.FlattenStringSlice(input.SearchPaths)
    if strictHostKeyChecking := input.StrictHostKeyChecking; strictHostKeyChecking != nil {
        result["strict_host_key_checking"] = *strictHostKeyChecking
    }
    if uri := input.Uri; uri != nil {
        result["uri"] = *uri
    }
    if username := input.Username; username != nil {
        result["username"] = *username
    }

    return []interface{}{result}
}
