// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmStreamingPolicy() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmStreamingPolicyCreateUpdate,
        Read: resourceArmStreamingPolicyRead,
        Update: resourceArmStreamingPolicyCreateUpdate,
        Delete: resourceArmStreamingPolicyDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "account_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "common_encryption_cbcs": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "clear_tracks": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "track_selections": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "operation": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.Equal),
                                                    }, false),
                                                },
                                                "property": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.FourCC),
                                                    }, false),
                                                },
                                                "value": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "content_keys": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "default_key": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "key_to_track_mappings": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "tracks": {
                                                    Type: schema.TypeList,
                                                    Optional: true,
                                                    Elem: &schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                            "track_selections": {
                                                                Type: schema.TypeList,
                                                                Optional: true,
                                                                Elem: &schema.Resource{
                                                                    Schema: map[string]*schema.Schema{
                                                                        "operation": {
                                                                            Type: schema.TypeString,
                                                                            Required: true,
                                                                            ValidateFunc: validation.StringInSlice([]string{
                                                                                string(mediaservices.Unknown),
                                                                                string(mediaservices.Equal),
                                                                            }, false),
                                                                        },
                                                                        "property": {
                                                                            Type: schema.TypeString,
                                                                            Required: true,
                                                                            ValidateFunc: validation.StringInSlice([]string{
                                                                                string(mediaservices.Unknown),
                                                                                string(mediaservices.FourCC),
                                                                            }, false),
                                                                        },
                                                                        "value": {
                                                                            Type: schema.TypeString,
                                                                            Optional: true,
                                                                        },
                                                                    },
                                                                },
                                                            },
                                                        },
                                                    },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "drm": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "fair_play": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "allow_persistent_license": {
                                                    Type: schema.TypeBool,
                                                    Required: true,
                                                },
                                                "custom_license_acquisition_url_template": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "play_ready": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "custom_license_acquisition_url_template": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "play_ready_custom_attributes": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "widevine": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "custom_license_acquisition_url_template": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "enabled_protocols": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "dash": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "download": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "hls": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "smooth_streaming": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "common_encryption_cenc": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "clear_tracks": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "track_selections": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "operation": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.Equal),
                                                    }, false),
                                                },
                                                "property": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.FourCC),
                                                    }, false),
                                                },
                                                "value": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "content_keys": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "default_key": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "key_to_track_mappings": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "tracks": {
                                                    Type: schema.TypeList,
                                                    Optional: true,
                                                    Elem: &schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                            "track_selections": {
                                                                Type: schema.TypeList,
                                                                Optional: true,
                                                                Elem: &schema.Resource{
                                                                    Schema: map[string]*schema.Schema{
                                                                        "operation": {
                                                                            Type: schema.TypeString,
                                                                            Required: true,
                                                                            ValidateFunc: validation.StringInSlice([]string{
                                                                                string(mediaservices.Unknown),
                                                                                string(mediaservices.Equal),
                                                                            }, false),
                                                                        },
                                                                        "property": {
                                                                            Type: schema.TypeString,
                                                                            Required: true,
                                                                            ValidateFunc: validation.StringInSlice([]string{
                                                                                string(mediaservices.Unknown),
                                                                                string(mediaservices.FourCC),
                                                                            }, false),
                                                                        },
                                                                        "value": {
                                                                            Type: schema.TypeString,
                                                                            Optional: true,
                                                                        },
                                                                    },
                                                                },
                                                            },
                                                        },
                                                    },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "drm": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "play_ready": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "custom_license_acquisition_url_template": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "play_ready_custom_attributes": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "widevine": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "custom_license_acquisition_url_template": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "enabled_protocols": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "dash": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "download": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "hls": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "smooth_streaming": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "default_content_key_policy_name": {
                Type: schema.TypeString,
                Optional: true,
            },

            "envelope_encryption": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "clear_tracks": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "track_selections": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "operation": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.Equal),
                                                    }, false),
                                                },
                                                "property": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.FourCC),
                                                    }, false),
                                                },
                                                "value": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "content_keys": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "default_key": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "key_to_track_mappings": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "tracks": {
                                                    Type: schema.TypeList,
                                                    Optional: true,
                                                    Elem: &schema.Resource{
                                                        Schema: map[string]*schema.Schema{
                                                            "track_selections": {
                                                                Type: schema.TypeList,
                                                                Optional: true,
                                                                Elem: &schema.Resource{
                                                                    Schema: map[string]*schema.Schema{
                                                                        "operation": {
                                                                            Type: schema.TypeString,
                                                                            Required: true,
                                                                            ValidateFunc: validation.StringInSlice([]string{
                                                                                string(mediaservices.Unknown),
                                                                                string(mediaservices.Equal),
                                                                            }, false),
                                                                        },
                                                                        "property": {
                                                                            Type: schema.TypeString,
                                                                            Required: true,
                                                                            ValidateFunc: validation.StringInSlice([]string{
                                                                                string(mediaservices.Unknown),
                                                                                string(mediaservices.FourCC),
                                                                            }, false),
                                                                        },
                                                                        "value": {
                                                                            Type: schema.TypeString,
                                                                            Optional: true,
                                                                        },
                                                                    },
                                                                },
                                                            },
                                                        },
                                                    },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "custom_key_acquisition_url_template": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "enabled_protocols": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "dash": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "download": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "hls": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "smooth_streaming": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "no_encryption": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "enabled_protocols": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "dash": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "download": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "hls": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "smooth_streaming": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },
        },
    }
}

func resourceArmStreamingPolicyCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).streamingPoliciesClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    accountName := d.Get("account_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, accountName, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Streaming Policy %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_streaming_policy", *existing.ID)
        }
    }

    commonEncryptionCbcs := d.Get("common_encryption_cbcs").([]interface{})
    commonEncryptionCenc := d.Get("common_encryption_cenc").([]interface{})
    defaultContentKeyPolicyName := d.Get("default_content_key_policy_name").(string)
    envelopeEncryption := d.Get("envelope_encryption").([]interface{})
    noEncryption := d.Get("no_encryption").([]interface{})

    parameters := mediaservices.StreamingPolicy{
        StreamingPolicyProperties: &mediaservices.StreamingPolicyProperties{
            CommonEncryptionCbcs: expandArmStreamingPolicyCommonEncryptionCbcs(commonEncryptionCbcs),
            CommonEncryptionCenc: expandArmStreamingPolicyCommonEncryptionCenc(commonEncryptionCenc),
            DefaultContentKeyPolicyName: utils.String(defaultContentKeyPolicyName),
            EnvelopeEncryption: expandArmStreamingPolicyEnvelopeEncryption(envelopeEncryption),
            NoEncryption: expandArmStreamingPolicyNoEncryption(noEncryption),
        },
    }


    if _, err := client.Create(ctx, resourceGroup, accountName, name, parameters); err != nil {
        return fmt.Errorf("Error creating Streaming Policy %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, accountName, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Streaming Policy %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Streaming Policy %q (Account Name %q / Resource Group %q) ID", name, accountName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmStreamingPolicyRead(d, meta)
}

func resourceArmStreamingPolicyRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).streamingPoliciesClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    accountName := id.Path["mediaServices"]
    name := id.Path["streamingPolicies"]

    resp, err := client.Get(ctx, resourceGroup, accountName, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Streaming Policy %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Streaming Policy %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    d.Set("account_name", accountName)
    d.Set("type", resp.Type)

    return nil
}


func resourceArmStreamingPolicyDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).streamingPoliciesClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    accountName := id.Path["mediaServices"]
    name := id.Path["streamingPolicies"]

    if _, err := client.Delete(ctx, resourceGroup, accountName, name); err != nil {
        return fmt.Errorf("Error deleting Streaming Policy %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
    }

    return nil
}

func expandArmStreamingPolicyCommonEncryptionCbcs(input []interface{}) *mediaservices.CommonEncryptionCbcs {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enabledProtocols := v["enabled_protocols"].([]interface{})
    clearTracks := v["clear_tracks"].([]interface{})
    contentKeys := v["content_keys"].([]interface{})
    drm := v["drm"].([]interface{})

    result := mediaservices.CommonEncryptionCbcs{
        ClearTracks: expandArmStreamingPolicyTrackSelection(clearTracks),
        ContentKeys: expandArmStreamingPolicyStreamingPolicyContentKeys(contentKeys),
        Drm: expandArmStreamingPolicyCbcsDrmConfiguration(drm),
        EnabledProtocols: expandArmStreamingPolicyEnabledProtocols(enabledProtocols),
    }
    return &result
}

func expandArmStreamingPolicyCommonEncryptionCenc(input []interface{}) *mediaservices.CommonEncryptionCenc {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enabledProtocols := v["enabled_protocols"].([]interface{})
    clearTracks := v["clear_tracks"].([]interface{})
    contentKeys := v["content_keys"].([]interface{})
    drm := v["drm"].([]interface{})

    result := mediaservices.CommonEncryptionCenc{
        ClearTracks: expandArmStreamingPolicyTrackSelection(clearTracks),
        ContentKeys: expandArmStreamingPolicyStreamingPolicyContentKeys(contentKeys),
        Drm: expandArmStreamingPolicyCencDrmConfiguration(drm),
        EnabledProtocols: expandArmStreamingPolicyEnabledProtocols(enabledProtocols),
    }
    return &result
}

func expandArmStreamingPolicyEnvelopeEncryption(input []interface{}) *mediaservices.EnvelopeEncryption {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enabledProtocols := v["enabled_protocols"].([]interface{})
    clearTracks := v["clear_tracks"].([]interface{})
    contentKeys := v["content_keys"].([]interface{})
    customKeyAcquisitionUrlTemplate := v["custom_key_acquisition_url_template"].(string)

    result := mediaservices.EnvelopeEncryption{
        ClearTracks: expandArmStreamingPolicyTrackSelection(clearTracks),
        ContentKeys: expandArmStreamingPolicyStreamingPolicyContentKeys(contentKeys),
        CustomKeyAcquisitionURLTemplate: utils.String(customKeyAcquisitionUrlTemplate),
        EnabledProtocols: expandArmStreamingPolicyEnabledProtocols(enabledProtocols),
    }
    return &result
}

func expandArmStreamingPolicyNoEncryption(input []interface{}) *mediaservices.NoEncryption {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enabledProtocols := v["enabled_protocols"].([]interface{})

    result := mediaservices.NoEncryption{
        EnabledProtocols: expandArmStreamingPolicyEnabledProtocols(enabledProtocols),
    }
    return &result
}

func expandArmStreamingPolicyTrackSelection(input []interface{}) *[]mediaservices.TrackSelection {
    results := make([]mediaservices.TrackSelection, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        trackSelections := v["track_selections"].([]interface{})

        result := mediaservices.TrackSelection{
            TrackSelections: expandArmStreamingPolicyTrackPropertyCondition(trackSelections),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmStreamingPolicyStreamingPolicyContentKeys(input []interface{}) *mediaservices.StreamingPolicyContentKeys {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    defaultKey := v["default_key"].([]interface{})
    keyToTrackMappings := v["key_to_track_mappings"].([]interface{})

    result := mediaservices.StreamingPolicyContentKeys{
        DefaultKey: expandArmStreamingPolicyDefaultKey(defaultKey),
        KeyToTrackMappings: expandArmStreamingPolicyStreamingPolicyContentKey(keyToTrackMappings),
    }
    return &result
}

func expandArmStreamingPolicyCbcsDrmConfiguration(input []interface{}) *mediaservices.CbcsDrmConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    fairPlay := v["fair_play"].([]interface{})
    playReady := v["play_ready"].([]interface{})
    widevine := v["widevine"].([]interface{})

    result := mediaservices.CbcsDrmConfiguration{
        FairPlay: expandArmStreamingPolicyStreamingPolicyFairPlayConfiguration(fairPlay),
        PlayReady: expandArmStreamingPolicyStreamingPolicyPlayReadyConfiguration(playReady),
        Widevine: expandArmStreamingPolicyStreamingPolicyWidevineConfiguration(widevine),
    }
    return &result
}

func expandArmStreamingPolicyEnabledProtocols(input []interface{}) *mediaservices.EnabledProtocols {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    download := v["download"].(bool)
    dash := v["dash"].(bool)
    hls := v["hls"].(bool)
    smoothStreaming := v["smooth_streaming"].(bool)

    result := mediaservices.EnabledProtocols{
        Dash: utils.Bool(dash),
        Download: utils.Bool(download),
        Hls: utils.Bool(hls),
        SmoothStreaming: utils.Bool(smoothStreaming),
    }
    return &result
}

func expandArmStreamingPolicyCencDrmConfiguration(input []interface{}) *mediaservices.CencDrmConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    playReady := v["play_ready"].([]interface{})
    widevine := v["widevine"].([]interface{})

    result := mediaservices.CencDrmConfiguration{
        PlayReady: expandArmStreamingPolicyStreamingPolicyPlayReadyConfiguration(playReady),
        Widevine: expandArmStreamingPolicyStreamingPolicyWidevineConfiguration(widevine),
    }
    return &result
}

func expandArmStreamingPolicyTrackPropertyCondition(input []interface{}) *[]mediaservices.TrackPropertyCondition {
    results := make([]mediaservices.TrackPropertyCondition, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        property := v["property"].(string)
        operation := v["operation"].(string)
        value := v["value"].(string)

        result := mediaservices.TrackPropertyCondition{
            Operation: mediaservices.TrackPropertyCompareOperation(operation),
            Property: mediaservices.TrackPropertyType(property),
            Value: utils.String(value),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmStreamingPolicyDefaultKey(input []interface{}) *mediaservices.DefaultKey {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    label := v["label"].(string)
    policyName := v["policy_name"].(string)

    result := mediaservices.DefaultKey{
        Label: utils.String(label),
        PolicyName: utils.String(policyName),
    }
    return &result
}

func expandArmStreamingPolicyStreamingPolicyContentKey(input []interface{}) *[]mediaservices.StreamingPolicyContentKey {
    results := make([]mediaservices.StreamingPolicyContentKey, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        label := v["label"].(string)
        policyName := v["policy_name"].(string)
        tracks := v["tracks"].([]interface{})

        result := mediaservices.StreamingPolicyContentKey{
            Label: utils.String(label),
            PolicyName: utils.String(policyName),
            Tracks: expandArmStreamingPolicyTrackSelection(tracks),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmStreamingPolicyStreamingPolicyFairPlayConfiguration(input []interface{}) *mediaservices.StreamingPolicyFairPlayConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    customLicenseAcquisitionUrlTemplate := v["custom_license_acquisition_url_template"].(string)
    allowPersistentLicense := v["allow_persistent_license"].(bool)

    result := mediaservices.StreamingPolicyFairPlayConfiguration{
        AllowPersistentLicense: utils.Bool(allowPersistentLicense),
        CustomLicenseAcquisitionURLTemplate: utils.String(customLicenseAcquisitionUrlTemplate),
    }
    return &result
}

func expandArmStreamingPolicyStreamingPolicyPlayReadyConfiguration(input []interface{}) *mediaservices.StreamingPolicyPlayReadyConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    customLicenseAcquisitionUrlTemplate := v["custom_license_acquisition_url_template"].(string)
    playReadyCustomAttributes := v["play_ready_custom_attributes"].(string)

    result := mediaservices.StreamingPolicyPlayReadyConfiguration{
        CustomLicenseAcquisitionURLTemplate: utils.String(customLicenseAcquisitionUrlTemplate),
        PlayReadyCustomAttributes: utils.String(playReadyCustomAttributes),
    }
    return &result
}

func expandArmStreamingPolicyStreamingPolicyWidevineConfiguration(input []interface{}) *mediaservices.StreamingPolicyWidevineConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    customLicenseAcquisitionUrlTemplate := v["custom_license_acquisition_url_template"].(string)

    result := mediaservices.StreamingPolicyWidevineConfiguration{
        CustomLicenseAcquisitionURLTemplate: utils.String(customLicenseAcquisitionUrlTemplate),
    }
    return &result
}
