// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmSoftwareUpdateConfiguration() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmSoftwareUpdateConfigurationCreateUpdate,
        Read: resourceArmSoftwareUpdateConfigurationRead,
        Update: resourceArmSoftwareUpdateConfigurationCreateUpdate,
        Delete: resourceArmSoftwareUpdateConfigurationDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "automation_account_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "schedule_info": {
                Type: schema.TypeList,
                Required: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "advanced_schedule": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "month_days": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeInt,
                                        },
                                    },
                                    "monthly_occurrences": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "day": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(automation.Monday),
                                                        string(automation.Tuesday),
                                                        string(automation.Wednesday),
                                                        string(automation.Thursday),
                                                        string(automation.Friday),
                                                        string(automation.Saturday),
                                                        string(automation.Sunday),
                                                    }, false),
                                                    Default: string(automation.Monday),
                                                },
                                                "occurrence": {
                                                    Type: schema.TypeInt,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "week_days": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                },
                            },
                        },
                        "creation_time": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateRFC3339Date,
                        },
                        "description": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "expiry_time": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateRFC3339Date,
                        },
                        "expiry_time_offset_minutes": {
                            Type: schema.TypeFloat,
                            Optional: true,
                        },
                        "frequency": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(automation.OneTime),
                                string(automation.Day),
                                string(automation.Hour),
                                string(automation.Week),
                                string(automation.Month),
                                string(automation.Minute),
                            }, false),
                            Default: string(automation.OneTime),
                        },
                        "interval": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "is_enabled": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "last_modified_time": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateRFC3339Date,
                        },
                        "next_run": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateRFC3339Date,
                        },
                        "next_run_offset_minutes": {
                            Type: schema.TypeFloat,
                            Optional: true,
                        },
                        "start_time": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateRFC3339Date,
                        },
                        "time_zone": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "update_configuration": {
                Type: schema.TypeList,
                Required: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "operating_system": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(automation.Windows),
                                string(automation.Linux),
                            }, false),
                        },
                        "azure_virtual_machines": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Schema{
                                Type: schema.TypeString,
                            },
                        },
                        "duration": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateIso8601Duration(),
                        },
                        "linux": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "excluded_package_name_masks": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                    "included_package_classifications": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(automation.Unclassified),
                                            string(automation.Critical),
                                            string(automation.Security),
                                            string(automation.Other),
                                        }, false),
                                        Default: string(automation.Unclassified),
                                    },
                                    "included_package_name_masks": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                    "reboot_setting": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "non_azure_computer_names": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Schema{
                                Type: schema.TypeString,
                            },
                        },
                        "targets": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "azure_queries": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "locations": {
                                                    Type: schema.TypeList,
                                                    Optional: true,
                                                    Elem: &schema.Schema{
                                                        Type: schema.TypeString,
                                                    },
                                                },
                                                "scope": {
                                                    Type: schema.TypeList,
                                                    Optional: true,
                                                    Elem: &schema.Schema{
                                                        Type: schema.TypeString,
                                                    },
                                                },
                                            },
                                        },
                                    },
                                    "non_azure_queries": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "function_alias": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "workspace_id": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "windows": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "excluded_kb_numbers": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                    "included_kb_numbers": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                    "included_update_classifications": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(automation.Unclassified),
                                            string(automation.Critical),
                                            string(automation.Security),
                                            string(automation.UpdateRollup),
                                            string(automation.FeaturePack),
                                            string(automation.ServicePack),
                                            string(automation.Definition),
                                            string(automation.Tools),
                                            string(automation.Updates),
                                        }, false),
                                        Default: string(automation.Unclassified),
                                    },
                                    "reboot_setting": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "client_request_id": {
                Type: schema.TypeString,
                Optional: true,
                ForceNew: true,
            },

            "error": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "code": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "message": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "tasks": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "post_task": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "parameters": {
                                        Type: schema.TypeMap,
                                        Optional: true,
                                        Elem: &schema.Schema{Type: schema.TypeString},
                                    },
                                    "source": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "pre_task": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "parameters": {
                                        Type: schema.TypeMap,
                                        Optional: true,
                                        Elem: &schema.Schema{Type: schema.TypeString},
                                    },
                                    "source": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "created_by": {
                Type: schema.TypeString,
                Computed: true,
            },

            "creation_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "last_modified_by": {
                Type: schema.TypeString,
                Computed: true,
            },

            "last_modified_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },
        },
    }
}

func resourceArmSoftwareUpdateConfigurationCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).softwareUpdateConfigurationsClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    automationAccountName := d.Get("automation_account_name").(string)
    clientRequestID := d.Get("client_request_id").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.GetByName(ctx, resourceGroup, automationAccountName, name, clientRequestID)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q): %+v", name, clientRequestID, automationAccountName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_software_update_configuration", *existing.ID)
        }
    }

    error := d.Get("error").([]interface{})
    scheduleInfo := d.Get("schedule_info").([]interface{})
    tasks := d.Get("tasks").([]interface{})
    updateConfiguration := d.Get("update_configuration").([]interface{})

    parameters := automation.SoftwareUpdateConfiguration{
        SoftwareUpdateConfigurationProperties: &automation.SoftwareUpdateConfigurationProperties{
            Error: expandArmSoftwareUpdateConfigurationErrorResponse(error),
            ScheduleInfo: expandArmSoftwareUpdateConfigurationScheduleProperties(scheduleInfo),
            Tasks: expandArmSoftwareUpdateConfigurationSoftwareUpdateConfigurationTasks(tasks),
            UpdateConfiguration: expandArmSoftwareUpdateConfigurationUpdateConfiguration(updateConfiguration),
        },
    }


    if _, err := client.Create(ctx, resourceGroup, automationAccountName, name, parameters, clientRequestID); err != nil {
        return fmt.Errorf("Error creating Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q): %+v", name, clientRequestID, automationAccountName, resourceGroup, err)
    }


    resp, err := client.GetByName(ctx, resourceGroup, automationAccountName, name, clientRequestID)
    if err != nil {
        return fmt.Errorf("Error retrieving Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q): %+v", name, clientRequestID, automationAccountName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q) ID", name, clientRequestID, automationAccountName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmSoftwareUpdateConfigurationRead(d, meta)
}

func resourceArmSoftwareUpdateConfigurationRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).softwareUpdateConfigurationsClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    automationAccountName := id.Path["automationAccounts"]
    name := id.Path["softwareUpdateConfigurations"]

    resp, err := client.GetByName(ctx, resourceGroup, automationAccountName, name, clientRequestID)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Software Update Configuration %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q): %+v", name, clientRequestID, automationAccountName, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    d.Set("automation_account_name", automationAccountName)
    d.Set("client_request_id", clientRequestID)
    if softwareUpdateConfigurationProperties := resp.SoftwareUpdateConfigurationProperties; softwareUpdateConfigurationProperties != nil {
        d.Set("created_by", softwareUpdateConfigurationProperties.CreatedBy)
        d.Set("creation_time", (softwareUpdateConfigurationProperties.CreationTime).String())
        if err := d.Set("error", flattenArmSoftwareUpdateConfigurationErrorResponse(softwareUpdateConfigurationProperties.Error)); err != nil {
            return fmt.Errorf("Error setting `error`: %+v", err)
        }
        d.Set("last_modified_by", softwareUpdateConfigurationProperties.LastModifiedBy)
        d.Set("last_modified_time", (softwareUpdateConfigurationProperties.LastModifiedTime).String())
        d.Set("provisioning_state", softwareUpdateConfigurationProperties.ProvisioningState)
        if err := d.Set("schedule_info", flattenArmSoftwareUpdateConfigurationScheduleProperties(softwareUpdateConfigurationProperties.ScheduleInfo)); err != nil {
            return fmt.Errorf("Error setting `schedule_info`: %+v", err)
        }
        if err := d.Set("tasks", flattenArmSoftwareUpdateConfigurationSoftwareUpdateConfigurationTasks(softwareUpdateConfigurationProperties.Tasks)); err != nil {
            return fmt.Errorf("Error setting `tasks`: %+v", err)
        }
        if err := d.Set("update_configuration", flattenArmSoftwareUpdateConfigurationUpdateConfiguration(softwareUpdateConfigurationProperties.UpdateConfiguration)); err != nil {
            return fmt.Errorf("Error setting `update_configuration`: %+v", err)
        }
    }
    d.Set("type", resp.Type)

    return nil
}


func resourceArmSoftwareUpdateConfigurationDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).softwareUpdateConfigurationsClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    automationAccountName := id.Path["automationAccounts"]
    name := id.Path["softwareUpdateConfigurations"]

    if _, err := client.Delete(ctx, resourceGroup, automationAccountName, name, clientRequestID); err != nil {
        return fmt.Errorf("Error deleting Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q): %+v", name, clientRequestID, automationAccountName, resourceGroup, err)
    }

    return nil
}

func expandArmSoftwareUpdateConfigurationErrorResponse(input []interface{}) *automation.ErrorResponse {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    code := v["code"].(string)
    message := v["message"].(string)

    result := automation.ErrorResponse{
        Code: utils.String(code),
        Message: utils.String(message),
    }
    return &result
}

func expandArmSoftwareUpdateConfigurationScheduleProperties(input []interface{}) *automation.ScheduleProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    startTime := v["start_time"].(string)
    expiryTime := v["expiry_time"].(string)
    expiryTimeOffsetMinutes := v["expiry_time_offset_minutes"].(float64)
    isEnabled := v["is_enabled"].(bool)
    nextRun := v["next_run"].(string)
    nextRunOffsetMinutes := v["next_run_offset_minutes"].(float64)
    interval := v["interval"].(int)
    frequency := v["frequency"].(string)
    timeZone := v["time_zone"].(string)
    advancedSchedule := v["advanced_schedule"].([]interface{})
    creationTime := v["creation_time"].(string)
    lastModifiedTime := v["last_modified_time"].(string)
    description := v["description"].(string)

    result := automation.ScheduleProperties{
        AdvancedSchedule: expandArmSoftwareUpdateConfigurationAdvancedSchedule(advancedSchedule),
        CreationTime: convertStringToDate(creationTime),
        Description: utils.String(description),
        ExpiryTime: convertStringToDate(expiryTime),
        ExpiryTimeOffsetMinutes: utils.Float(expiryTimeOffsetMinutes),
        Frequency: automation.ScheduleFrequency(frequency),
        Interval: utils.Int(interval),
        IsEnabled: utils.Bool(isEnabled),
        LastModifiedTime: convertStringToDate(lastModifiedTime),
        NextRun: convertStringToDate(nextRun),
        NextRunOffsetMinutes: utils.Float(nextRunOffsetMinutes),
        StartTime: convertStringToDate(startTime),
        TimeZone: utils.String(timeZone),
    }
    return &result
}

func expandArmSoftwareUpdateConfigurationSoftwareUpdateConfigurationTasks(input []interface{}) *automation.SoftwareUpdateConfigurationTasks {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    preTask := v["pre_task"].([]interface{})
    postTask := v["post_task"].([]interface{})

    result := automation.SoftwareUpdateConfigurationTasks{
        PostTask: expandArmSoftwareUpdateConfigurationTaskProperties(postTask),
        PreTask: expandArmSoftwareUpdateConfigurationTaskProperties(preTask),
    }
    return &result
}

func expandArmSoftwareUpdateConfigurationUpdateConfiguration(input []interface{}) *automation.UpdateConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    operatingSystem := v["operating_system"].(string)
    windows := v["windows"].([]interface{})
    linux := v["linux"].([]interface{})
    duration := v["duration"].(string)
    azureVirtualMachines := v["azure_virtual_machines"].([]interface{})
    nonAzureComputerNames := v["non_azure_computer_names"].([]interface{})
    targets := v["targets"].([]interface{})

    result := automation.UpdateConfiguration{
        AzureVirtualMachines: utils.ExpandStringSlice(azureVirtualMachines),
        Duration: utils.String(duration),
        Linux: expandArmSoftwareUpdateConfigurationLinuxProperties(linux),
        NonAzureComputerNames: utils.ExpandStringSlice(nonAzureComputerNames),
        OperatingSystem: automation.OperatingSystemType(operatingSystem),
        Targets: expandArmSoftwareUpdateConfigurationTargetProperties(targets),
        Windows: expandArmSoftwareUpdateConfigurationWindowsProperties(windows),
    }
    return &result
}

func expandArmSoftwareUpdateConfigurationAdvancedSchedule(input []interface{}) *automation.AdvancedSchedule {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    weekDays := v["week_days"].([]interface{})
    monthDays := v["month_days"].([]interface{})
    monthlyOccurrences := v["monthly_occurrences"].([]interface{})

    result := automation.AdvancedSchedule{
        MonthDays: utils.ExpandInteger32Slice(monthDays),
        MonthlyOccurrences: expandArmSoftwareUpdateConfigurationAdvancedScheduleMonthlyOccurrence(monthlyOccurrences),
        WeekDays: utils.ExpandStringSlice(weekDays),
    }
    return &result
}

func convertStringToDate(input interface{}) *date.Time {
  v := input.(string)

  dateTime, err := date.ParseTime(time.RFC3339, v)
  if err != nil {
      log.Printf("[ERROR] Cannot convert an invalid string to RFC3339 date %q: %+v", v, err)
      return nil
  }

  result := date.Time{
      Time: dateTime,
  }
  return &result
}

func expandArmSoftwareUpdateConfigurationTaskProperties(input []interface{}) *automation.TaskProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    parameters := v["parameters"].(map[string]interface{})
    source := v["source"].(string)

    result := automation.TaskProperties{
        Parameters: utils.ExpandKeyValuePairs(parameters),
        Source: utils.String(source),
    }
    return &result
}

func expandArmSoftwareUpdateConfigurationLinuxProperties(input []interface{}) *automation.LinuxProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    includedPackageClassifications := v["included_package_classifications"].(string)
    excludedPackageNameMasks := v["excluded_package_name_masks"].([]interface{})
    includedPackageNameMasks := v["included_package_name_masks"].([]interface{})
    rebootSetting := v["reboot_setting"].(string)

    result := automation.LinuxProperties{
        ExcludedPackageNameMasks: utils.ExpandStringSlice(excludedPackageNameMasks),
        IncludedPackageClassifications: automation.LinuxUpdateClasses(includedPackageClassifications),
        IncludedPackageNameMasks: utils.ExpandStringSlice(includedPackageNameMasks),
        RebootSetting: utils.String(rebootSetting),
    }
    return &result
}

func expandArmSoftwareUpdateConfigurationTargetProperties(input []interface{}) *automation.TargetProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    azureQueries := v["azure_queries"].([]interface{})
    nonAzureQueries := v["non_azure_queries"].([]interface{})

    result := automation.TargetProperties{
        AzureQueries: expandArmSoftwareUpdateConfigurationAzureQueryProperties(azureQueries),
        NonAzureQueries: expandArmSoftwareUpdateConfigurationNonAzureQueryProperties(nonAzureQueries),
    }
    return &result
}

func expandArmSoftwareUpdateConfigurationWindowsProperties(input []interface{}) *automation.WindowsProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    includedUpdateClassifications := v["included_update_classifications"].(string)
    excludedKbNumbers := v["excluded_kb_numbers"].([]interface{})
    includedKbNumbers := v["included_kb_numbers"].([]interface{})
    rebootSetting := v["reboot_setting"].(string)

    result := automation.WindowsProperties{
        ExcludedKbNumbers: utils.ExpandStringSlice(excludedKbNumbers),
        IncludedKbNumbers: utils.ExpandStringSlice(includedKbNumbers),
        IncludedUpdateClassifications: automation.WindowsUpdateClasses(includedUpdateClassifications),
        RebootSetting: utils.String(rebootSetting),
    }
    return &result
}

func expandArmSoftwareUpdateConfigurationAdvancedScheduleMonthlyOccurrence(input []interface{}) *[]automation.AdvancedScheduleMonthlyOccurrence {
    results := make([]automation.AdvancedScheduleMonthlyOccurrence, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        occurrence := v["occurrence"].(int)
        day := v["day"].(string)

        result := automation.AdvancedScheduleMonthlyOccurrence{
            Day: automation.ScheduleDay(day),
            Occurrence: utils.Int32(int32(occurrence)),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmSoftwareUpdateConfigurationAzureQueryProperties(input []interface{}) *[]automation.AzureQueryProperties {
    results := make([]automation.AzureQueryProperties, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        scope := v["scope"].([]interface{})
        locations := v["locations"].([]interface{})

        result := automation.AzureQueryProperties{
            Locations: utils.ExpandStringSlice(locations),
            Scope: utils.ExpandStringSlice(scope),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmSoftwareUpdateConfigurationNonAzureQueryProperties(input []interface{}) *[]automation.NonAzureQueryProperties {
    results := make([]automation.NonAzureQueryProperties, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        functionAlias := v["function_alias"].(string)
        workspaceId := v["workspace_id"].(string)

        result := automation.NonAzureQueryProperties{
            FunctionAlias: utils.String(functionAlias),
            WorkspaceID: utils.String(workspaceId),
        }

        results = append(results, result)
    }
    return &results
}


func flattenArmSoftwareUpdateConfigurationErrorResponse(input *automation.ErrorResponse) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if code := input.Code; code != nil {
        result["code"] = *code
    }
    if message := input.Message; message != nil {
        result["message"] = *message
    }

    return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationScheduleProperties(input *automation.ScheduleProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["advanced_schedule"] = flattenArmSoftwareUpdateConfigurationAdvancedSchedule(input.AdvancedSchedule)
    if creationTime := input.CreationTime; creationTime != nil {
        result["creation_time"] = (*creationTime).String()
    }
    if description := input.Description; description != nil {
        result["description"] = *description
    }
    if expiryTime := input.ExpiryTime; expiryTime != nil {
        result["expiry_time"] = (*expiryTime).String()
    }
    if expiryTimeOffsetMinutes := input.ExpiryTimeOffsetMinutes; expiryTimeOffsetMinutes != nil {
        result["expiry_time_offset_minutes"] = *expiryTimeOffsetMinutes
    }
    result["frequency"] = string(input.Frequency)
    if interval := input.Interval; interval != nil {
        result["interval"] = *interval
    }
    if isEnabled := input.IsEnabled; isEnabled != nil {
        result["is_enabled"] = *isEnabled
    }
    if lastModifiedTime := input.LastModifiedTime; lastModifiedTime != nil {
        result["last_modified_time"] = (*lastModifiedTime).String()
    }
    if nextRun := input.NextRun; nextRun != nil {
        result["next_run"] = (*nextRun).String()
    }
    if nextRunOffsetMinutes := input.NextRunOffsetMinutes; nextRunOffsetMinutes != nil {
        result["next_run_offset_minutes"] = *nextRunOffsetMinutes
    }
    if startTime := input.StartTime; startTime != nil {
        result["start_time"] = (*startTime).String()
    }
    if timeZone := input.TimeZone; timeZone != nil {
        result["time_zone"] = *timeZone
    }

    return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationSoftwareUpdateConfigurationTasks(input *automation.SoftwareUpdateConfigurationTasks) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["post_task"] = flattenArmSoftwareUpdateConfigurationTaskProperties(input.PostTask)
    result["pre_task"] = flattenArmSoftwareUpdateConfigurationTaskProperties(input.PreTask)

    return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationUpdateConfiguration(input *automation.UpdateConfiguration) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["azure_virtual_machines"] = utils.FlattenStringSlice(input.AzureVirtualMachines)
    if duration := input.Duration; duration != nil {
        result["duration"] = *duration
    }
    result["linux"] = flattenArmSoftwareUpdateConfigurationLinuxProperties(input.Linux)
    result["non_azure_computer_names"] = utils.FlattenStringSlice(input.NonAzureComputerNames)
    result["operating_system"] = string(input.OperatingSystem)
    result["targets"] = flattenArmSoftwareUpdateConfigurationTargetProperties(input.Targets)
    result["windows"] = flattenArmSoftwareUpdateConfigurationWindowsProperties(input.Windows)

    return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationAdvancedSchedule(input *automation.AdvancedSchedule) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["month_days"] = utils.FlattenInteger32Slice(input.MonthDays)
    result["monthly_occurrences"] = flattenArmSoftwareUpdateConfigurationAdvancedScheduleMonthlyOccurrence(input.MonthlyOccurrences)
    result["week_days"] = utils.FlattenStringSlice(input.WeekDays)

    return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationTaskProperties(input *automation.TaskProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["parameters"] = utils.FlattenKeyValuePairs(input.Parameters)
    if source := input.Source; source != nil {
        result["source"] = *source
    }

    return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationLinuxProperties(input *automation.LinuxProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["excluded_package_name_masks"] = utils.FlattenStringSlice(input.ExcludedPackageNameMasks)
    result["included_package_classifications"] = string(input.IncludedPackageClassifications)
    result["included_package_name_masks"] = utils.FlattenStringSlice(input.IncludedPackageNameMasks)
    if rebootSetting := input.RebootSetting; rebootSetting != nil {
        result["reboot_setting"] = *rebootSetting
    }

    return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationTargetProperties(input *automation.TargetProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["azure_queries"] = flattenArmSoftwareUpdateConfigurationAzureQueryProperties(input.AzureQueries)
    result["non_azure_queries"] = flattenArmSoftwareUpdateConfigurationNonAzureQueryProperties(input.NonAzureQueries)

    return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationWindowsProperties(input *automation.WindowsProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["excluded_kb_numbers"] = utils.FlattenStringSlice(input.ExcludedKbNumbers)
    result["included_kb_numbers"] = utils.FlattenStringSlice(input.IncludedKbNumbers)
    result["included_update_classifications"] = string(input.IncludedUpdateClassifications)
    if rebootSetting := input.RebootSetting; rebootSetting != nil {
        result["reboot_setting"] = *rebootSetting
    }

    return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationAdvancedScheduleMonthlyOccurrence(input *[]automation.AdvancedScheduleMonthlyOccurrence) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        v["day"] = string(item.Day)
        if occurrence := item.Occurrence; occurrence != nil {
            v["occurrence"] = int(*occurrence)
        }

        results = append(results, v)
    }

    return results
}

func flattenArmSoftwareUpdateConfigurationAzureQueryProperties(input *[]automation.AzureQueryProperties) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        v["locations"] = utils.FlattenStringSlice(item.Locations)
        v["scope"] = utils.FlattenStringSlice(item.Scope)

        results = append(results, v)
    }

    return results
}

func flattenArmSoftwareUpdateConfigurationNonAzureQueryProperties(input *[]automation.NonAzureQueryProperties) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if functionAlias := item.FunctionAlias; functionAlias != nil {
            v["function_alias"] = *functionAlias
        }
        if workspaceId := item.WorkspaceID; workspaceId != nil {
            v["workspace_id"] = *workspaceId
        }

        results = append(results, v)
    }

    return results
}
