// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmWebApp() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmWebAppCreate,
        Read: resourceArmWebAppRead,
        Update: resourceArmWebAppUpdate,
        Delete: resourceArmWebAppDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "resource_group": {
                Type: schema.TypeString,
                Computed: true,
            },

            "client_affinity_enabled": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "client_cert_enabled": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "client_cert_exclusion_paths": {
                Type: schema.TypeString,
                Optional: true,
            },

            "cloning_info": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "source_web_app_id": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "app_settings_overrides": {
                            Type: schema.TypeMap,
                            Optional: true,
                            Elem: &schema.Schema{Type: schema.TypeString},
                        },
                        "clone_custom_host_names": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "clone_source_control": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "configure_load_balancing": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "correlation_id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "hosting_environment": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "overwrite": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "source_web_app_location": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "traffic_manager_profile_id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "traffic_manager_profile_name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "container_size": {
                Type: schema.TypeInt,
                Optional: true,
            },

            "daily_memory_time_quota": {
                Type: schema.TypeInt,
                Optional: true,
            },

            "enabled": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "host_name_ssl_states": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "host_type": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(web.Standard),
                                string(web.Repository),
                            }, false),
                            Default: string(web.Standard),
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "ssl_state": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(web.Disabled),
                                string(web.SniEnabled),
                                string(web.IpBasedEnabled),
                            }, false),
                            Default: string(web.Disabled),
                        },
                        "thumbprint": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "to_update": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "virtual_ip": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "host_names_disabled": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "hosting_environment_profile": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "https_only": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "hyper_v": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "identity": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "type": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(web.None),
                                string(web.SystemAssigned),
                                string(web.UserAssigned),
                            }, false),
                            Default: string(web.None),
                        },
                        "user_assigned_identities": {
                            Type: schema.TypeMap,
                            Optional: true,
                            Elem: &schema.Schema{Type: schema.TypeString},
                        },
                    },
                },
            },

            "is_xenon": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "kind": {
                Type: schema.TypeString,
                Optional: true,
                ForceNew: true,
            },

            "redundancy_mode": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(web.None),
                    string(web.Manual),
                    string(web.Failover),
                    string(web.ActiveActive),
                    string(web.GeoRedundant),
                }, false),
                Default: string(web.None),
            },

            "reserved": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "scm_site_also_stopped": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "server_farm_id": {
                Type: schema.TypeString,
                Optional: true,
            },

            "site_config": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "always_on": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "api_definition": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "url": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "api_management_config": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "app_command_line": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "app_settings": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "name": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "value": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "auto_heal_enabled": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "auto_heal_rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "actions": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "action_type": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(web.Recycle),
                                                        string(web.LogEvent),
                                                        string(web.CustomAction),
                                                    }, false),
                                                    Default: string(web.Recycle),
                                                },
                                                "min_process_execution_time": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "triggers": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "private_bytes_in_kb": {
                                                    Type: schema.TypeInt,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "auto_swap_slot_name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "connection_strings": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "connection_string": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "name": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "type": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(web.MySql),
                                            string(web.SQLServer),
                                            string(web.SQLAzure),
                                            string(web.Custom),
                                            string(web.NotificationHub),
                                            string(web.ServiceBus),
                                            string(web.EventHub),
                                            string(web.ApiHub),
                                            string(web.DocDb),
                                            string(web.RedisCache),
                                            string(web.PostgreSQL),
                                        }, false),
                                        Default: string(web.MySql),
                                    },
                                },
                            },
                        },
                        "cors": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "allowed_origins": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                        },
                                    },
                                    "support_credentials": {
                                        Type: schema.TypeBool,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "default_documents": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Schema{
                                Type: schema.TypeString,
                            },
                        },
                        "detailed_error_logging_enabled": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "document_root": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "experiments": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "ramp_up_rules": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "action_host_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "change_decision_callback_url": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "change_interval_in_minutes": {
                                                    Type: schema.TypeInt,
                                                    Optional: true,
                                                },
                                                "change_step": {
                                                    Type: schema.TypeFloat,
                                                    Optional: true,
                                                },
                                                "max_reroute_percentage": {
                                                    Type: schema.TypeFloat,
                                                    Optional: true,
                                                },
                                                "min_reroute_percentage": {
                                                    Type: schema.TypeFloat,
                                                    Optional: true,
                                                },
                                                "name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "reroute_percentage": {
                                                    Type: schema.TypeFloat,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "ftps_state": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(web.AllAllowed),
                                string(web.FtpsOnly),
                                string(web.Disabled),
                            }, false),
                            Default: string(web.AllAllowed),
                        },
                        "handler_mappings": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "arguments": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "extension": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "script_processor": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "health_check_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "http20enabled": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "http_logging_enabled": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "ip_security_restrictions": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "action": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "description": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "ip_address": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "name": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "priority": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "subnet_mask": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "subnet_traffic_tag": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "tag": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(web.Default),
                                            string(web.XffProxy),
                                        }, false),
                                        Default: string(web.Default),
                                    },
                                    "vnet_subnet_resource_id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "vnet_traffic_tag": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "java_container": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "java_container_version": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "java_version": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "limits": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "max_disk_size_in_mb": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "max_memory_in_mb": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "max_percentage_cpu": {
                                        Type: schema.TypeFloat,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "linux_fx_version": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "load_balancing": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(web.WeightedRoundRobin),
                                string(web.LeastRequests),
                                string(web.LeastResponseTime),
                                string(web.WeightedTotalTraffic),
                                string(web.RequestHash),
                            }, false),
                            Default: string(web.WeightedRoundRobin),
                        },
                        "local_my_sql_enabled": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "logs_directory_size_limit": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "managed_pipeline_mode": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(web.Integrated),
                                string(web.Classic),
                            }, false),
                            Default: string(web.Integrated),
                        },
                        "managed_service_identity_id": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "min_tls_version": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(web.1.0),
                                string(web.1.1),
                                string(web.1.2),
                            }, false),
                            Default: string(web.1.0),
                        },
                        "net_framework_version": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "node_version": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "number_of_workers": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "php_version": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "pre_warmed_instance_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "publishing_username": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "push": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "is_push_enabled": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "dynamic_tags_json": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "kind": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "tag_whitelist_json": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "tags_requiring_auth": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "python_version": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "remote_debugging_enabled": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "remote_debugging_version": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "request_tracing_enabled": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "request_tracing_expiration_time": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateRFC3339Date,
                        },
                        "scm_ip_security_restrictions": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "action": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "description": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "ip_address": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "name": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "priority": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "subnet_mask": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "subnet_traffic_tag": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "tag": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(web.Default),
                                            string(web.XffProxy),
                                        }, false),
                                        Default: string(web.Default),
                                    },
                                    "vnet_subnet_resource_id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "vnet_traffic_tag": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "scm_ip_security_restrictions_use_main": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "scm_type": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(web.None),
                                string(web.Dropbox),
                                string(web.Tfs),
                                string(web.LocalGit),
                                string(web.GitHub),
                                string(web.CodePlexGit),
                                string(web.CodePlexHg),
                                string(web.BitbucketGit),
                                string(web.BitbucketHg),
                                string(web.ExternalGit),
                                string(web.ExternalHg),
                                string(web.OneDrive),
                                string(web.VSO),
                                string(web.VSTSRM),
                            }, false),
                            Default: string(web.None),
                        },
                        "tracing_options": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "use32bit_worker_process": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "virtual_applications": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "physical_path": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "preload_enabled": {
                                        Type: schema.TypeBool,
                                        Optional: true,
                                    },
                                    "virtual_directories": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "physical_path": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "virtual_path": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "virtual_path": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "vnet_name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "web_sockets_enabled": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "windows_fx_version": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "x_managed_service_identity_id": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                    },
                },
            },

            "availability_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "default_host_name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "enabled_host_names": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Schema{
                    Type: schema.TypeString,
                },
            },

            "host_names": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Schema{
                    Type: schema.TypeString,
                },
            },

            "in_progress_operation_id": {
                Type: schema.TypeString,
                Computed: true,
            },

            "is_default_container": {
                Type: schema.TypeBool,
                Computed: true,
            },

            "last_modified_time_utc": {
                Type: schema.TypeString,
                Computed: true,
            },

            "max_number_of_workers": {
                Type: schema.TypeInt,
                Computed: true,
            },

            "outbound_ip_addresses": {
                Type: schema.TypeString,
                Computed: true,
            },

            "possible_outbound_ip_addresses": {
                Type: schema.TypeString,
                Computed: true,
            },

            "repository_site_name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "slot_swap_status": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "destination_slot_name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "source_slot_name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "timestamp_utc": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateRFC3339Date,
                        },
                    },
                },
            },

            "state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "suspended_till": {
                Type: schema.TypeString,
                Computed: true,
            },

            "target_swap_slot": {
                Type: schema.TypeString,
                Computed: true,
            },

            "traffic_manager_host_names": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Schema{
                    Type: schema.TypeString,
                },
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "usage_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmWebAppCreate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).webAppsClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Web App %q (Resource Group %q): %+v", name, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_web_app", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    clientAffinityEnabled := d.Get("client_affinity_enabled").(bool)
    clientCertEnabled := d.Get("client_cert_enabled").(bool)
    clientCertExclusionPaths := d.Get("client_cert_exclusion_paths").(string)
    cloningInfo := d.Get("cloning_info").([]interface{})
    containerSize := d.Get("container_size").(int)
    dailyMemoryTimeQuota := d.Get("daily_memory_time_quota").(int)
    enabled := d.Get("enabled").(bool)
    hostNameSslStates := d.Get("host_name_ssl_states").([]interface{})
    hostNamesDisabled := d.Get("host_names_disabled").(bool)
    hostingEnvironmentProfile := d.Get("hosting_environment_profile").([]interface{})
    httpsOnly := d.Get("https_only").(bool)
    hyperV := d.Get("hyper_v").(bool)
    identity := d.Get("identity").([]interface{})
    isXenon := d.Get("is_xenon").(bool)
    kind := d.Get("kind").(string)
    redundancyMode := d.Get("redundancy_mode").(string)
    reserved := d.Get("reserved").(bool)
    scmSiteAlsoStopped := d.Get("scm_site_also_stopped").(bool)
    serverFarmId := d.Get("server_farm_id").(string)
    siteConfig := d.Get("site_config").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    siteEnvelope := web.Site{
        Identity: expandArmWebAppManagedServiceIdentity(identity),
        Kind: utils.String(kind),
        Location: utils.String(location),
        Site_properties: &web.Site_properties{
            ClientAffinityEnabled: utils.Bool(clientAffinityEnabled),
            ClientCertEnabled: utils.Bool(clientCertEnabled),
            ClientCertExclusionPaths: utils.String(clientCertExclusionPaths),
            CloningInfo: expandArmWebAppCloningInfo(cloningInfo),
            ContainerSize: utils.Int32(int32(containerSize)),
            DailyMemoryTimeQuota: utils.Int32(int32(dailyMemoryTimeQuota)),
            Enabled: utils.Bool(enabled),
            HostNameSslStates: expandArmWebAppHostNameSslState(hostNameSslStates),
            HostNamesDisabled: utils.Bool(hostNamesDisabled),
            HostingEnvironmentProfile: expandArmWebAppHostingEnvironmentProfile(hostingEnvironmentProfile),
            HttpsOnly: utils.Bool(httpsOnly),
            HyperV: utils.Bool(hyperV),
            IsXenon: utils.Bool(isXenon),
            RedundancyMode: web.RedundancyMode(redundancyMode),
            Reserved: utils.Bool(reserved),
            ScmSiteAlsoStopped: utils.Bool(scmSiteAlsoStopped),
            ServerFarmID: utils.String(serverFarmId),
            SiteConfig: expandArmWebAppSiteConfig(siteConfig),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.CreateOrUpdate(ctx, resourceGroup, name, siteEnvelope)
    if err != nil {
        return fmt.Errorf("Error creating Web App %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Web App %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Web App %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Web App %q (Resource Group %q) ID", name, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmWebAppRead(d, meta)
}

func resourceArmWebAppRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).webAppsClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["sites"]

    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Web App %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Web App %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    if siteProperties := resp.Site_properties; siteProperties != nil {
        d.Set("availability_state", string(siteProperties.AvailabilityState))
        d.Set("client_affinity_enabled", siteProperties.ClientAffinityEnabled)
        d.Set("client_cert_enabled", siteProperties.ClientCertEnabled)
        d.Set("client_cert_exclusion_paths", siteProperties.ClientCertExclusionPaths)
        if err := d.Set("cloning_info", flattenArmWebAppCloningInfo(siteProperties.CloningInfo)); err != nil {
            return fmt.Errorf("Error setting `cloning_info`: %+v", err)
        }
        d.Set("container_size", int(*siteProperties.ContainerSize))
        d.Set("daily_memory_time_quota", int(*siteProperties.DailyMemoryTimeQuota))
        d.Set("default_host_name", siteProperties.DefaultHostName)
        d.Set("enabled", siteProperties.Enabled)
        d.Set("enabled_host_names", utils.FlattenStringSlice(siteProperties.EnabledHostNames))
        if err := d.Set("host_name_ssl_states", flattenArmWebAppHostNameSslState(siteProperties.HostNameSslStates)); err != nil {
            return fmt.Errorf("Error setting `host_name_ssl_states`: %+v", err)
        }
        d.Set("host_names", utils.FlattenStringSlice(siteProperties.HostNames))
        d.Set("host_names_disabled", siteProperties.HostNamesDisabled)
        if err := d.Set("hosting_environment_profile", flattenArmWebAppHostingEnvironmentProfile(siteProperties.HostingEnvironmentProfile)); err != nil {
            return fmt.Errorf("Error setting `hosting_environment_profile`: %+v", err)
        }
        d.Set("https_only", siteProperties.HttpsOnly)
        d.Set("hyper_v", siteProperties.HyperV)
        d.Set("in_progress_operation_id", siteProperties.InProgressOperationID)
        d.Set("is_default_container", siteProperties.IsDefaultContainer)
        d.Set("is_xenon", siteProperties.IsXenon)
        d.Set("last_modified_time_utc", (siteProperties.LastModifiedTimeUtc).String())
        d.Set("max_number_of_workers", int(*siteProperties.MaxNumberOfWorkers))
        d.Set("outbound_ip_addresses", siteProperties.OutboundIpAddresses)
        d.Set("possible_outbound_ip_addresses", siteProperties.PossibleOutboundIpAddresses)
        d.Set("redundancy_mode", string(siteProperties.RedundancyMode))
        d.Set("repository_site_name", siteProperties.RepositorySiteName)
        d.Set("reserved", siteProperties.Reserved)
        d.Set("resource_group", siteProperties.ResourceGroup)
        d.Set("scm_site_also_stopped", siteProperties.ScmSiteAlsoStopped)
        d.Set("server_farm_id", siteProperties.ServerFarmID)
        if err := d.Set("site_config", flattenArmWebAppSiteConfig(siteProperties.SiteConfig)); err != nil {
            return fmt.Errorf("Error setting `site_config`: %+v", err)
        }
        if err := d.Set("slot_swap_status", flattenArmWebAppSlotSwapStatus(siteProperties.SlotSwapStatus)); err != nil {
            return fmt.Errorf("Error setting `slot_swap_status`: %+v", err)
        }
        d.Set("state", siteProperties.State)
        d.Set("suspended_till", (siteProperties.SuspendedTill).String())
        d.Set("target_swap_slot", siteProperties.TargetSwapSlot)
        d.Set("traffic_manager_host_names", utils.FlattenStringSlice(siteProperties.TrafficManagerHostNames))
        d.Set("usage_state", string(siteProperties.UsageState))
    }
    if err := d.Set("identity", flattenArmWebAppManagedServiceIdentity(resp.Identity)); err != nil {
        return fmt.Errorf("Error setting `identity`: %+v", err)
    }
    d.Set("kind", resp.Kind)
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}

func resourceArmWebAppUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).webAppsClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    clientAffinityEnabled := d.Get("client_affinity_enabled").(bool)
    clientCertEnabled := d.Get("client_cert_enabled").(bool)
    clientCertExclusionPaths := d.Get("client_cert_exclusion_paths").(string)
    cloningInfo := d.Get("cloning_info").([]interface{})
    containerSize := d.Get("container_size").(int)
    dailyMemoryTimeQuota := d.Get("daily_memory_time_quota").(int)
    enabled := d.Get("enabled").(bool)
    hostNameSslStates := d.Get("host_name_ssl_states").([]interface{})
    hostNamesDisabled := d.Get("host_names_disabled").(bool)
    hostingEnvironmentProfile := d.Get("hosting_environment_profile").([]interface{})
    httpsOnly := d.Get("https_only").(bool)
    hyperV := d.Get("hyper_v").(bool)
    identity := d.Get("identity").([]interface{})
    isXenon := d.Get("is_xenon").(bool)
    kind := d.Get("kind").(string)
    redundancyMode := d.Get("redundancy_mode").(string)
    reserved := d.Get("reserved").(bool)
    scmSiteAlsoStopped := d.Get("scm_site_also_stopped").(bool)
    serverFarmId := d.Get("server_farm_id").(string)
    siteConfig := d.Get("site_config").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    siteEnvelope := web.Site{
        Identity: expandArmWebAppManagedServiceIdentity(identity),
        Kind: utils.String(kind),
        Location: utils.String(location),
        Site_properties: &web.Site_properties{
            ClientAffinityEnabled: utils.Bool(clientAffinityEnabled),
            ClientCertEnabled: utils.Bool(clientCertEnabled),
            ClientCertExclusionPaths: utils.String(clientCertExclusionPaths),
            CloningInfo: expandArmWebAppCloningInfo(cloningInfo),
            ContainerSize: utils.Int32(int32(containerSize)),
            DailyMemoryTimeQuota: utils.Int32(int32(dailyMemoryTimeQuota)),
            Enabled: utils.Bool(enabled),
            HostNameSslStates: expandArmWebAppHostNameSslState(hostNameSslStates),
            HostNamesDisabled: utils.Bool(hostNamesDisabled),
            HostingEnvironmentProfile: expandArmWebAppHostingEnvironmentProfile(hostingEnvironmentProfile),
            HttpsOnly: utils.Bool(httpsOnly),
            HyperV: utils.Bool(hyperV),
            IsXenon: utils.Bool(isXenon),
            RedundancyMode: web.RedundancyMode(redundancyMode),
            Reserved: utils.Bool(reserved),
            ScmSiteAlsoStopped: utils.Bool(scmSiteAlsoStopped),
            ServerFarmID: utils.String(serverFarmId),
            SiteConfig: expandArmWebAppSiteConfig(siteConfig),
        },
        Tags: tags.Expand(t),
    }


    if _, err := client.Update(ctx, resourceGroup, name, siteEnvelope); err != nil {
        return fmt.Errorf("Error updating Web App %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    return resourceArmWebAppRead(d, meta)
}

func resourceArmWebAppDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).webAppsClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["sites"]

    if _, err := client.Delete(ctx, resourceGroup, name); err != nil {
        return fmt.Errorf("Error deleting Web App %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    return nil
}

func expandArmWebAppManagedServiceIdentity(input []interface{}) *web.ManagedServiceIdentity {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    type := v["type"].(string)
    userAssignedIdentities := v["user_assigned_identities"].(map[string]interface{})

    result := web.ManagedServiceIdentity{
        Type: web.ManagedServiceIdentityType(type),
        UserAssignedIdentities: utils.ExpandKeyValuePairs(userAssignedIdentities),
    }
    return &result
}

func expandArmWebAppCloningInfo(input []interface{}) *web.CloningInfo {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    correlationId := v["correlation_id"].(string)
    overwrite := v["overwrite"].(bool)
    cloneCustomHostNames := v["clone_custom_host_names"].(bool)
    cloneSourceControl := v["clone_source_control"].(bool)
    sourceWebAppId := v["source_web_app_id"].(string)
    sourceWebAppLocation := v["source_web_app_location"].(string)
    hostingEnvironment := v["hosting_environment"].(string)
    appSettingsOverrides := v["app_settings_overrides"].(map[string]interface{})
    configureLoadBalancing := v["configure_load_balancing"].(bool)
    trafficManagerProfileId := v["traffic_manager_profile_id"].(string)
    trafficManagerProfileName := v["traffic_manager_profile_name"].(string)

    result := web.CloningInfo{
        AppSettingsOverrides: utils.ExpandKeyValuePairs(appSettingsOverrides),
        CloneCustomHostNames: utils.Bool(cloneCustomHostNames),
        CloneSourceControl: utils.Bool(cloneSourceControl),
        ConfigureLoadBalancing: utils.Bool(configureLoadBalancing),
        CorrelationID: utils.String(correlationId),
        HostingEnvironment: utils.String(hostingEnvironment),
        Overwrite: utils.Bool(overwrite),
        SourceWebAppID: utils.String(sourceWebAppId),
        SourceWebAppLocation: utils.String(sourceWebAppLocation),
        TrafficManagerProfileID: utils.String(trafficManagerProfileId),
        TrafficManagerProfileName: utils.String(trafficManagerProfileName),
    }
    return &result
}

func expandArmWebAppHostNameSslState(input []interface{}) *[]web.HostNameSslState {
    results := make([]web.HostNameSslState, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        sslState := v["ssl_state"].(string)
        virtualIp := v["virtual_ip"].(string)
        thumbprint := v["thumbprint"].(string)
        toUpdate := v["to_update"].(bool)
        hostType := v["host_type"].(string)

        result := web.HostNameSslState{
            HostType: web.HostType(hostType),
            Name: utils.String(name),
            SslState: web.SslState(sslState),
            Thumbprint: utils.String(thumbprint),
            ToUpdate: utils.Bool(toUpdate),
            VirtualIp: utils.String(virtualIp),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmWebAppHostingEnvironmentProfile(input []interface{}) *web.HostingEnvironmentProfile {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    id := v["id"].(string)

    result := web.HostingEnvironmentProfile{
        ID: utils.String(id),
    }
    return &result
}

func expandArmWebAppSiteConfig(input []interface{}) *web.SiteConfig {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    numberOfWorkers := v["number_of_workers"].(int)
    defaultDocuments := v["default_documents"].([]interface{})
    netFrameworkVersion := v["net_framework_version"].(string)
    phpVersion := v["php_version"].(string)
    pythonVersion := v["python_version"].(string)
    nodeVersion := v["node_version"].(string)
    linuxFxVersion := v["linux_fx_version"].(string)
    windowsFxVersion := v["windows_fx_version"].(string)
    requestTracingEnabled := v["request_tracing_enabled"].(bool)
    requestTracingExpirationTime := v["request_tracing_expiration_time"].(string)
    remoteDebuggingEnabled := v["remote_debugging_enabled"].(bool)
    remoteDebuggingVersion := v["remote_debugging_version"].(string)
    httpLoggingEnabled := v["http_logging_enabled"].(bool)
    logsDirectorySizeLimit := v["logs_directory_size_limit"].(int)
    detailedErrorLoggingEnabled := v["detailed_error_logging_enabled"].(bool)
    publishingUsername := v["publishing_username"].(string)
    appSettings := v["app_settings"].([]interface{})
    connectionStrings := v["connection_strings"].([]interface{})
    handlerMappings := v["handler_mappings"].([]interface{})
    documentRoot := v["document_root"].(string)
    scmType := v["scm_type"].(string)
    use32bitWorkerProcess := v["use32bit_worker_process"].(bool)
    webSocketsEnabled := v["web_sockets_enabled"].(bool)
    alwaysOn := v["always_on"].(bool)
    javaVersion := v["java_version"].(string)
    javaContainer := v["java_container"].(string)
    javaContainerVersion := v["java_container_version"].(string)
    appCommandLine := v["app_command_line"].(string)
    managedPipelineMode := v["managed_pipeline_mode"].(string)
    virtualApplications := v["virtual_applications"].([]interface{})
    loadBalancing := v["load_balancing"].(string)
    experiments := v["experiments"].([]interface{})
    limits := v["limits"].([]interface{})
    autoHealEnabled := v["auto_heal_enabled"].(bool)
    autoHealRules := v["auto_heal_rules"].([]interface{})
    tracingOptions := v["tracing_options"].(string)
    vnetName := v["vnet_name"].(string)
    cors := v["cors"].([]interface{})
    push := v["push"].([]interface{})
    apiDefinition := v["api_definition"].([]interface{})
    apiManagementConfig := v["api_management_config"].([]interface{})
    autoSwapSlotName := v["auto_swap_slot_name"].(string)
    localMySqlEnabled := v["local_my_sql_enabled"].(bool)
    managedServiceIdentityId := v["managed_service_identity_id"].(int)
    xManagedServiceIdentityId := v["x_managed_service_identity_id"].(int)
    ipSecurityRestrictions := v["ip_security_restrictions"].([]interface{})
    scmIpSecurityRestrictions := v["scm_ip_security_restrictions"].([]interface{})
    scmIpSecurityRestrictionsUseMain := v["scm_ip_security_restrictions_use_main"].(bool)
    http20enabled := v["http20enabled"].(bool)
    minTlsVersion := v["min_tls_version"].(string)
    ftpsState := v["ftps_state"].(string)
    preWarmedInstanceCount := v["pre_warmed_instance_count"].(int)
    healthCheckPath := v["health_check_path"].(string)

    result := web.SiteConfig{
        AlwaysOn: utils.Bool(alwaysOn),
        ApiDefinition: expandArmWebAppApiDefinitionInfo(apiDefinition),
        ApiManagementConfig: expandArmWebAppApiManagementConfig(apiManagementConfig),
        AppCommandLine: utils.String(appCommandLine),
        AppSettings: expandArmWebAppNameValuePair(appSettings),
        AutoHealEnabled: utils.Bool(autoHealEnabled),
        AutoHealRules: expandArmWebAppAutoHealRules(autoHealRules),
        AutoSwapSlotName: utils.String(autoSwapSlotName),
        ConnectionStrings: expandArmWebAppConnStringInfo(connectionStrings),
        Cors: expandArmWebAppCorsSettings(cors),
        DefaultDocuments: utils.ExpandStringSlice(defaultDocuments),
        DetailedErrorLoggingEnabled: utils.Bool(detailedErrorLoggingEnabled),
        DocumentRoot: utils.String(documentRoot),
        Experiments: expandArmWebAppExperiments(experiments),
        FtpsState: web.FtpsState(ftpsState),
        HandlerMappings: expandArmWebAppHandlerMapping(handlerMappings),
        HealthCheckPath: utils.String(healthCheckPath),
        Http20enabled: utils.Bool(http20enabled),
        HttpLoggingEnabled: utils.Bool(httpLoggingEnabled),
        IpSecurityRestrictions: expandArmWebAppIpSecurityRestriction(ipSecurityRestrictions),
        JavaContainer: utils.String(javaContainer),
        JavaContainerVersion: utils.String(javaContainerVersion),
        JavaVersion: utils.String(javaVersion),
        Limits: expandArmWebAppSiteLimits(limits),
        LinuxFxVersion: utils.String(linuxFxVersion),
        LoadBalancing: web.SiteLoadBalancing(loadBalancing),
        LocalMySqlEnabled: utils.Bool(localMySqlEnabled),
        LogsDirectorySizeLimit: utils.Int32(int32(logsDirectorySizeLimit)),
        ManagedPipelineMode: web.ManagedPipelineMode(managedPipelineMode),
        ManagedServiceIdentityID: utils.Int32(int32(managedServiceIdentityId)),
        MinTlsVersion: web.SupportedTlsVersions(minTlsVersion),
        NetFrameworkVersion: utils.String(netFrameworkVersion),
        NodeVersion: utils.String(nodeVersion),
        NumberOfWorkers: utils.Int32(int32(numberOfWorkers)),
        PhpVersion: utils.String(phpVersion),
        PreWarmedInstanceCount: utils.Int32(int32(preWarmedInstanceCount)),
        PublishingUsername: utils.String(publishingUsername),
        Push: expandArmWebAppPushSettings(push),
        PythonVersion: utils.String(pythonVersion),
        RemoteDebuggingEnabled: utils.Bool(remoteDebuggingEnabled),
        RemoteDebuggingVersion: utils.String(remoteDebuggingVersion),
        RequestTracingEnabled: utils.Bool(requestTracingEnabled),
        RequestTracingExpirationTime: convertStringToDate(requestTracingExpirationTime),
        ScmIpSecurityRestrictions: expandArmWebAppIpSecurityRestriction(scmIpSecurityRestrictions),
        ScmIpSecurityRestrictionsUseMain: utils.Bool(scmIpSecurityRestrictionsUseMain),
        ScmType: web.ScmType(scmType),
        TracingOptions: utils.String(tracingOptions),
        Use32bitWorkerProcess: utils.Bool(use32bitWorkerProcess),
        VirtualApplications: expandArmWebAppVirtualApplication(virtualApplications),
        VnetName: utils.String(vnetName),
        WebSocketsEnabled: utils.Bool(webSocketsEnabled),
        WindowsFxVersion: utils.String(windowsFxVersion),
        XManagedServiceIdentityID: utils.Int32(int32(xManagedServiceIdentityId)),
    }
    return &result
}

func expandArmWebAppApiDefinitionInfo(input []interface{}) *web.ApiDefinitionInfo {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    url := v["url"].(string)

    result := web.ApiDefinitionInfo{
        URL: utils.String(url),
    }
    return &result
}

func expandArmWebAppApiManagementConfig(input []interface{}) *web.ApiManagementConfig {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    id := v["id"].(string)

    result := web.ApiManagementConfig{
        ID: utils.String(id),
    }
    return &result
}

func expandArmWebAppNameValuePair(input []interface{}) *[]web.NameValuePair {
    results := make([]web.NameValuePair, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        value := v["value"].(string)

        result := web.NameValuePair{
            Name: utils.String(name),
            Value: utils.String(value),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmWebAppAutoHealRules(input []interface{}) *web.AutoHealRules {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    triggers := v["triggers"].([]interface{})
    actions := v["actions"].([]interface{})

    result := web.AutoHealRules{
        Actions: expandArmWebAppAutoHealActions(actions),
        Triggers: expandArmWebAppAutoHealTriggers(triggers),
    }
    return &result
}

func expandArmWebAppConnStringInfo(input []interface{}) *[]web.ConnStringInfo {
    results := make([]web.ConnStringInfo, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        connectionString := v["connection_string"].(string)
        type := v["type"].(string)

        result := web.ConnStringInfo{
            ConnectionString: utils.String(connectionString),
            Name: utils.String(name),
            Type: web.ConnectionStringType(type),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmWebAppCorsSettings(input []interface{}) *web.CorsSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    allowedOrigins := v["allowed_origins"].([]interface{})
    supportCredentials := v["support_credentials"].(bool)

    result := web.CorsSettings{
        AllowedOrigins: utils.ExpandStringSlice(allowedOrigins),
        SupportCredentials: utils.Bool(supportCredentials),
    }
    return &result
}

func expandArmWebAppExperiments(input []interface{}) *web.Experiments {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    rampUpRules := v["ramp_up_rules"].([]interface{})

    result := web.Experiments{
        RampUpRules: expandArmWebAppRampUpRule(rampUpRules),
    }
    return &result
}

func expandArmWebAppHandlerMapping(input []interface{}) *[]web.HandlerMapping {
    results := make([]web.HandlerMapping, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        extension := v["extension"].(string)
        scriptProcessor := v["script_processor"].(string)
        arguments := v["arguments"].(string)

        result := web.HandlerMapping{
            Arguments: utils.String(arguments),
            Extension: utils.String(extension),
            ScriptProcessor: utils.String(scriptProcessor),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmWebAppIpSecurityRestriction(input []interface{}) *[]web.IpSecurityRestriction {
    results := make([]web.IpSecurityRestriction, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        ipAddress := v["ip_address"].(string)
        subnetMask := v["subnet_mask"].(string)
        vnetSubnetResourceId := v["vnet_subnet_resource_id"].(string)
        vnetTrafficTag := v["vnet_traffic_tag"].(int)
        subnetTrafficTag := v["subnet_traffic_tag"].(int)
        action := v["action"].(string)
        tag := v["tag"].(string)
        priority := v["priority"].(int)
        name := v["name"].(string)
        description := v["description"].(string)

        result := web.IpSecurityRestriction{
            Action: utils.String(action),
            Description: utils.String(description),
            IpAddress: utils.String(ipAddress),
            Name: utils.String(name),
            Priority: utils.Int32(int32(priority)),
            SubnetMask: utils.String(subnetMask),
            SubnetTrafficTag: utils.Int32(int32(subnetTrafficTag)),
            Tag: web.IpFilterTag(tag),
            VnetSubnetResourceID: utils.String(vnetSubnetResourceId),
            VnetTrafficTag: utils.Int32(int32(vnetTrafficTag)),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmWebAppSiteLimits(input []interface{}) *web.SiteLimits {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    maxPercentageCpu := v["max_percentage_cpu"].(float64)
    maxMemoryInMb := v["max_memory_in_mb"].(int)
    maxDiskSizeInMb := v["max_disk_size_in_mb"].(int)

    result := web.SiteLimits{
        MaxDiskSizeInMb: utils.Int64(int64(maxDiskSizeInMb)),
        MaxMemoryInMb: utils.Int64(int64(maxMemoryInMb)),
        MaxPercentageCpu: utils.Float(maxPercentageCpu),
    }
    return &result
}

func expandArmWebAppPushSettings(input []interface{}) *web.PushSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    kind := v["kind"].(string)
    isPushEnabled := v["is_push_enabled"].(bool)
    tagWhitelistJson := v["tag_whitelist_json"].(string)
    tagsRequiringAuth := v["tags_requiring_auth"].(string)
    dynamicTagsJson := v["dynamic_tags_json"].(string)

    result := web.PushSettings{
        Kind: utils.String(kind),
        PushSettings_properties: &web.PushSettings_properties{
            DynamicTagsJson: utils.String(dynamicTagsJson),
            IsPushEnabled: utils.Bool(isPushEnabled),
            TagWhitelistJson: utils.String(tagWhitelistJson),
            TagsRequiringAuth: utils.String(tagsRequiringAuth),
        },
    }
    return &result
}

func convertStringToDate(input interface{}) *date.Time {
  v := input.(string)

  dateTime, err := date.ParseTime(time.RFC3339, v)
  if err != nil {
      log.Printf("[ERROR] Cannot convert an invalid string to RFC3339 date %q: %+v", v, err)
      return nil
  }

  result := date.Time{
      Time: dateTime,
  }
  return &result
}

func expandArmWebAppVirtualApplication(input []interface{}) *[]web.VirtualApplication {
    results := make([]web.VirtualApplication, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        virtualPath := v["virtual_path"].(string)
        physicalPath := v["physical_path"].(string)
        preloadEnabled := v["preload_enabled"].(bool)
        virtualDirectories := v["virtual_directories"].([]interface{})

        result := web.VirtualApplication{
            PhysicalPath: utils.String(physicalPath),
            PreloadEnabled: utils.Bool(preloadEnabled),
            VirtualDirectories: expandArmWebAppVirtualDirectory(virtualDirectories),
            VirtualPath: utils.String(virtualPath),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmWebAppAutoHealActions(input []interface{}) *web.AutoHealActions {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    actionType := v["action_type"].(string)
    minProcessExecutionTime := v["min_process_execution_time"].(string)

    result := web.AutoHealActions{
        ActionType: web.AutoHealActionType(actionType),
        MinProcessExecutionTime: utils.String(minProcessExecutionTime),
    }
    return &result
}

func expandArmWebAppAutoHealTriggers(input []interface{}) *web.AutoHealTriggers {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    privateBytesInKb := v["private_bytes_in_kb"].(int)

    result := web.AutoHealTriggers{
        PrivateBytesInKb: utils.Int32(int32(privateBytesInKb)),
    }
    return &result
}

func expandArmWebAppRampUpRule(input []interface{}) *[]web.RampUpRule {
    results := make([]web.RampUpRule, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        actionHostName := v["action_host_name"].(string)
        reroutePercentage := v["reroute_percentage"].(float64)
        changeStep := v["change_step"].(float64)
        changeIntervalInMinutes := v["change_interval_in_minutes"].(int)
        minReroutePercentage := v["min_reroute_percentage"].(float64)
        maxReroutePercentage := v["max_reroute_percentage"].(float64)
        changeDecisionCallbackUrl := v["change_decision_callback_url"].(string)
        name := v["name"].(string)

        result := web.RampUpRule{
            ActionHostName: utils.String(actionHostName),
            ChangeDecisionCallbackURL: utils.String(changeDecisionCallbackUrl),
            ChangeIntervalInMinutes: utils.Int32(int32(changeIntervalInMinutes)),
            ChangeStep: utils.Float(changeStep),
            MaxReroutePercentage: utils.Float(maxReroutePercentage),
            MinReroutePercentage: utils.Float(minReroutePercentage),
            Name: utils.String(name),
            ReroutePercentage: utils.Float(reroutePercentage),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmWebAppVirtualDirectory(input []interface{}) *[]web.VirtualDirectory {
    results := make([]web.VirtualDirectory, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        virtualPath := v["virtual_path"].(string)
        physicalPath := v["physical_path"].(string)

        result := web.VirtualDirectory{
            PhysicalPath: utils.String(physicalPath),
            VirtualPath: utils.String(virtualPath),
        }

        results = append(results, result)
    }
    return &results
}


func flattenArmWebAppCloningInfo(input *web.CloningInfo) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["app_settings_overrides"] = utils.FlattenKeyValuePairs(input.AppSettingsOverrides)
    if cloneCustomHostNames := input.CloneCustomHostNames; cloneCustomHostNames != nil {
        result["clone_custom_host_names"] = *cloneCustomHostNames
    }
    if cloneSourceControl := input.CloneSourceControl; cloneSourceControl != nil {
        result["clone_source_control"] = *cloneSourceControl
    }
    if configureLoadBalancing := input.ConfigureLoadBalancing; configureLoadBalancing != nil {
        result["configure_load_balancing"] = *configureLoadBalancing
    }
    if correlationId := input.CorrelationID; correlationId != nil {
        result["correlation_id"] = *correlationId
    }
    if hostingEnvironment := input.HostingEnvironment; hostingEnvironment != nil {
        result["hosting_environment"] = *hostingEnvironment
    }
    if overwrite := input.Overwrite; overwrite != nil {
        result["overwrite"] = *overwrite
    }
    if sourceWebAppId := input.SourceWebAppID; sourceWebAppId != nil {
        result["source_web_app_id"] = *sourceWebAppId
    }
    if sourceWebAppLocation := input.SourceWebAppLocation; sourceWebAppLocation != nil {
        result["source_web_app_location"] = *sourceWebAppLocation
    }
    if trafficManagerProfileId := input.TrafficManagerProfileID; trafficManagerProfileId != nil {
        result["traffic_manager_profile_id"] = *trafficManagerProfileId
    }
    if trafficManagerProfileName := input.TrafficManagerProfileName; trafficManagerProfileName != nil {
        result["traffic_manager_profile_name"] = *trafficManagerProfileName
    }

    return []interface{}{result}
}

func flattenArmWebAppHostNameSslState(input *[]web.HostNameSslState) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        v["host_type"] = string(item.HostType)
        v["ssl_state"] = string(item.SslState)
        if thumbprint := item.Thumbprint; thumbprint != nil {
            v["thumbprint"] = *thumbprint
        }
        if toUpdate := item.ToUpdate; toUpdate != nil {
            v["to_update"] = *toUpdate
        }
        if virtualIp := item.VirtualIp; virtualIp != nil {
            v["virtual_ip"] = *virtualIp
        }

        results = append(results, v)
    }

    return results
}

func flattenArmWebAppHostingEnvironmentProfile(input *web.HostingEnvironmentProfile) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if id := input.ID; id != nil {
        result["id"] = *id
    }

    return []interface{}{result}
}

func flattenArmWebAppSiteConfig(input *web.SiteConfig) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if alwaysOn := input.AlwaysOn; alwaysOn != nil {
        result["always_on"] = *alwaysOn
    }
    result["api_definition"] = flattenArmWebAppApiDefinitionInfo(input.ApiDefinition)
    result["api_management_config"] = flattenArmWebAppApiManagementConfig(input.ApiManagementConfig)
    if appCommandLine := input.AppCommandLine; appCommandLine != nil {
        result["app_command_line"] = *appCommandLine
    }
    result["app_settings"] = flattenArmWebAppNameValuePair(input.AppSettings)
    if autoHealEnabled := input.AutoHealEnabled; autoHealEnabled != nil {
        result["auto_heal_enabled"] = *autoHealEnabled
    }
    result["auto_heal_rules"] = flattenArmWebAppAutoHealRules(input.AutoHealRules)
    if autoSwapSlotName := input.AutoSwapSlotName; autoSwapSlotName != nil {
        result["auto_swap_slot_name"] = *autoSwapSlotName
    }
    result["connection_strings"] = flattenArmWebAppConnStringInfo(input.ConnectionStrings)
    result["cors"] = flattenArmWebAppCorsSettings(input.Cors)
    result["default_documents"] = utils.FlattenStringSlice(input.DefaultDocuments)
    if detailedErrorLoggingEnabled := input.DetailedErrorLoggingEnabled; detailedErrorLoggingEnabled != nil {
        result["detailed_error_logging_enabled"] = *detailedErrorLoggingEnabled
    }
    if documentRoot := input.DocumentRoot; documentRoot != nil {
        result["document_root"] = *documentRoot
    }
    result["experiments"] = flattenArmWebAppExperiments(input.Experiments)
    result["ftps_state"] = string(input.FtpsState)
    result["handler_mappings"] = flattenArmWebAppHandlerMapping(input.HandlerMappings)
    if healthCheckPath := input.HealthCheckPath; healthCheckPath != nil {
        result["health_check_path"] = *healthCheckPath
    }
    if http20enabled := input.Http20enabled; http20enabled != nil {
        result["http20enabled"] = *http20enabled
    }
    if httpLoggingEnabled := input.HttpLoggingEnabled; httpLoggingEnabled != nil {
        result["http_logging_enabled"] = *httpLoggingEnabled
    }
    result["ip_security_restrictions"] = flattenArmWebAppIpSecurityRestriction(input.IpSecurityRestrictions)
    if javaContainer := input.JavaContainer; javaContainer != nil {
        result["java_container"] = *javaContainer
    }
    if javaContainerVersion := input.JavaContainerVersion; javaContainerVersion != nil {
        result["java_container_version"] = *javaContainerVersion
    }
    if javaVersion := input.JavaVersion; javaVersion != nil {
        result["java_version"] = *javaVersion
    }
    result["limits"] = flattenArmWebAppSiteLimits(input.Limits)
    if linuxFxVersion := input.LinuxFxVersion; linuxFxVersion != nil {
        result["linux_fx_version"] = *linuxFxVersion
    }
    result["load_balancing"] = string(input.LoadBalancing)
    if localMySqlEnabled := input.LocalMySqlEnabled; localMySqlEnabled != nil {
        result["local_my_sql_enabled"] = *localMySqlEnabled
    }
    if logsDirectorySizeLimit := input.LogsDirectorySizeLimit; logsDirectorySizeLimit != nil {
        result["logs_directory_size_limit"] = int(*logsDirectorySizeLimit)
    }
    result["managed_pipeline_mode"] = string(input.ManagedPipelineMode)
    if managedServiceIdentityId := input.ManagedServiceIdentityID; managedServiceIdentityId != nil {
        result["managed_service_identity_id"] = int(*managedServiceIdentityId)
    }
    result["min_tls_version"] = string(input.MinTlsVersion)
    if netFrameworkVersion := input.NetFrameworkVersion; netFrameworkVersion != nil {
        result["net_framework_version"] = *netFrameworkVersion
    }
    if nodeVersion := input.NodeVersion; nodeVersion != nil {
        result["node_version"] = *nodeVersion
    }
    if numberOfWorkers := input.NumberOfWorkers; numberOfWorkers != nil {
        result["number_of_workers"] = int(*numberOfWorkers)
    }
    if phpVersion := input.PhpVersion; phpVersion != nil {
        result["php_version"] = *phpVersion
    }
    if preWarmedInstanceCount := input.PreWarmedInstanceCount; preWarmedInstanceCount != nil {
        result["pre_warmed_instance_count"] = int(*preWarmedInstanceCount)
    }
    if publishingUsername := input.PublishingUsername; publishingUsername != nil {
        result["publishing_username"] = *publishingUsername
    }
    result["push"] = flattenArmWebAppPushSettings(input.Push)
    if pythonVersion := input.PythonVersion; pythonVersion != nil {
        result["python_version"] = *pythonVersion
    }
    if remoteDebuggingEnabled := input.RemoteDebuggingEnabled; remoteDebuggingEnabled != nil {
        result["remote_debugging_enabled"] = *remoteDebuggingEnabled
    }
    if remoteDebuggingVersion := input.RemoteDebuggingVersion; remoteDebuggingVersion != nil {
        result["remote_debugging_version"] = *remoteDebuggingVersion
    }
    if requestTracingEnabled := input.RequestTracingEnabled; requestTracingEnabled != nil {
        result["request_tracing_enabled"] = *requestTracingEnabled
    }
    if requestTracingExpirationTime := input.RequestTracingExpirationTime; requestTracingExpirationTime != nil {
        result["request_tracing_expiration_time"] = (*requestTracingExpirationTime).String()
    }
    result["scm_ip_security_restrictions"] = flattenArmWebAppIpSecurityRestriction(input.ScmIpSecurityRestrictions)
    if scmIpSecurityRestrictionsUseMain := input.ScmIpSecurityRestrictionsUseMain; scmIpSecurityRestrictionsUseMain != nil {
        result["scm_ip_security_restrictions_use_main"] = *scmIpSecurityRestrictionsUseMain
    }
    result["scm_type"] = string(input.ScmType)
    if tracingOptions := input.TracingOptions; tracingOptions != nil {
        result["tracing_options"] = *tracingOptions
    }
    if use32bitWorkerProcess := input.Use32bitWorkerProcess; use32bitWorkerProcess != nil {
        result["use32bit_worker_process"] = *use32bitWorkerProcess
    }
    result["virtual_applications"] = flattenArmWebAppVirtualApplication(input.VirtualApplications)
    if vnetName := input.VnetName; vnetName != nil {
        result["vnet_name"] = *vnetName
    }
    if webSocketsEnabled := input.WebSocketsEnabled; webSocketsEnabled != nil {
        result["web_sockets_enabled"] = *webSocketsEnabled
    }
    if windowsFxVersion := input.WindowsFxVersion; windowsFxVersion != nil {
        result["windows_fx_version"] = *windowsFxVersion
    }
    if xManagedServiceIdentityId := input.XManagedServiceIdentityID; xManagedServiceIdentityId != nil {
        result["x_managed_service_identity_id"] = int(*xManagedServiceIdentityId)
    }

    return []interface{}{result}
}

func flattenArmWebAppSlotSwapStatus(input *web.SlotSwapStatus) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})


    return []interface{}{result}
}

func flattenArmWebAppManagedServiceIdentity(input *web.ManagedServiceIdentity) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["type"] = string(input.Type)
    result["user_assigned_identities"] = utils.FlattenKeyValuePairs(input.UserAssignedIdentities)

    return []interface{}{result}
}

func flattenArmWebAppApiDefinitionInfo(input *web.ApiDefinitionInfo) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if url := input.URL; url != nil {
        result["url"] = *url
    }

    return []interface{}{result}
}

func flattenArmWebAppApiManagementConfig(input *web.ApiManagementConfig) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if id := input.ID; id != nil {
        result["id"] = *id
    }

    return []interface{}{result}
}

func flattenArmWebAppNameValuePair(input *[]web.NameValuePair) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if value := item.Value; value != nil {
            v["value"] = *value
        }

        results = append(results, v)
    }

    return results
}

func flattenArmWebAppAutoHealRules(input *web.AutoHealRules) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["actions"] = flattenArmWebAppAutoHealActions(input.Actions)
    result["triggers"] = flattenArmWebAppAutoHealTriggers(input.Triggers)

    return []interface{}{result}
}

func flattenArmWebAppConnStringInfo(input *[]web.ConnStringInfo) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if connectionString := item.ConnectionString; connectionString != nil {
            v["connection_string"] = *connectionString
        }
        v["type"] = string(item.Type)

        results = append(results, v)
    }

    return results
}

func flattenArmWebAppCorsSettings(input *web.CorsSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["allowed_origins"] = utils.FlattenStringSlice(input.AllowedOrigins)
    if supportCredentials := input.SupportCredentials; supportCredentials != nil {
        result["support_credentials"] = *supportCredentials
    }

    return []interface{}{result}
}

func flattenArmWebAppExperiments(input *web.Experiments) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["ramp_up_rules"] = flattenArmWebAppRampUpRule(input.RampUpRules)

    return []interface{}{result}
}

func flattenArmWebAppHandlerMapping(input *[]web.HandlerMapping) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if arguments := item.Arguments; arguments != nil {
            v["arguments"] = *arguments
        }
        if extension := item.Extension; extension != nil {
            v["extension"] = *extension
        }
        if scriptProcessor := item.ScriptProcessor; scriptProcessor != nil {
            v["script_processor"] = *scriptProcessor
        }

        results = append(results, v)
    }

    return results
}

func flattenArmWebAppIpSecurityRestriction(input *[]web.IpSecurityRestriction) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if action := item.Action; action != nil {
            v["action"] = *action
        }
        if description := item.Description; description != nil {
            v["description"] = *description
        }
        if ipAddress := item.IpAddress; ipAddress != nil {
            v["ip_address"] = *ipAddress
        }
        if priority := item.Priority; priority != nil {
            v["priority"] = int(*priority)
        }
        if subnetMask := item.SubnetMask; subnetMask != nil {
            v["subnet_mask"] = *subnetMask
        }
        if subnetTrafficTag := item.SubnetTrafficTag; subnetTrafficTag != nil {
            v["subnet_traffic_tag"] = int(*subnetTrafficTag)
        }
        v["tag"] = string(item.Tag)
        if vnetSubnetResourceId := item.VnetSubnetResourceID; vnetSubnetResourceId != nil {
            v["vnet_subnet_resource_id"] = *vnetSubnetResourceId
        }
        if vnetTrafficTag := item.VnetTrafficTag; vnetTrafficTag != nil {
            v["vnet_traffic_tag"] = int(*vnetTrafficTag)
        }

        results = append(results, v)
    }

    return results
}

func flattenArmWebAppSiteLimits(input *web.SiteLimits) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if maxDiskSizeInMb := input.MaxDiskSizeInMb; maxDiskSizeInMb != nil {
        result["max_disk_size_in_mb"] = int(*maxDiskSizeInMb)
    }
    if maxMemoryInMb := input.MaxMemoryInMb; maxMemoryInMb != nil {
        result["max_memory_in_mb"] = int(*maxMemoryInMb)
    }
    if maxPercentageCpu := input.MaxPercentageCpu; maxPercentageCpu != nil {
        result["max_percentage_cpu"] = *maxPercentageCpu
    }

    return []interface{}{result}
}

func flattenArmWebAppPushSettings(input *web.PushSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if pushSettingsProperties := input.PushSettings_properties; pushSettingsProperties != nil {
        if dynamicTagsJson := pushSettingsProperties.DynamicTagsJson; dynamicTagsJson != nil {
            result["dynamic_tags_json"] = *dynamicTagsJson
        }
        if isPushEnabled := pushSettingsProperties.IsPushEnabled; isPushEnabled != nil {
            result["is_push_enabled"] = *isPushEnabled
        }
        if tagWhitelistJson := pushSettingsProperties.TagWhitelistJson; tagWhitelistJson != nil {
            result["tag_whitelist_json"] = *tagWhitelistJson
        }
        if tagsRequiringAuth := pushSettingsProperties.TagsRequiringAuth; tagsRequiringAuth != nil {
            result["tags_requiring_auth"] = *tagsRequiringAuth
        }
    }
    if kind := input.Kind; kind != nil {
        result["kind"] = *kind
    }

    return []interface{}{result}
}

func flattenArmWebAppVirtualApplication(input *[]web.VirtualApplication) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if physicalPath := item.PhysicalPath; physicalPath != nil {
            v["physical_path"] = *physicalPath
        }
        if preloadEnabled := item.PreloadEnabled; preloadEnabled != nil {
            v["preload_enabled"] = *preloadEnabled
        }
        v["virtual_directories"] = flattenArmWebAppVirtualDirectory(item.VirtualDirectories)
        if virtualPath := item.VirtualPath; virtualPath != nil {
            v["virtual_path"] = *virtualPath
        }

        results = append(results, v)
    }

    return results
}

func flattenArmWebAppAutoHealActions(input *web.AutoHealActions) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["action_type"] = string(input.ActionType)
    if minProcessExecutionTime := input.MinProcessExecutionTime; minProcessExecutionTime != nil {
        result["min_process_execution_time"] = *minProcessExecutionTime
    }

    return []interface{}{result}
}

func flattenArmWebAppAutoHealTriggers(input *web.AutoHealTriggers) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if privateBytesInKb := input.PrivateBytesInKb; privateBytesInKb != nil {
        result["private_bytes_in_kb"] = int(*privateBytesInKb)
    }

    return []interface{}{result}
}

func flattenArmWebAppRampUpRule(input *[]web.RampUpRule) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if actionHostName := item.ActionHostName; actionHostName != nil {
            v["action_host_name"] = *actionHostName
        }
        if changeDecisionCallbackUrl := item.ChangeDecisionCallbackURL; changeDecisionCallbackUrl != nil {
            v["change_decision_callback_url"] = *changeDecisionCallbackUrl
        }
        if changeIntervalInMinutes := item.ChangeIntervalInMinutes; changeIntervalInMinutes != nil {
            v["change_interval_in_minutes"] = int(*changeIntervalInMinutes)
        }
        if changeStep := item.ChangeStep; changeStep != nil {
            v["change_step"] = *changeStep
        }
        if maxReroutePercentage := item.MaxReroutePercentage; maxReroutePercentage != nil {
            v["max_reroute_percentage"] = *maxReroutePercentage
        }
        if minReroutePercentage := item.MinReroutePercentage; minReroutePercentage != nil {
            v["min_reroute_percentage"] = *minReroutePercentage
        }
        if reroutePercentage := item.ReroutePercentage; reroutePercentage != nil {
            v["reroute_percentage"] = *reroutePercentage
        }

        results = append(results, v)
    }

    return results
}

func flattenArmWebAppVirtualDirectory(input *[]web.VirtualDirectory) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if physicalPath := item.PhysicalPath; physicalPath != nil {
            v["physical_path"] = *physicalPath
        }
        if virtualPath := item.VirtualPath; virtualPath != nil {
            v["virtual_path"] = *virtualPath
        }

        results = append(results, v)
    }

    return results
}
