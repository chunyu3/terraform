// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmStreamingPolicy() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmStreamingPolicyCreateUpdate,
        Read: resourceArmStreamingPolicyRead,
        Update: resourceArmStreamingPolicyCreateUpdate,
        Delete: resourceArmStreamingPolicyDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "account_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "streaming_policy_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "common_encryption_cbcs": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "clear_tracks": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "track_selections": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "operation": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.Equal),
                                                    }, false),
                                                },
                                                "property": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.FourCC),
                                                    }, false),
                                                },
                                                "value": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "content_keys": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "default_key": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "key_to_track_mappings": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "drm": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "fair_play": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "allow_persistent_license": {
                                                    Type: schema.TypeBool,
                                                    Required: true,
                                                },
                                                "custom_license_acquisition_url_template": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "play_ready": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "custom_license_acquisition_url_template": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "play_ready_custom_attributes": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "widevine": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "custom_license_acquisition_url_template": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "enabled_protocols": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "dash": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "download": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "hls": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "smooth_streaming": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "common_encryption_cenc": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "clear_tracks": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "track_selections": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "operation": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.Equal),
                                                    }, false),
                                                },
                                                "property": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.FourCC),
                                                    }, false),
                                                },
                                                "value": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "content_keys": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "default_key": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "key_to_track_mappings": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "drm": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "play_ready": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "custom_license_acquisition_url_template": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "play_ready_custom_attributes": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "widevine": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "custom_license_acquisition_url_template": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "enabled_protocols": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "dash": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "download": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "hls": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "smooth_streaming": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "default_content_key_policy_name": {
                Type: schema.TypeString,
                Optional: true,
            },

            "envelope_encryption": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "clear_tracks": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "track_selections": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "operation": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.Equal),
                                                    }, false),
                                                },
                                                "property": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(mediaservices.Unknown),
                                                        string(mediaservices.FourCC),
                                                    }, false),
                                                },
                                                "value": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "content_keys": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "default_key": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "key_to_track_mappings": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "label": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "policy_name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "custom_license_acquisition_url_template": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "enabled_protocols": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "dash": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "download": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "hls": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "smooth_streaming": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "no_encryption": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "enabled_protocols": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "dash": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "download": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "hls": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                    "smooth_streaming": {
                                        Type: schema.TypeBool,
                                        Required: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "created": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },
        },
    }
}

func resourceArmStreamingPolicyCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).streamingPoliciesClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    accountName := d.Get("account_name").(string)
    streamingPolicyName := d.Get("streaming_policy_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, accountName, streamingPolicyName)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Streaming Policy (Streaming Policy Name %q / Account Name %q / Resource Group %q): %+v", streamingPolicyName, accountName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_streaming_policy", *existing.ID)
        }
    }

    commonEncryptionCbcs := d.Get("common_encryption_cbcs").([]interface{})
    commonEncryptionCenc := d.Get("common_encryption_cenc").([]interface{})
    defaultContentKeyPolicyName := d.Get("default_content_key_policy_name").(string)
    envelopeEncryption := d.Get("envelope_encryption").([]interface{})
    noEncryption := d.Get("no_encryption").([]interface{})

    parameters := mediaservices.StreamingPolicy{
        StreamingPolicyProperties: &mediaservices.StreamingPolicyProperties{
            CommonEncryptionCbcs: expandArmStreamingPolicyCommonEncryptionCbcs(commonEncryptionCbcs),
            CommonEncryptionCenc: expandArmStreamingPolicyCommonEncryptionCenc(commonEncryptionCenc),
            DefaultContentKeyPolicyName: utils.String(defaultContentKeyPolicyName),
            EnvelopeEncryption: expandArmStreamingPolicyEnvelopeEncryption(envelopeEncryption),
            NoEncryption: expandArmStreamingPolicyNoEncryption(noEncryption),
        },
    }


    if _, err := client.Create(ctx, resourceGroup, accountName, streamingPolicyName, parameters); err != nil {
        return fmt.Errorf("Error creating Streaming Policy (Streaming Policy Name %q / Account Name %q / Resource Group %q): %+v", streamingPolicyName, accountName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, accountName, streamingPolicyName)
    if err != nil {
        return fmt.Errorf("Error retrieving Streaming Policy (Streaming Policy Name %q / Account Name %q / Resource Group %q): %+v", streamingPolicyName, accountName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Streaming Policy (Streaming Policy Name %q / Account Name %q / Resource Group %q) ID", streamingPolicyName, accountName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmStreamingPolicyRead(d, meta)
}

func resourceArmStreamingPolicyRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).streamingPoliciesClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    accountName := id.Path["mediaServices"]
    streamingPolicyName := id.Path["streamingPolicies"]

    resp, err := client.Get(ctx, resourceGroup, accountName, streamingPolicyName)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Streaming Policy %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Streaming Policy (Streaming Policy Name %q / Account Name %q / Resource Group %q): %+v", streamingPolicyName, accountName, resourceGroup, err)
    }


    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    d.Set("account_name", accountName)
    if streamingPolicyProperties := resp.StreamingPolicyProperties; streamingPolicyProperties != nil {
        if err := d.Set("common_encryption_cbcs", flattenArmStreamingPolicyCommonEncryptionCbcs(streamingPolicyProperties.CommonEncryptionCbcs)); err != nil {
            return fmt.Errorf("Error setting `common_encryption_cbcs`: %+v", err)
        }
        if err := d.Set("common_encryption_cenc", flattenArmStreamingPolicyCommonEncryptionCenc(streamingPolicyProperties.CommonEncryptionCenc)); err != nil {
            return fmt.Errorf("Error setting `common_encryption_cenc`: %+v", err)
        }
        d.Set("created", (streamingPolicyProperties.Created).String())
        d.Set("default_content_key_policy_name", streamingPolicyProperties.DefaultContentKeyPolicyName)
        if err := d.Set("envelope_encryption", flattenArmStreamingPolicyEnvelopeEncryption(streamingPolicyProperties.EnvelopeEncryption)); err != nil {
            return fmt.Errorf("Error setting `envelope_encryption`: %+v", err)
        }
        if err := d.Set("no_encryption", flattenArmStreamingPolicyNoEncryption(streamingPolicyProperties.NoEncryption)); err != nil {
            return fmt.Errorf("Error setting `no_encryption`: %+v", err)
        }
    }
    d.Set("streaming_policy_name", streamingPolicyName)
    d.Set("type", resp.Type)

    return nil
}


func resourceArmStreamingPolicyDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).streamingPoliciesClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    accountName := id.Path["mediaServices"]
    streamingPolicyName := id.Path["streamingPolicies"]

    if _, err := client.Delete(ctx, resourceGroup, accountName, streamingPolicyName); err != nil {
        return fmt.Errorf("Error deleting Streaming Policy (Streaming Policy Name %q / Account Name %q / Resource Group %q): %+v", streamingPolicyName, accountName, resourceGroup, err)
    }

    return nil
}

func expandArmStreamingPolicyCommonEncryptionCbcs(input []interface{}) *mediaservices.CommonEncryptionCbcs {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enabledProtocols := v["enabled_protocols"].([]interface{})
    clearTracks := v["clear_tracks"].([]interface{})
    contentKeys := v["content_keys"].([]interface{})
    drm := v["drm"].([]interface{})

    result := mediaservices.CommonEncryptionCbcs{
        ClearTracks: expandArmStreamingPolicyTrackSelection(clearTracks),
        ContentKeys: expandArmStreamingPolicyStreamingPolicyContentKeys(contentKeys),
        Drm: expandArmStreamingPolicyCbcsDrmConfiguration(drm),
        EnabledProtocols: expandArmStreamingPolicyEnabledProtocols(enabledProtocols),
    }
    return &result
}

func expandArmStreamingPolicyCommonEncryptionCenc(input []interface{}) *mediaservices.CommonEncryptionCenc {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enabledProtocols := v["enabled_protocols"].([]interface{})
    clearTracks := v["clear_tracks"].([]interface{})
    contentKeys := v["content_keys"].([]interface{})
    drm := v["drm"].([]interface{})

    result := mediaservices.CommonEncryptionCenc{
        ClearTracks: expandArmStreamingPolicyTrackSelection(clearTracks),
        ContentKeys: expandArmStreamingPolicyStreamingPolicyContentKeys(contentKeys),
        Drm: expandArmStreamingPolicyCencDrmConfiguration(drm),
        EnabledProtocols: expandArmStreamingPolicyEnabledProtocols(enabledProtocols),
    }
    return &result
}

func expandArmStreamingPolicyEnvelopeEncryption(input []interface{}) *mediaservices.EnvelopeEncryption {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enabledProtocols := v["enabled_protocols"].([]interface{})
    clearTracks := v["clear_tracks"].([]interface{})
    contentKeys := v["content_keys"].([]interface{})
    customLicenseAcquisitionUrlTemplate := v["custom_license_acquisition_url_template"].(string)

    result := mediaservices.EnvelopeEncryption{
        ClearTracks: expandArmStreamingPolicyTrackSelection(clearTracks),
        ContentKeys: expandArmStreamingPolicyStreamingPolicyContentKeys(contentKeys),
        CustomLicenseAcquisitionURLTemplate: utils.String(customLicenseAcquisitionUrlTemplate),
        EnabledProtocols: expandArmStreamingPolicyEnabledProtocols(enabledProtocols),
    }
    return &result
}

func expandArmStreamingPolicyNoEncryption(input []interface{}) *mediaservices.NoEncryption {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enabledProtocols := v["enabled_protocols"].([]interface{})

    result := mediaservices.NoEncryption{
        EnabledProtocols: expandArmStreamingPolicyEnabledProtocols(enabledProtocols),
    }
    return &result
}

func expandArmStreamingPolicyTrackSelection(input []interface{}) *[]mediaservices.TrackSelection {
    results := make([]mediaservices.TrackSelection, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        trackSelections := v["track_selections"].([]interface{})

        result := mediaservices.TrackSelection{
            TrackSelections: expandArmStreamingPolicyTrackPropertyCondition(trackSelections),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmStreamingPolicyStreamingPolicyContentKeys(input []interface{}) *mediaservices.StreamingPolicyContentKeys {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    defaultKey := v["default_key"].([]interface{})
    keyToTrackMappings := v["key_to_track_mappings"].([]interface{})

    result := mediaservices.StreamingPolicyContentKeys{
        DefaultKey: expandArmStreamingPolicyDefaultKey(defaultKey),
        KeyToTrackMappings: expandArmStreamingPolicyStreamingPolicyContentKey(keyToTrackMappings),
    }
    return &result
}

func expandArmStreamingPolicyCbcsDrmConfiguration(input []interface{}) *mediaservices.CbcsDrmConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    fairPlay := v["fair_play"].([]interface{})
    playReady := v["play_ready"].([]interface{})
    widevine := v["widevine"].([]interface{})

    result := mediaservices.CbcsDrmConfiguration{
        FairPlay: expandArmStreamingPolicyStreamingPolicyFairPlayConfiguration(fairPlay),
        PlayReady: expandArmStreamingPolicyStreamingPolicyPlayReadyConfiguration(playReady),
        Widevine: expandArmStreamingPolicyStreamingPolicyWidevineConfiguration(widevine),
    }
    return &result
}

func expandArmStreamingPolicyEnabledProtocols(input []interface{}) *mediaservices.EnabledProtocols {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    download := v["download"].(bool)
    dash := v["dash"].(bool)
    hls := v["hls"].(bool)
    smoothStreaming := v["smooth_streaming"].(bool)

    result := mediaservices.EnabledProtocols{
        Dash: utils.Bool(dash),
        Download: utils.Bool(download),
        Hls: utils.Bool(hls),
        SmoothStreaming: utils.Bool(smoothStreaming),
    }
    return &result
}

func expandArmStreamingPolicyCencDrmConfiguration(input []interface{}) *mediaservices.CencDrmConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    playReady := v["play_ready"].([]interface{})
    widevine := v["widevine"].([]interface{})

    result := mediaservices.CencDrmConfiguration{
        PlayReady: expandArmStreamingPolicyStreamingPolicyPlayReadyConfiguration(playReady),
        Widevine: expandArmStreamingPolicyStreamingPolicyWidevineConfiguration(widevine),
    }
    return &result
}

func expandArmStreamingPolicyTrackPropertyCondition(input []interface{}) *[]mediaservices.TrackPropertyCondition {
    results := make([]mediaservices.TrackPropertyCondition, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        property := v["property"].(string)
        operation := v["operation"].(string)
        value := v["value"].(string)

        result := mediaservices.TrackPropertyCondition{
            Operation: mediaservices.TrackPropertyCompareOperation(operation),
            Property: mediaservices.TrackPropertyType(property),
            Value: utils.String(value),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmStreamingPolicyDefaultKey(input []interface{}) *mediaservices.DefaultKey {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    label := v["label"].(string)
    policyName := v["policy_name"].(string)

    result := mediaservices.DefaultKey{
        Label: utils.String(label),
        PolicyName: utils.String(policyName),
    }
    return &result
}

func expandArmStreamingPolicyStreamingPolicyContentKey(input []interface{}) *[]mediaservices.StreamingPolicyContentKey {
    results := make([]mediaservices.StreamingPolicyContentKey, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        label := v["label"].(string)
        policyName := v["policy_name"].(string)

        result := mediaservices.StreamingPolicyContentKey{
            Label: utils.String(label),
            PolicyName: utils.String(policyName),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmStreamingPolicyStreamingPolicyFairPlayConfiguration(input []interface{}) *mediaservices.StreamingPolicyFairPlayConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    customLicenseAcquisitionUrlTemplate := v["custom_license_acquisition_url_template"].(string)
    allowPersistentLicense := v["allow_persistent_license"].(bool)

    result := mediaservices.StreamingPolicyFairPlayConfiguration{
        AllowPersistentLicense: utils.Bool(allowPersistentLicense),
        CustomLicenseAcquisitionURLTemplate: utils.String(customLicenseAcquisitionUrlTemplate),
    }
    return &result
}

func expandArmStreamingPolicyStreamingPolicyPlayReadyConfiguration(input []interface{}) *mediaservices.StreamingPolicyPlayReadyConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    customLicenseAcquisitionUrlTemplate := v["custom_license_acquisition_url_template"].(string)
    playReadyCustomAttributes := v["play_ready_custom_attributes"].(string)

    result := mediaservices.StreamingPolicyPlayReadyConfiguration{
        CustomLicenseAcquisitionURLTemplate: utils.String(customLicenseAcquisitionUrlTemplate),
        PlayReadyCustomAttributes: utils.String(playReadyCustomAttributes),
    }
    return &result
}

func expandArmStreamingPolicyStreamingPolicyWidevineConfiguration(input []interface{}) *mediaservices.StreamingPolicyWidevineConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    customLicenseAcquisitionUrlTemplate := v["custom_license_acquisition_url_template"].(string)

    result := mediaservices.StreamingPolicyWidevineConfiguration{
        CustomLicenseAcquisitionURLTemplate: utils.String(customLicenseAcquisitionUrlTemplate),
    }
    return &result
}


func flattenArmStreamingPolicyCommonEncryptionCbcs(input *mediaservices.CommonEncryptionCbcs) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["clear_tracks"] = flattenArmStreamingPolicyTrackSelection(input.ClearTracks)
    result["content_keys"] = flattenArmStreamingPolicyStreamingPolicyContentKeys(input.ContentKeys)
    result["drm"] = flattenArmStreamingPolicyCbcsDrmConfiguration(input.Drm)
    result["enabled_protocols"] = flattenArmStreamingPolicyEnabledProtocols(input.EnabledProtocols)

    return []interface{}{result}
}

func flattenArmStreamingPolicyCommonEncryptionCenc(input *mediaservices.CommonEncryptionCenc) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["clear_tracks"] = flattenArmStreamingPolicyTrackSelection(input.ClearTracks)
    result["content_keys"] = flattenArmStreamingPolicyStreamingPolicyContentKeys(input.ContentKeys)
    result["drm"] = flattenArmStreamingPolicyCencDrmConfiguration(input.Drm)
    result["enabled_protocols"] = flattenArmStreamingPolicyEnabledProtocols(input.EnabledProtocols)

    return []interface{}{result}
}

func flattenArmStreamingPolicyEnvelopeEncryption(input *mediaservices.EnvelopeEncryption) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["clear_tracks"] = flattenArmStreamingPolicyTrackSelection(input.ClearTracks)
    result["content_keys"] = flattenArmStreamingPolicyStreamingPolicyContentKeys(input.ContentKeys)
    if customLicenseAcquisitionUrlTemplate := input.CustomLicenseAcquisitionURLTemplate; customLicenseAcquisitionUrlTemplate != nil {
        result["custom_license_acquisition_url_template"] = *customLicenseAcquisitionUrlTemplate
    }
    result["enabled_protocols"] = flattenArmStreamingPolicyEnabledProtocols(input.EnabledProtocols)

    return []interface{}{result}
}

func flattenArmStreamingPolicyNoEncryption(input *mediaservices.NoEncryption) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["enabled_protocols"] = flattenArmStreamingPolicyEnabledProtocols(input.EnabledProtocols)

    return []interface{}{result}
}

func flattenArmStreamingPolicyTrackSelection(input *[]mediaservices.TrackSelection) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        v["track_selections"] = flattenArmStreamingPolicyTrackPropertyCondition(item.TrackSelections)

        results = append(results, v)
    }

    return results
}

func flattenArmStreamingPolicyStreamingPolicyContentKeys(input *mediaservices.StreamingPolicyContentKeys) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["default_key"] = flattenArmStreamingPolicyDefaultKey(input.DefaultKey)
    result["key_to_track_mappings"] = flattenArmStreamingPolicyStreamingPolicyContentKey(input.KeyToTrackMappings)

    return []interface{}{result}
}

func flattenArmStreamingPolicyCbcsDrmConfiguration(input *mediaservices.CbcsDrmConfiguration) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["fair_play"] = flattenArmStreamingPolicyStreamingPolicyFairPlayConfiguration(input.FairPlay)
    result["play_ready"] = flattenArmStreamingPolicyStreamingPolicyPlayReadyConfiguration(input.PlayReady)
    result["widevine"] = flattenArmStreamingPolicyStreamingPolicyWidevineConfiguration(input.Widevine)

    return []interface{}{result}
}

func flattenArmStreamingPolicyEnabledProtocols(input *mediaservices.EnabledProtocols) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if dash := input.Dash; dash != nil {
        result["dash"] = *dash
    }
    if download := input.Download; download != nil {
        result["download"] = *download
    }
    if hls := input.Hls; hls != nil {
        result["hls"] = *hls
    }
    if smoothStreaming := input.SmoothStreaming; smoothStreaming != nil {
        result["smooth_streaming"] = *smoothStreaming
    }

    return []interface{}{result}
}

func flattenArmStreamingPolicyCencDrmConfiguration(input *mediaservices.CencDrmConfiguration) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["play_ready"] = flattenArmStreamingPolicyStreamingPolicyPlayReadyConfiguration(input.PlayReady)
    result["widevine"] = flattenArmStreamingPolicyStreamingPolicyWidevineConfiguration(input.Widevine)

    return []interface{}{result}
}

func flattenArmStreamingPolicyTrackPropertyCondition(input *[]mediaservices.TrackPropertyCondition) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        v["operation"] = string(item.Operation)
        v["property"] = string(item.Property)
        if value := item.Value; value != nil {
            v["value"] = *value
        }

        results = append(results, v)
    }

    return results
}

func flattenArmStreamingPolicyDefaultKey(input *mediaservices.DefaultKey) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if label := input.Label; label != nil {
        result["label"] = *label
    }
    if policyName := input.PolicyName; policyName != nil {
        result["policy_name"] = *policyName
    }

    return []interface{}{result}
}

func flattenArmStreamingPolicyStreamingPolicyContentKey(input *[]mediaservices.StreamingPolicyContentKey) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if label := item.Label; label != nil {
            v["label"] = *label
        }
        if policyName := item.PolicyName; policyName != nil {
            v["policy_name"] = *policyName
        }

        results = append(results, v)
    }

    return results
}

func flattenArmStreamingPolicyStreamingPolicyFairPlayConfiguration(input *mediaservices.StreamingPolicyFairPlayConfiguration) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if allowPersistentLicense := input.AllowPersistentLicense; allowPersistentLicense != nil {
        result["allow_persistent_license"] = *allowPersistentLicense
    }
    if customLicenseAcquisitionUrlTemplate := input.CustomLicenseAcquisitionURLTemplate; customLicenseAcquisitionUrlTemplate != nil {
        result["custom_license_acquisition_url_template"] = *customLicenseAcquisitionUrlTemplate
    }

    return []interface{}{result}
}

func flattenArmStreamingPolicyStreamingPolicyPlayReadyConfiguration(input *mediaservices.StreamingPolicyPlayReadyConfiguration) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if customLicenseAcquisitionUrlTemplate := input.CustomLicenseAcquisitionURLTemplate; customLicenseAcquisitionUrlTemplate != nil {
        result["custom_license_acquisition_url_template"] = *customLicenseAcquisitionUrlTemplate
    }
    if playReadyCustomAttributes := input.PlayReadyCustomAttributes; playReadyCustomAttributes != nil {
        result["play_ready_custom_attributes"] = *playReadyCustomAttributes
    }

    return []interface{}{result}
}

func flattenArmStreamingPolicyStreamingPolicyWidevineConfiguration(input *mediaservices.StreamingPolicyWidevineConfiguration) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if customLicenseAcquisitionUrlTemplate := input.CustomLicenseAcquisitionURLTemplate; customLicenseAcquisitionUrlTemplate != nil {
        result["custom_license_acquisition_url_template"] = *customLicenseAcquisitionUrlTemplate
    }

    return []interface{}{result}
}
