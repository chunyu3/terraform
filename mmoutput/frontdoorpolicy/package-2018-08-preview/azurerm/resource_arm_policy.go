// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmPolicy() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmPolicyCreateUpdate,
        Read: resourceArmPolicyRead,
        Update: resourceArmPolicyCreateUpdate,
        Delete: resourceArmPolicyDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "custom_rules": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "action": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(frontdoor.Allow),
                                            string(frontdoor.Block),
                                            string(frontdoor.Log),
                                        }, false),
                                    },
                                    "match_conditions": {
                                        Type: schema.TypeList,
                                        Required: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "match_value": {
                                                    Type: schema.TypeList,
                                                    Required: true,
                                                    Elem: &schema.Schema{
                                                        Type: schema.TypeString,
                                                    },
                                                },
                                                "match_variable": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(frontdoor.RemoteAddr),
                                                        string(frontdoor.RequestMethod),
                                                        string(frontdoor.QueryString),
                                                        string(frontdoor.PostArgs),
                                                        string(frontdoor.RequestUri),
                                                        string(frontdoor.RequestHeader),
                                                        string(frontdoor.RequestBody),
                                                    }, false),
                                                },
                                                "operator": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validation.StringInSlice([]string{
                                                        string(frontdoor.Any),
                                                        string(frontdoor.IPMatch),
                                                        string(frontdoor.GeoMatch),
                                                        string(frontdoor.Equal),
                                                        string(frontdoor.Contains),
                                                        string(frontdoor.LessThan),
                                                        string(frontdoor.GreaterThan),
                                                        string(frontdoor.LessThanOrEqual),
                                                        string(frontdoor.GreaterThanOrEqual),
                                                        string(frontdoor.BeginsWith),
                                                        string(frontdoor.EndsWith),
                                                    }, false),
                                                },
                                                "negate_condition": {
                                                    Type: schema.TypeBool,
                                                    Optional: true,
                                                },
                                                "selector": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "priority": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "rule_type": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(frontdoor.MatchRule),
                                            string(frontdoor.RateLimitRule),
                                        }, false),
                                    },
                                    "name": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "rate_limit_duration_in_minutes": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "rate_limit_threshold": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "transforms": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeString,
                                            ValidateFunc: validation.StringInSlice([]string{
                                                string(frontdoor.Lowercase),
                                                string(frontdoor.Uppercase),
                                                string(frontdoor.Trim),
                                                string(frontdoor.UrlDecode),
                                                string(frontdoor.UrlEncode),
                                                string(frontdoor.RemoveNulls),
                                                string(frontdoor.HtmlEntityDecode),
                                           }, false),
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "etag": {
                Type: schema.TypeString,
                Optional: true,
                ForceNew: true,
            },

            "managed_rules": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "rule_sets": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "priority": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "version": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "policy_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "enabled_state": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(frontdoor.Disabled),
                                string(frontdoor.Enabled),
                            }, false),
                            Default: string(frontdoor.Disabled),
                        },
                        "mode": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(frontdoor.Prevention),
                                string(frontdoor.Detection),
                            }, false),
                            Default: string(frontdoor.Prevention),
                        },
                    },
                },
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "resource_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmPolicyCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).policiesClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Policy %q (Resource Group %q): %+v", name, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_policy", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    customRules := d.Get("custom_rules").([]interface{})
    etag := d.Get("etag").(string)
    managedRules := d.Get("managed_rules").([]interface{})
    policySettings := d.Get("policy_settings").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    parameters := frontdoor.WebApplicationFirewallPolicy{
        Etag: utils.String(etag),
        Location: utils.String(location),
        WebApplicationFirewallPolicyPropertiesFormat: &frontdoor.WebApplicationFirewallPolicyPropertiesFormat{
            CustomRules: expandArmPolicyCustomRules(customRules),
            ManagedRules: expandArmPolicyManagedRuleSets(managedRules),
            PolicySettings: expandArmPolicyPolicySettings(policySettings),
        },
        Tags: tags.Expand(t),
    }


    if _, err := client.CreateOrUpdate(ctx, resourceGroup, name, parameters); err != nil {
        return fmt.Errorf("Error creating Policy %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Policy %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Policy %q (Resource Group %q) ID", name, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmPolicyRead(d, meta)
}

func resourceArmPolicyRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).policiesClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["FrontDoorWebApplicationFirewallPolicies"]

    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Policy %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Policy %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    if webApplicationFirewallPolicyPropertiesFormat := resp.WebApplicationFirewallPolicyPropertiesFormat; webApplicationFirewallPolicyPropertiesFormat != nil {
        if err := d.Set("custom_rules", flattenArmPolicyCustomRules(webApplicationFirewallPolicyPropertiesFormat.CustomRules)); err != nil {
            return fmt.Errorf("Error setting `custom_rules`: %+v", err)
        }
        if err := d.Set("managed_rules", flattenArmPolicyManagedRuleSets(webApplicationFirewallPolicyPropertiesFormat.ManagedRules)); err != nil {
            return fmt.Errorf("Error setting `managed_rules`: %+v", err)
        }
        if err := d.Set("policy_settings", flattenArmPolicyPolicySettings(webApplicationFirewallPolicyPropertiesFormat.PolicySettings)); err != nil {
            return fmt.Errorf("Error setting `policy_settings`: %+v", err)
        }
        d.Set("provisioning_state", webApplicationFirewallPolicyPropertiesFormat.ProvisioningState)
        d.Set("resource_state", string(webApplicationFirewallPolicyPropertiesFormat.ResourceState))
    }
    d.Set("etag", resp.Etag)
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}


func resourceArmPolicyDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).policiesClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["FrontDoorWebApplicationFirewallPolicies"]

    future, err := client.Delete(ctx, resourceGroup, name)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Policy %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Policy %q (Resource Group %q): %+v", name, resourceGroup, err)
        }
    }

    return nil
}

func expandArmPolicyCustomRules(input []interface{}) *frontdoor.CustomRules {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    rules := v["rules"].([]interface{})

    result := frontdoor.CustomRules{
        Rules: expandArmPolicyCustomRule(rules),
    }
    return &result
}

func expandArmPolicyManagedRuleSets(input []interface{}) *frontdoor.ManagedRuleSets {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    ruleSets := v["rule_sets"].([]interface{})

    result := frontdoor.ManagedRuleSets{
        RuleSets: expandArmPolicyUnknown(ruleSets),
    }
    return &result
}

func expandArmPolicyPolicySettings(input []interface{}) *frontdoor.PolicySettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enabledState := v["enabled_state"].(string)
    mode := v["mode"].(string)

    result := frontdoor.PolicySettings{
        EnabledState: frontdoor.EnabledState(enabledState),
        Mode: frontdoor.Mode(mode),
    }
    return &result
}

func expandArmPolicyCustomRule(input []interface{}) *[]frontdoor.CustomRule {
    results := make([]frontdoor.CustomRule, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        priority := v["priority"].(int)
        ruleType := v["rule_type"].(string)
        rateLimitDurationInMinutes := v["rate_limit_duration_in_minutes"].(int)
        rateLimitThreshold := v["rate_limit_threshold"].(int)
        matchConditions := v["match_conditions"].([]interface{})
        action := v["action"].(string)
        transforms := v["transforms"].([]interface{})

        result := frontdoor.CustomRule{
            Action: frontdoor.Action(action),
            MatchConditions: expandArmPolicyMatchCondition(matchConditions),
            Name: utils.String(name),
            Priority: utils.Int(priority),
            RateLimitDurationInMinutes: utils.Int(rateLimitDurationInMinutes),
            RateLimitThreshold: utils.Int(rateLimitThreshold),
            RuleType: frontdoor.RuleType(ruleType),
            Transforms: expandArmPolicy(transforms),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmPolicyUnknown(input []interface{}) *[]frontdoor.Unknown {
    results := make([]frontdoor.Unknown, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        priority := v["priority"].(int)
        version := v["version"].(int)

        result := frontdoor.Unknown{
            Priority: utils.Int(priority),
            Version: utils.Int(version),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmPolicyMatchCondition(input []interface{}) *[]frontdoor.MatchCondition {
    results := make([]frontdoor.MatchCondition, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        matchVariable := v["match_variable"].(string)
        selector := v["selector"].(string)
        operator := v["operator"].(string)
        negateCondition := v["negate_condition"].(bool)
        matchValue := v["match_value"].([]interface{})

        result := frontdoor.MatchCondition{
            MatchValue: utils.ExpandStringSlice(matchValue),
            MatchVariable: frontdoor.MatchCondition(matchVariable),
            NegateCondition: utils.Bool(negateCondition),
            Operator: frontdoor.Operator(operator),
            Selector: utils.String(selector),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmPolicy(input []interface{}) *[]frontdoor. {
    results := make([]frontdoor., 0)
    for _, item := range input {
        v := item.(string)
        result := frontdoor.(v)
        results = append(results, result)
    }
    return &results
}


func flattenArmPolicyCustomRules(input *frontdoor.CustomRules) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["rules"] = flattenArmPolicyCustomRule(input.Rules)

    return []interface{}{result}
}

func flattenArmPolicyManagedRuleSets(input *frontdoor.ManagedRuleSets) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["rule_sets"] = flattenArmPolicyUnknown(input.RuleSets)

    return []interface{}{result}
}

func flattenArmPolicyPolicySettings(input *frontdoor.PolicySettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["enabled_state"] = string(input.EnabledState)
    result["mode"] = string(input.Mode)

    return []interface{}{result}
}

func flattenArmPolicyCustomRule(input *[]frontdoor.CustomRule) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        v["action"] = string(item.Action)
        v["match_conditions"] = flattenArmPolicyMatchCondition(item.MatchConditions)
        if priority := item.Priority; priority != nil {
            v["priority"] = *priority
        }
        if rateLimitDurationInMinutes := item.RateLimitDurationInMinutes; rateLimitDurationInMinutes != nil {
            v["rate_limit_duration_in_minutes"] = *rateLimitDurationInMinutes
        }
        if rateLimitThreshold := item.RateLimitThreshold; rateLimitThreshold != nil {
            v["rate_limit_threshold"] = *rateLimitThreshold
        }
        v["rule_type"] = string(item.RuleType)
        v["transforms"] = flattenArmPolicy(string(item.Transforms))

        results = append(results, v)
    }

    return results
}

func flattenArmPolicyUnknown(input *[]frontdoor.Unknown) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if priority := item.Priority; priority != nil {
            v["priority"] = *priority
        }
        if version := item.Version; version != nil {
            v["version"] = *version
        }

        results = append(results, v)
    }

    return results
}

func flattenArmPolicyMatchCondition(input *[]frontdoor.MatchCondition) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        v["match_value"] = utils.FlattenStringSlice(item.MatchValue)
        v["match_variable"] = string(item.MatchVariable)
        if negateCondition := item.NegateCondition; negateCondition != nil {
            v["negate_condition"] = *negateCondition
        }
        v["operator"] = string(item.Operator)
        if selector := item.Selector; selector != nil {
            v["selector"] = *selector
        }

        results = append(results, v)
    }

    return results
}

func flattenArmPolicy(input *[]frontdoor.) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        result := string(item)
        results = append(results, result)
    }

    return results
}
