// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmContainerGroup() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmContainerGroupCreateUpdate,
        Read: resourceArmContainerGroupRead,
        Update: resourceArmContainerGroupCreateUpdate,
        Delete: resourceArmContainerGroupDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "containers": {
                Type: schema.TypeList,
                Required: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "image": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "resources": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "requests": {
                                        Type: schema.TypeList,
                                        Required: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "cpu": {
                                                    Type: schema.TypeFloat,
                                                    Required: true,
                                                },
                                                "memory_in_gb": {
                                                    Type: schema.TypeFloat,
                                                    Required: true,
                                                },
                                            },
                                        },
                                    },
                                    "limits": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "cpu": {
                                                    Type: schema.TypeFloat,
                                                    Optional: true,
                                                },
                                                "memory_in_gb": {
                                                    Type: schema.TypeFloat,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "command": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Schema{
                                Type: schema.TypeString,
                            },
                        },
                        "environment_variables": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "value": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                },
                            },
                        },
                        "ports": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "port": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                },
                            },
                        },
                        "volume_mounts": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "mount_path": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "read_only": {
                                        Type: schema.TypeBool,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "os_type": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(containerinstance.Windows),
                    string(containerinstance.Linux),
                }, false),
            },

            "image_registry_credentials": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "server": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "username": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "password": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "ip_address": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "ports": {
                            Type: schema.TypeList,
                            Required: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "port": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "protocol": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(containerinstance.TCP),
                                            string(containerinstance.UDP),
                                        }, false),
                                        Default: string(containerinstance.TCP),
                                    },
                                },
                            },
                        },
                        "type": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "ip": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "restart_policy": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(containerinstance.always),
                }, false),
                Default: string(containerinstance.always),
            },

            "volumes": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "azure_file": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "share_name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "storage_account_name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "read_only": {
                                        Type: schema.TypeBool,
                                        Optional: true,
                                    },
                                    "storage_account_key": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmContainerGroupCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).containerGroupsClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Container Group %q (Resource Group %q): %+v", name, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_container_group", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    containers := d.Get("containers").([]interface{})
    imageRegistryCredentials := d.Get("image_registry_credentials").([]interface{})
    ipAddress := d.Get("ip_address").([]interface{})
    osType := d.Get("os_type").(string)
    restartPolicy := d.Get("restart_policy").(string)
    volumes := d.Get("volumes").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    containerGroup := containerinstance.ContainerGroup{
        Location: utils.String(location),
        ContainerGroup_properties: &containerinstance.ContainerGroup_properties{
            Containers: expandArmContainerGroupContainer(containers),
            ImageRegistryCredentials: expandArmContainerGroupImageRegistryCredential(imageRegistryCredentials),
            IPAddress: expandArmContainerGroupIpAddress(ipAddress),
            OsType: containerinstance.OperatingSystemTypes(osType),
            RestartPolicy: containerinstance.ContainerRestartPolicy(restartPolicy),
            Volumes: expandArmContainerGroupVolume(volumes),
        },
        Tags: tags.Expand(t),
    }


    if _, err := client.CreateOrUpdate(ctx, resourceGroup, name, containerGroup); err != nil {
        return fmt.Errorf("Error creating Container Group %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Container Group %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Container Group %q (Resource Group %q) ID", name, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmContainerGroupRead(d, meta)
}

func resourceArmContainerGroupRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).containerGroupsClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["containerGroups"]

    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Container Group %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Container Group %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    d.Set("type", resp.Type)

    return nil
}


func resourceArmContainerGroupDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).containerGroupsClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["containerGroups"]

    if _, err := client.Delete(ctx, resourceGroup, name); err != nil {
        return fmt.Errorf("Error deleting Container Group %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    return nil
}

func expandArmContainerGroupContainer(input []interface{}) *[]containerinstance.Container {
    results := make([]containerinstance.Container, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        image := v["image"].(string)
        command := v["command"].([]interface{})
        ports := v["ports"].([]interface{})
        environmentVariables := v["environment_variables"].([]interface{})
        resources := v["resources"].([]interface{})
        volumeMounts := v["volume_mounts"].([]interface{})

        result := containerinstance.Container{
            Name: utils.String(name),
            ContainerProperties: &containerinstance.ContainerProperties{
                Command: utils.ExpandStringSlice(command),
                EnvironmentVariables: expandArmContainerGroupEnvironmentVariable(environmentVariables),
                Image: utils.String(image),
                Ports: expandArmContainerGroupContainerPort(ports),
                Resources: expandArmContainerGroupResourceRequirements(resources),
                VolumeMounts: expandArmContainerGroupVolumeMount(volumeMounts),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmContainerGroupImageRegistryCredential(input []interface{}) *[]containerinstance.ImageRegistryCredential {
    results := make([]containerinstance.ImageRegistryCredential, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        server := v["server"].(string)
        username := v["username"].(string)
        password := v["password"].(string)

        result := containerinstance.ImageRegistryCredential{
            Password: utils.String(password),
            Server: utils.String(server),
            Username: utils.String(username),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmContainerGroupIpAddress(input []interface{}) *containerinstance.IpAddress {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    ports := v["ports"].([]interface{})
    type := v["type"].(string)
    ip := v["ip"].(string)

    result := containerinstance.IpAddress{
        IP: utils.String(ip),
        Ports: expandArmContainerGroupPort(ports),
        Type: utils.String(type),
    }
    return &result
}

func expandArmContainerGroupVolume(input []interface{}) *[]containerinstance.Volume {
    results := make([]containerinstance.Volume, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        azureFile := v["azure_file"].([]interface{})

        result := containerinstance.Volume{
            AzureFile: expandArmContainerGroupAzureFileVolume(azureFile),
            Name: utils.String(name),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmContainerGroupEnvironmentVariable(input []interface{}) *[]containerinstance.EnvironmentVariable {
    results := make([]containerinstance.EnvironmentVariable, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        value := v["value"].(string)

        result := containerinstance.EnvironmentVariable{
            Name: utils.String(name),
            Value: utils.String(value),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmContainerGroupContainerPort(input []interface{}) *[]containerinstance.ContainerPort {
    results := make([]containerinstance.ContainerPort, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        port := v["port"].(int)

        result := containerinstance.ContainerPort{
            Port: utils.Int32(int32(port)),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmContainerGroupResourceRequirements(input []interface{}) *containerinstance.ResourceRequirements {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    requests := v["requests"].([]interface{})
    limits := v["limits"].([]interface{})

    result := containerinstance.ResourceRequirements{
        Limits: expandArmContainerGroupResourceLimits(limits),
        Requests: expandArmContainerGroupResourceRequests(requests),
    }
    return &result
}

func expandArmContainerGroupVolumeMount(input []interface{}) *[]containerinstance.VolumeMount {
    results := make([]containerinstance.VolumeMount, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        mountPath := v["mount_path"].(string)
        readOnly := v["read_only"].(bool)

        result := containerinstance.VolumeMount{
            MountPath: utils.String(mountPath),
            Name: utils.String(name),
            ReadOnly: utils.Bool(readOnly),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmContainerGroupPort(input []interface{}) *[]containerinstance.Port {
    results := make([]containerinstance.Port, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        protocol := v["protocol"].(string)
        port := v["port"].(int)

        result := containerinstance.Port{
            Port: utils.Int32(int32(port)),
            Protocol: containerinstance.ContainerGroupNetworkProtocol(protocol),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmContainerGroupAzureFileVolume(input []interface{}) *containerinstance.AzureFileVolume {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    shareName := v["share_name"].(string)
    readOnly := v["read_only"].(bool)
    storageAccountName := v["storage_account_name"].(string)
    storageAccountKey := v["storage_account_key"].(string)

    result := containerinstance.AzureFileVolume{
        ReadOnly: utils.Bool(readOnly),
        ShareName: utils.String(shareName),
        StorageAccountKey: utils.String(storageAccountKey),
        StorageAccountName: utils.String(storageAccountName),
    }
    return &result
}

func expandArmContainerGroupResourceLimits(input []interface{}) *containerinstance.ResourceLimits {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    memoryInGb := v["memory_in_gb"].(float64)
    cpu := v["cpu"].(float64)

    result := containerinstance.ResourceLimits{
        CPU: utils.Float(cpu),
        MemoryInGB: utils.Float(memoryInGb),
    }
    return &result
}

func expandArmContainerGroupResourceRequests(input []interface{}) *containerinstance.ResourceRequests {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    memoryInGb := v["memory_in_gb"].(float64)
    cpu := v["cpu"].(float64)

    result := containerinstance.ResourceRequests{
        CPU: utils.Float(cpu),
        MemoryInGB: utils.Float(memoryInGb),
    }
    return &result
}
