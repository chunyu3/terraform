// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmCluster() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmClusterCreate,
        Read: resourceArmClusterRead,
        Update: resourceArmClusterUpdate,
        Delete: resourceArmClusterDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "management_endpoint": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "node_types": {
                Type: schema.TypeList,
                Required: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "client_connection_endpoint_port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "http_gateway_endpoint_port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "is_primary": {
                            Type: schema.TypeBool,
                            Required: true,
                        },
                        "name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "vm_instance_count": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "application_ports": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "end_port": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "start_port": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                },
                            },
                        },
                        "capacities": {
                            Type: schema.TypeMap,
                            Optional: true,
                            Elem: &schema.Schema{Type: schema.TypeString},
                        },
                        "durability_level": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(servicefabric.Bronze),
                                string(servicefabric.Silver),
                                string(servicefabric.Gold),
                            }, false),
                            Default: string(servicefabric.Bronze),
                        },
                        "ephemeral_ports": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "end_port": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "start_port": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                },
                            },
                        },
                        "placement_properties": {
                            Type: schema.TypeMap,
                            Optional: true,
                            Elem: &schema.Schema{Type: schema.TypeString},
                        },
                        "reverse_proxy_endpoint_port": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                    },
                },
            },

            "azure_active_directory": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "client_application": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "cluster_application": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "tenant_id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "certificate": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "thumbprint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "thumbprint_secondary": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "x509store_name": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(servicefabric.AddressBook),
                                string(servicefabric.AuthRoot),
                                string(servicefabric.CertificateAuthority),
                                string(servicefabric.Disallowed),
                                string(servicefabric.My),
                                string(servicefabric.Root),
                                string(servicefabric.TrustedPeople),
                                string(servicefabric.TrustedPublisher),
                            }, false),
                            Default: string(servicefabric.AddressBook),
                        },
                    },
                },
            },

            "client_certificate_common_names": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "certificate_common_name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "certificate_issuer_thumbprint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "is_admin": {
                            Type: schema.TypeBool,
                            Required: true,
                        },
                    },
                },
            },

            "client_certificate_thumbprints": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "certificate_thumbprint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "is_admin": {
                            Type: schema.TypeBool,
                            Required: true,
                        },
                    },
                },
            },

            "cluster_code_version": {
                Type: schema.TypeString,
                Optional: true,
            },

            "diagnostics_storage_account_config": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "blob_endpoint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "protected_account_key_name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "queue_endpoint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "storage_account_name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "table_endpoint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "fabric_settings": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "parameters": {
                            Type: schema.TypeList,
                            Required: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "value": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "reliability_level": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(servicefabric.Bronze),
                    string(servicefabric.Silver),
                    string(servicefabric.Gold),
                    string(servicefabric.Platinum),
                }, false),
                Default: string(servicefabric.Bronze),
            },

            "reverse_proxy_certificate": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "thumbprint": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "thumbprint_secondary": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "x509store_name": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(servicefabric.AddressBook),
                                string(servicefabric.AuthRoot),
                                string(servicefabric.CertificateAuthority),
                                string(servicefabric.Disallowed),
                                string(servicefabric.My),
                                string(servicefabric.Root),
                                string(servicefabric.TrustedPeople),
                                string(servicefabric.TrustedPublisher),
                            }, false),
                            Default: string(servicefabric.AddressBook),
                        },
                    },
                },
            },

            "upgrade_description": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "health_check_retry_timeout": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "health_check_stable_duration": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "health_check_wait_duration": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "health_policy": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "max_percent_unhealthy_applications": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "max_percent_unhealthy_nodes": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "upgrade_domain_timeout": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "upgrade_replica_set_check_timeout": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "upgrade_timeout": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "delta_health_policy": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "max_percent_delta_unhealthy_applications": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "max_percent_delta_unhealthy_nodes": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "max_percent_upgrade_domain_delta_unhealthy_nodes": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                },
                            },
                        },
                        "force_restart": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "override_user_upgrade_policy": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                    },
                },
            },

            "upgrade_mode": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(servicefabric.Automatic),
                    string(servicefabric.Manual),
                }, false),
                Default: string(servicefabric.Automatic),
            },

            "vm_image": {
                Type: schema.TypeString,
                Optional: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmClusterCreate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_cluster", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    azureActiveDirectory := d.Get("azure_active_directory").([]interface{})
    certificate := d.Get("certificate").([]interface{})
    clientCertificateCommonNames := d.Get("client_certificate_common_names").([]interface{})
    clientCertificateThumbprints := d.Get("client_certificate_thumbprints").([]interface{})
    clusterCodeVersion := d.Get("cluster_code_version").(string)
    diagnosticsStorageAccountConfig := d.Get("diagnostics_storage_account_config").([]interface{})
    fabricSettings := d.Get("fabric_settings").([]interface{})
    managementEndpoint := d.Get("management_endpoint").(string)
    nodeTypes := d.Get("node_types").([]interface{})
    reliabilityLevel := d.Get("reliability_level").(string)
    reverseProxyCertificate := d.Get("reverse_proxy_certificate").([]interface{})
    upgradeDescription := d.Get("upgrade_description").([]interface{})
    upgradeMode := d.Get("upgrade_mode").(string)
    vmImage := d.Get("vm_image").(string)
    t := d.Get("tags").(map[string]interface{})

    parameters := servicefabric.Cluster{
        Location: utils.String(location),
        ClusterProperties: &servicefabric.ClusterProperties{
            AzureActiveDirectory: expandArmClusterAzureActiveDirectory(azureActiveDirectory),
            Certificate: expandArmClusterCertificateDescription(certificate),
            ClientCertificateCommonNames: expandArmClusterClientCertificateCommonName(clientCertificateCommonNames),
            ClientCertificateThumbprints: expandArmClusterClientCertificateThumbprint(clientCertificateThumbprints),
            ClusterCodeVersion: utils.String(clusterCodeVersion),
            DiagnosticsStorageAccountConfig: expandArmClusterDiagnosticsStorageAccountConfig(diagnosticsStorageAccountConfig),
            FabricSettings: expandArmClusterSettingsSectionDescription(fabricSettings),
            ManagementEndpoint: utils.String(managementEndpoint),
            NodeTypes: expandArmClusterNodeTypeDescription(nodeTypes),
            ReliabilityLevel: servicefabric.(reliabilityLevel),
            ReverseProxyCertificate: expandArmClusterCertificateDescription(reverseProxyCertificate),
            UpgradeDescription: expandArmClusterClusterUpgradePolicy(upgradeDescription),
            UpgradeMode: servicefabric.(upgradeMode),
            VMImage: utils.String(vmImage),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.Create(ctx, resourceGroup, name, parameters)
    if err != nil {
        return fmt.Errorf("Error creating Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Cluster %q (Resource Group %q) ID", name, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmClusterRead(d, meta)
}

func resourceArmClusterRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.Path["resourcegroups"]
    name := id.Path["clusters"]

    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Cluster %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    d.Set("type", resp.Type)

    return nil
}

func resourceArmClusterUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    azureActiveDirectory := d.Get("azure_active_directory").([]interface{})
    certificate := d.Get("certificate").([]interface{})
    clientCertificateCommonNames := d.Get("client_certificate_common_names").([]interface{})
    clientCertificateThumbprints := d.Get("client_certificate_thumbprints").([]interface{})
    clusterCodeVersion := d.Get("cluster_code_version").(string)
    diagnosticsStorageAccountConfig := d.Get("diagnostics_storage_account_config").([]interface{})
    fabricSettings := d.Get("fabric_settings").([]interface{})
    managementEndpoint := d.Get("management_endpoint").(string)
    nodeTypes := d.Get("node_types").([]interface{})
    reliabilityLevel := d.Get("reliability_level").(string)
    reverseProxyCertificate := d.Get("reverse_proxy_certificate").([]interface{})
    upgradeDescription := d.Get("upgrade_description").([]interface{})
    upgradeMode := d.Get("upgrade_mode").(string)
    vmImage := d.Get("vm_image").(string)
    t := d.Get("tags").(map[string]interface{})

    parameters := servicefabric.Cluster{
        ClusterProperties: &servicefabric.ClusterProperties{
            AzureActiveDirectory: expandArmClusterAzureActiveDirectory(azureActiveDirectory),
            Certificate: expandArmClusterCertificateDescription(certificate),
            ClientCertificateCommonNames: expandArmClusterClientCertificateCommonName(clientCertificateCommonNames),
            ClientCertificateThumbprints: expandArmClusterClientCertificateThumbprint(clientCertificateThumbprints),
            ClusterCodeVersion: utils.String(clusterCodeVersion),
            DiagnosticsStorageAccountConfig: expandArmClusterDiagnosticsStorageAccountConfig(diagnosticsStorageAccountConfig),
            FabricSettings: expandArmClusterSettingsSectionDescription(fabricSettings),
            ManagementEndpoint: utils.String(managementEndpoint),
            NodeTypes: expandArmClusterNodeTypeDescription(nodeTypes),
            ReliabilityLevel: servicefabric.(reliabilityLevel),
            ReverseProxyCertificate: expandArmClusterCertificateDescription(reverseProxyCertificate),
            UpgradeDescription: expandArmClusterClusterUpgradePolicy(upgradeDescription),
            UpgradeMode: servicefabric.(upgradeMode),
            VMImage: utils.String(vmImage),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.Update(ctx, resourceGroup, name, parameters)
    if err != nil {
        return fmt.Errorf("Error updating Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for update of Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    return resourceArmClusterRead(d, meta)
}

func resourceArmClusterDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.Path["resourcegroups"]
    name := id.Path["clusters"]

    if _, err := client.Delete(ctx, resourceGroup, name); err != nil {
        return fmt.Errorf("Error deleting Cluster %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    return nil
}

func expandArmClusterAzureActiveDirectory(input []interface{}) *servicefabric.AzureActiveDirectory {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    tenantId := v["tenant_id"].(string)
    clusterApplication := v["cluster_application"].(string)
    clientApplication := v["client_application"].(string)

    result := servicefabric.AzureActiveDirectory{
        ClientApplication: utils.String(clientApplication),
        ClusterApplication: utils.String(clusterApplication),
        TenantID: utils.String(tenantId),
    }
    return &result
}

func expandArmClusterCertificateDescription(input []interface{}) *servicefabric.CertificateDescription {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    thumbprint := v["thumbprint"].(string)
    thumbprintSecondary := v["thumbprint_secondary"].(string)
    x509storeName := v["x509store_name"].(string)

    result := servicefabric.CertificateDescription{
        Thumbprint: utils.String(thumbprint),
        ThumbprintSecondary: utils.String(thumbprintSecondary),
        X509StoreName: servicefabric.(x509storeName),
    }
    return &result
}

func expandArmClusterClientCertificateCommonName(input []interface{}) *[]servicefabric.ClientCertificateCommonName {
    results := make([]servicefabric.ClientCertificateCommonName, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        isAdmin := v["is_admin"].(bool)
        certificateCommonName := v["certificate_common_name"].(string)
        certificateIssuerThumbprint := v["certificate_issuer_thumbprint"].(string)

        result := servicefabric.ClientCertificateCommonName{
            CertificateCommonName: utils.String(certificateCommonName),
            CertificateIssuerThumbprint: utils.String(certificateIssuerThumbprint),
            IsAdmin: utils.Bool(isAdmin),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterClientCertificateThumbprint(input []interface{}) *[]servicefabric.ClientCertificateThumbprint {
    results := make([]servicefabric.ClientCertificateThumbprint, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        isAdmin := v["is_admin"].(bool)
        certificateThumbprint := v["certificate_thumbprint"].(string)

        result := servicefabric.ClientCertificateThumbprint{
            CertificateThumbprint: utils.String(certificateThumbprint),
            IsAdmin: utils.Bool(isAdmin),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterDiagnosticsStorageAccountConfig(input []interface{}) *servicefabric.DiagnosticsStorageAccountConfig {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    storageAccountName := v["storage_account_name"].(string)
    protectedAccountKeyName := v["protected_account_key_name"].(string)
    blobEndpoint := v["blob_endpoint"].(string)
    queueEndpoint := v["queue_endpoint"].(string)
    tableEndpoint := v["table_endpoint"].(string)

    result := servicefabric.DiagnosticsStorageAccountConfig{
        BlobEndpoint: utils.String(blobEndpoint),
        ProtectedAccountKeyName: utils.String(protectedAccountKeyName),
        QueueEndpoint: utils.String(queueEndpoint),
        StorageAccountName: utils.String(storageAccountName),
        TableEndpoint: utils.String(tableEndpoint),
    }
    return &result
}

func expandArmClusterSettingsSectionDescription(input []interface{}) *[]servicefabric.SettingsSectionDescription {
    results := make([]servicefabric.SettingsSectionDescription, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        parameters := v["parameters"].([]interface{})

        result := servicefabric.SettingsSectionDescription{
            Name: utils.String(name),
            Parameters: expandArmClusterSettingsParameterDescription(parameters),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterNodeTypeDescription(input []interface{}) *[]servicefabric.NodeTypeDescription {
    results := make([]servicefabric.NodeTypeDescription, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        placementProperties := v["placement_properties"].(map[string]interface{})
        capacities := v["capacities"].(map[string]interface{})
        clientConnectionEndpointPort := v["client_connection_endpoint_port"].(int)
        httpGatewayEndpointPort := v["http_gateway_endpoint_port"].(int)
        durabilityLevel := v["durability_level"].(string)
        applicationPorts := v["application_ports"].([]interface{})
        ephemeralPorts := v["ephemeral_ports"].([]interface{})
        isPrimary := v["is_primary"].(bool)
        vmInstanceCount := v["vm_instance_count"].(int)
        reverseProxyEndpointPort := v["reverse_proxy_endpoint_port"].(int)

        result := servicefabric.NodeTypeDescription{
            ApplicationPorts: expandArmClusterEndpointRangeDescription(applicationPorts),
            Capacities: utils.ExpandKeyValuePairs(capacities),
            ClientConnectionEndpointPort: utils.Int(clientConnectionEndpointPort),
            DurabilityLevel: servicefabric.(durabilityLevel),
            EphemeralPorts: expandArmClusterEndpointRangeDescription(ephemeralPorts),
            HTTPGatewayEndpointPort: utils.Int(httpGatewayEndpointPort),
            IsPrimary: utils.Bool(isPrimary),
            Name: utils.String(name),
            PlacementProperties: utils.ExpandKeyValuePairs(placementProperties),
            ReverseProxyEndpointPort: utils.Int(reverseProxyEndpointPort),
            VMInstanceCount: utils.Int(vmInstanceCount),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterClusterUpgradePolicy(input []interface{}) *servicefabric.ClusterUpgradePolicy {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    overrideUserUpgradePolicy := v["override_user_upgrade_policy"].(bool)
    forceRestart := v["force_restart"].(bool)
    upgradeReplicaSetCheckTimeout := v["upgrade_replica_set_check_timeout"].(string)
    healthCheckWaitDuration := v["health_check_wait_duration"].(string)
    healthCheckStableDuration := v["health_check_stable_duration"].(string)
    healthCheckRetryTimeout := v["health_check_retry_timeout"].(string)
    upgradeTimeout := v["upgrade_timeout"].(string)
    upgradeDomainTimeout := v["upgrade_domain_timeout"].(string)
    healthPolicy := v["health_policy"].([]interface{})
    deltaHealthPolicy := v["delta_health_policy"].([]interface{})

    result := servicefabric.ClusterUpgradePolicy{
        DeltaHealthPolicy: expandArmClusterClusterUpgradeDeltaHealthPolicy(deltaHealthPolicy),
        ForceRestart: utils.Bool(forceRestart),
        HealthCheckRetryTimeout: utils.String(healthCheckRetryTimeout),
        HealthCheckStableDuration: utils.String(healthCheckStableDuration),
        HealthCheckWaitDuration: utils.String(healthCheckWaitDuration),
        HealthPolicy: expandArmClusterClusterHealthPolicy(healthPolicy),
        OverrideUserUpgradePolicy: utils.Bool(overrideUserUpgradePolicy),
        UpgradeDomainTimeout: utils.String(upgradeDomainTimeout),
        UpgradeReplicaSetCheckTimeout: utils.String(upgradeReplicaSetCheckTimeout),
        UpgradeTimeout: utils.String(upgradeTimeout),
    }
    return &result
}

func expandArmClusterSettingsParameterDescription(input []interface{}) *[]servicefabric.SettingsParameterDescription {
    results := make([]servicefabric.SettingsParameterDescription, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        value := v["value"].(string)

        result := servicefabric.SettingsParameterDescription{
            Name: utils.String(name),
            Value: utils.String(value),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterEndpointRangeDescription(input []interface{}) *servicefabric.EndpointRangeDescription {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    startPort := v["start_port"].(int)
    endPort := v["end_port"].(int)

    result := servicefabric.EndpointRangeDescription{
        EndPort: utils.Int(endPort),
        StartPort: utils.Int(startPort),
    }
    return &result
}

func expandArmClusterClusterUpgradeDeltaHealthPolicy(input []interface{}) *servicefabric.ClusterUpgradeDeltaHealthPolicy {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    maxPercentDeltaUnhealthyNodes := v["max_percent_delta_unhealthy_nodes"].(int)
    maxPercentUpgradeDomainDeltaUnhealthyNodes := v["max_percent_upgrade_domain_delta_unhealthy_nodes"].(int)
    maxPercentDeltaUnhealthyApplications := v["max_percent_delta_unhealthy_applications"].(int)

    result := servicefabric.ClusterUpgradeDeltaHealthPolicy{
        MaxPercentDeltaUnhealthyApplications: utils.Int(maxPercentDeltaUnhealthyApplications),
        MaxPercentDeltaUnhealthyNodes: utils.Int(maxPercentDeltaUnhealthyNodes),
        MaxPercentUpgradeDomainDeltaUnhealthyNodes: utils.Int(maxPercentUpgradeDomainDeltaUnhealthyNodes),
    }
    return &result
}

func expandArmClusterClusterHealthPolicy(input []interface{}) *servicefabric.ClusterHealthPolicy {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    maxPercentUnhealthyNodes := v["max_percent_unhealthy_nodes"].(int)
    maxPercentUnhealthyApplications := v["max_percent_unhealthy_applications"].(int)

    result := servicefabric.ClusterHealthPolicy{
        MaxPercentUnhealthyApplications: utils.Int(maxPercentUnhealthyApplications),
        MaxPercentUnhealthyNodes: utils.Int(maxPercentUnhealthyNodes),
    }
    return &result
}
