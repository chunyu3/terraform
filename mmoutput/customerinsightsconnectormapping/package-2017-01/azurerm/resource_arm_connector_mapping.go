// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmConnectorMapping() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmConnectorMappingCreateUpdate,
        Read: resourceArmConnectorMappingRead,
        Update: resourceArmConnectorMappingCreateUpdate,
        Delete: resourceArmConnectorMappingDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "connector_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "entity_type": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(customerinsights.None),
                    string(customerinsights.Profile),
                    string(customerinsights.Interaction),
                    string(customerinsights.Relationship),
                }, false),
            },

            "entity_type_name": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "hub_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "mapping_properties": {
                Type: schema.TypeList,
                Required: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "availability": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "interval": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "frequency": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(customerinsights.Minute),
                                            string(customerinsights.Hour),
                                            string(customerinsights.Day),
                                            string(customerinsights.Week),
                                            string(customerinsights.Month),
                                        }, false),
                                        Default: string(customerinsights.Minute),
                                    },
                                },
                            },
                        },
                        "complete_operation": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "completion_operation_type": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(customerinsights.DoNothing),
                                            string(customerinsights.DeleteFile),
                                            string(customerinsights.MoveFile),
                                        }, false),
                                        Default: string(customerinsights.DoNothing),
                                    },
                                    "destination_folder": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "error_management": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "error_management_type": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(customerinsights.RejectAndContinue),
                                            string(customerinsights.StopImport),
                                            string(customerinsights.RejectUntilLimit),
                                        }, false),
                                    },
                                    "error_limit": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "format": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "format_type": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "accept_language": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "array_separator": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "column_delimiter": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "quote_character": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "quote_escape_character": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "structure": {
                            Type: schema.TypeList,
                            Required: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "column_name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "property_name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "custom_format_specifier": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "is_encrypted": {
                                        Type: schema.TypeBool,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "file_filter": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "folder_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "has_header": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                    },
                },
            },

            "connector_type": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(customerinsights.None),
                    string(customerinsights.CRM),
                    string(customerinsights.AzureBlob),
                    string(customerinsights.Salesforce),
                    string(customerinsights.ExchangeOnline),
                    string(customerinsights.Outbound),
                }, false),
                Default: string(customerinsights.None),
            },

            "description": {
                Type: schema.TypeString,
                Optional: true,
            },

            "display_name": {
                Type: schema.TypeString,
                Optional: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },
        },
    }
}

func resourceArmConnectorMappingCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).connectorMappingsClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    connectorName := d.Get("connector_name").(string)
    hubName := d.Get("hub_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, hubName, connectorName, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q): %+v", name, connectorName, hubName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_connector_mapping", *existing.ID)
        }
    }

    connectorType := d.Get("connector_type").(string)
    description := d.Get("description").(string)
    displayName := d.Get("display_name").(string)
    entityType := d.Get("entity_type").(string)
    entityTypeName := d.Get("entity_type_name").(string)
    mappingProperties := d.Get("mapping_properties").([]interface{})

    parameters := customerinsights.ConnectorMappingResourceFormat{
        ConnectorMapping: &customerinsights.ConnectorMapping{
            ConnectorType: customerinsights.ConnectorTypes(connectorType),
            Description: utils.String(description),
            DisplayName: utils.String(displayName),
            EntityType: customerinsights.EntityTypes(entityType),
            EntityTypeName: utils.String(entityTypeName),
            MappingProperties: expandArmConnectorMappingConnectorMappingProperties(mappingProperties),
        },
    }


    if _, err := client.CreateOrUpdate(ctx, resourceGroup, hubName, connectorName, name, parameters); err != nil {
        return fmt.Errorf("Error creating Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q): %+v", name, connectorName, hubName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, hubName, connectorName, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q): %+v", name, connectorName, hubName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q) ID", name, connectorName, hubName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmConnectorMappingRead(d, meta)
}

func resourceArmConnectorMappingRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).connectorMappingsClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    hubName := id.Path["hubs"]
    connectorName := id.Path["connectors"]
    name := id.Path["mappings"]

    resp, err := client.Get(ctx, resourceGroup, hubName, connectorName, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Connector Mapping %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q): %+v", name, connectorName, hubName, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    d.Set("connector_name", connectorName)
    d.Set("hub_name", hubName)
    d.Set("type", resp.Type)

    return nil
}


func resourceArmConnectorMappingDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).connectorMappingsClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    hubName := id.Path["hubs"]
    connectorName := id.Path["connectors"]
    name := id.Path["mappings"]

    if _, err := client.Delete(ctx, resourceGroup, hubName, connectorName, name); err != nil {
        return fmt.Errorf("Error deleting Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q): %+v", name, connectorName, hubName, resourceGroup, err)
    }

    return nil
}

func expandArmConnectorMappingConnectorMappingProperties(input []interface{}) *customerinsights.ConnectorMappingProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    folderPath := v["folder_path"].(string)
    fileFilter := v["file_filter"].(string)
    hasHeader := v["has_header"].(bool)
    errorManagement := v["error_management"].([]interface{})
    format := v["format"].([]interface{})
    availability := v["availability"].([]interface{})
    structure := v["structure"].([]interface{})
    completeOperation := v["complete_operation"].([]interface{})

    result := customerinsights.ConnectorMappingProperties{
        Availability: expandArmConnectorMappingConnectorMappingAvailability(availability),
        CompleteOperation: expandArmConnectorMappingConnectorMappingCompleteOperation(completeOperation),
        ErrorManagement: expandArmConnectorMappingConnectorMappingErrorManagement(errorManagement),
        FileFilter: utils.String(fileFilter),
        FolderPath: utils.String(folderPath),
        Format: expandArmConnectorMappingConnectorMappingFormat(format),
        HasHeader: utils.Bool(hasHeader),
        Structure: expandArmConnectorMappingConnectorMappingStructure(structure),
    }
    return &result
}

func expandArmConnectorMappingConnectorMappingAvailability(input []interface{}) *customerinsights.ConnectorMappingAvailability {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    frequency := v["frequency"].(string)
    interval := v["interval"].(int)

    result := customerinsights.ConnectorMappingAvailability{
        Frequency: customerinsights.FrequencyTypes(frequency),
        Interval: utils.Int(interval),
    }
    return &result
}

func expandArmConnectorMappingConnectorMappingCompleteOperation(input []interface{}) *customerinsights.ConnectorMappingCompleteOperation {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    completionOperationType := v["completion_operation_type"].(string)
    destinationFolder := v["destination_folder"].(string)

    result := customerinsights.ConnectorMappingCompleteOperation{
        CompletionOperationType: customerinsights.CompletionOperationTypes(completionOperationType),
        DestinationFolder: utils.String(destinationFolder),
    }
    return &result
}

func expandArmConnectorMappingConnectorMappingErrorManagement(input []interface{}) *customerinsights.ConnectorMappingErrorManagement {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    errorManagementType := v["error_management_type"].(string)
    errorLimit := v["error_limit"].(int)

    result := customerinsights.ConnectorMappingErrorManagement{
        ErrorLimit: utils.Int(errorLimit),
        ErrorManagementType: customerinsights.ErrorManagementTypes(errorManagementType),
    }
    return &result
}

func expandArmConnectorMappingConnectorMappingFormat(input []interface{}) *customerinsights.ConnectorMappingFormat {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    formatType := v["format_type"].(string)
    columnDelimiter := v["column_delimiter"].(string)
    acceptLanguage := v["accept_language"].(string)
    quoteCharacter := v["quote_character"].(string)
    quoteEscapeCharacter := v["quote_escape_character"].(string)
    arraySeparator := v["array_separator"].(string)

    result := customerinsights.ConnectorMappingFormat{
        AcceptLanguage: utils.String(acceptLanguage),
        ArraySeparator: utils.String(arraySeparator),
        ColumnDelimiter: utils.String(columnDelimiter),
        FormatType: utils.String(formatType),
        QuoteCharacter: utils.String(quoteCharacter),
        QuoteEscapeCharacter: utils.String(quoteEscapeCharacter),
    }
    return &result
}

func expandArmConnectorMappingConnectorMappingStructure(input []interface{}) *[]customerinsights.ConnectorMappingStructure {
    results := make([]customerinsights.ConnectorMappingStructure, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        propertyName := v["property_name"].(string)
        columnName := v["column_name"].(string)
        customFormatSpecifier := v["custom_format_specifier"].(string)
        isEncrypted := v["is_encrypted"].(bool)

        result := customerinsights.ConnectorMappingStructure{
            ColumnName: utils.String(columnName),
            CustomFormatSpecifier: utils.String(customFormatSpecifier),
            IsEncrypted: utils.Bool(isEncrypted),
            PropertyName: utils.String(propertyName),
        }

        results = append(results, result)
    }
    return &results
}
