// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmConnectorMapping() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmConnectorMappingCreateUpdate,
        Read: resourceArmConnectorMappingRead,
        Update: resourceArmConnectorMappingCreateUpdate,
        Delete: resourceArmConnectorMappingDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "connector_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "entity_type": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(customerinsights.None),
                    string(customerinsights.Profile),
                    string(customerinsights.Interaction),
                    string(customerinsights.Relationship),
                }, false),
            },

            "entity_type_name": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "hub_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "mapping_properties": {
                Type: schema.TypeList,
                Required: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "availability": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "interval": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "frequency": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(customerinsights.Minute),
                                            string(customerinsights.Hour),
                                            string(customerinsights.Day),
                                            string(customerinsights.Week),
                                            string(customerinsights.Month),
                                        }, false),
                                        Default: string(customerinsights.Minute),
                                    },
                                },
                            },
                        },
                        "complete_operation": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "completion_operation_type": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(customerinsights.DoNothing),
                                            string(customerinsights.DeleteFile),
                                            string(customerinsights.MoveFile),
                                        }, false),
                                        Default: string(customerinsights.DoNothing),
                                    },
                                    "destination_folder": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "error_management": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "error_management_type": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(customerinsights.RejectAndContinue),
                                            string(customerinsights.StopImport),
                                            string(customerinsights.RejectUntilLimit),
                                        }, false),
                                    },
                                    "error_limit": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "format": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "format_type": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "accept_language": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "array_separator": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "column_delimiter": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "quote_character": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "quote_escape_character": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "structure": {
                            Type: schema.TypeList,
                            Required: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "column_name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "property_name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "custom_format_specifier": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "is_encrypted": {
                                        Type: schema.TypeBool,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "file_filter": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "folder_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "has_header": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                    },
                },
            },

            "connector_type": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(customerinsights.None),
                    string(customerinsights.CRM),
                    string(customerinsights.AzureBlob),
                    string(customerinsights.Salesforce),
                    string(customerinsights.ExchangeOnline),
                    string(customerinsights.Outbound),
                }, false),
                Default: string(customerinsights.None),
            },

            "description": {
                Type: schema.TypeString,
                Optional: true,
            },

            "display_name": {
                Type: schema.TypeString,
                Optional: true,
            },

            "connector_mapping_name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "connector_name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "created": {
                Type: schema.TypeString,
                Computed: true,
            },

            "data_format_id": {
                Type: schema.TypeString,
                Computed: true,
            },

            "last_modified": {
                Type: schema.TypeString,
                Computed: true,
            },

            "next_run_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "run_id": {
                Type: schema.TypeString,
                Computed: true,
            },

            "state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tenant_id": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },
        },
    }
}

func resourceArmConnectorMappingCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).connectorMappingsClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    connectorName := d.Get("connector_name").(string)
    hubName := d.Get("hub_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, hubName, connectorName, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q): %+v", name, connectorName, hubName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_connector_mapping", *existing.ID)
        }
    }

    connectorType := d.Get("connector_type").(string)
    description := d.Get("description").(string)
    displayName := d.Get("display_name").(string)
    entityType := d.Get("entity_type").(string)
    entityTypeName := d.Get("entity_type_name").(string)
    mappingProperties := d.Get("mapping_properties").([]interface{})

    parameters := customerinsights.ConnectorMappingResourceFormat{
        ConnectorMapping: &customerinsights.ConnectorMapping{
            ConnectorType: customerinsights.ConnectorTypes(connectorType),
            Description: utils.String(description),
            DisplayName: utils.String(displayName),
            EntityType: customerinsights.EntityTypes(entityType),
            EntityTypeName: utils.String(entityTypeName),
            MappingProperties: expandArmConnectorMappingConnectorMappingProperties(mappingProperties),
        },
    }


    if _, err := client.CreateOrUpdate(ctx, resourceGroup, hubName, connectorName, name, parameters); err != nil {
        return fmt.Errorf("Error creating Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q): %+v", name, connectorName, hubName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, hubName, connectorName, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q): %+v", name, connectorName, hubName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q) ID", name, connectorName, hubName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmConnectorMappingRead(d, meta)
}

func resourceArmConnectorMappingRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).connectorMappingsClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    hubName := id.Path["hubs"]
    connectorName := id.Path["connectors"]
    name := id.Path["mappings"]

    resp, err := client.Get(ctx, resourceGroup, hubName, connectorName, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Connector Mapping %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q): %+v", name, connectorName, hubName, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if connectorMapping := resp.ConnectorMapping; connectorMapping != nil {
        d.Set("connector_mapping_name", connectorMapping.ConnectorMappingName)
        d.Set("connector_name", connectorMapping.ConnectorName)
        d.Set("connector_type", string(connectorMapping.ConnectorType))
        d.Set("created", (connectorMapping.Created).String())
        d.Set("data_format_id", connectorMapping.DataFormatID)
        d.Set("description", connectorMapping.Description)
        d.Set("display_name", connectorMapping.DisplayName)
        d.Set("entity_type", string(connectorMapping.EntityType))
        d.Set("entity_type_name", connectorMapping.EntityTypeName)
        d.Set("last_modified", (connectorMapping.LastModified).String())
        if err := d.Set("mapping_properties", flattenArmConnectorMappingConnectorMappingProperties(connectorMapping.MappingProperties)); err != nil {
            return fmt.Errorf("Error setting `mapping_properties`: %+v", err)
        }
        d.Set("next_run_time", (connectorMapping.NextRunTime).String())
        d.Set("run_id", connectorMapping.RunID)
        d.Set("state", string(connectorMapping.State))
        d.Set("tenant_id", connectorMapping.TenantID)
    }
    d.Set("connector_name", connectorName)
    d.Set("hub_name", hubName)
    d.Set("type", resp.Type)

    return nil
}


func resourceArmConnectorMappingDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).connectorMappingsClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    hubName := id.Path["hubs"]
    connectorName := id.Path["connectors"]
    name := id.Path["mappings"]

    if _, err := client.Delete(ctx, resourceGroup, hubName, connectorName, name); err != nil {
        return fmt.Errorf("Error deleting Connector Mapping %q (Connector Name %q / Hub Name %q / Resource Group %q): %+v", name, connectorName, hubName, resourceGroup, err)
    }

    return nil
}

func expandArmConnectorMappingConnectorMappingProperties(input []interface{}) *customerinsights.ConnectorMappingProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    folderPath := v["folder_path"].(string)
    fileFilter := v["file_filter"].(string)
    hasHeader := v["has_header"].(bool)
    errorManagement := v["error_management"].([]interface{})
    format := v["format"].([]interface{})
    availability := v["availability"].([]interface{})
    structure := v["structure"].([]interface{})
    completeOperation := v["complete_operation"].([]interface{})

    result := customerinsights.ConnectorMappingProperties{
        Availability: expandArmConnectorMappingConnectorMappingAvailability(availability),
        CompleteOperation: expandArmConnectorMappingConnectorMappingCompleteOperation(completeOperation),
        ErrorManagement: expandArmConnectorMappingConnectorMappingErrorManagement(errorManagement),
        FileFilter: utils.String(fileFilter),
        FolderPath: utils.String(folderPath),
        Format: expandArmConnectorMappingConnectorMappingFormat(format),
        HasHeader: utils.Bool(hasHeader),
        Structure: expandArmConnectorMappingConnectorMappingStructure(structure),
    }
    return &result
}

func expandArmConnectorMappingConnectorMappingAvailability(input []interface{}) *customerinsights.ConnectorMappingAvailability {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    frequency := v["frequency"].(string)
    interval := v["interval"].(int)

    result := customerinsights.ConnectorMappingAvailability{
        Frequency: customerinsights.FrequencyTypes(frequency),
        Interval: utils.Int(interval),
    }
    return &result
}

func expandArmConnectorMappingConnectorMappingCompleteOperation(input []interface{}) *customerinsights.ConnectorMappingCompleteOperation {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    completionOperationType := v["completion_operation_type"].(string)
    destinationFolder := v["destination_folder"].(string)

    result := customerinsights.ConnectorMappingCompleteOperation{
        CompletionOperationType: customerinsights.CompletionOperationTypes(completionOperationType),
        DestinationFolder: utils.String(destinationFolder),
    }
    return &result
}

func expandArmConnectorMappingConnectorMappingErrorManagement(input []interface{}) *customerinsights.ConnectorMappingErrorManagement {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    errorManagementType := v["error_management_type"].(string)
    errorLimit := v["error_limit"].(int)

    result := customerinsights.ConnectorMappingErrorManagement{
        ErrorLimit: utils.Int(errorLimit),
        ErrorManagementType: customerinsights.ErrorManagementTypes(errorManagementType),
    }
    return &result
}

func expandArmConnectorMappingConnectorMappingFormat(input []interface{}) *customerinsights.ConnectorMappingFormat {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    formatType := v["format_type"].(string)
    columnDelimiter := v["column_delimiter"].(string)
    acceptLanguage := v["accept_language"].(string)
    quoteCharacter := v["quote_character"].(string)
    quoteEscapeCharacter := v["quote_escape_character"].(string)
    arraySeparator := v["array_separator"].(string)

    result := customerinsights.ConnectorMappingFormat{
        AcceptLanguage: utils.String(acceptLanguage),
        ArraySeparator: utils.String(arraySeparator),
        ColumnDelimiter: utils.String(columnDelimiter),
        FormatType: utils.String(formatType),
        QuoteCharacter: utils.String(quoteCharacter),
        QuoteEscapeCharacter: utils.String(quoteEscapeCharacter),
    }
    return &result
}

func expandArmConnectorMappingConnectorMappingStructure(input []interface{}) *[]customerinsights.ConnectorMappingStructure {
    results := make([]customerinsights.ConnectorMappingStructure, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        propertyName := v["property_name"].(string)
        columnName := v["column_name"].(string)
        customFormatSpecifier := v["custom_format_specifier"].(string)
        isEncrypted := v["is_encrypted"].(bool)

        result := customerinsights.ConnectorMappingStructure{
            ColumnName: utils.String(columnName),
            CustomFormatSpecifier: utils.String(customFormatSpecifier),
            IsEncrypted: utils.Bool(isEncrypted),
            PropertyName: utils.String(propertyName),
        }

        results = append(results, result)
    }
    return &results
}


func flattenArmConnectorMappingConnectorMappingProperties(input *customerinsights.ConnectorMappingProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["availability"] = flattenArmConnectorMappingConnectorMappingAvailability(input.Availability)
    result["complete_operation"] = flattenArmConnectorMappingConnectorMappingCompleteOperation(input.CompleteOperation)
    result["error_management"] = flattenArmConnectorMappingConnectorMappingErrorManagement(input.ErrorManagement)
    if fileFilter := input.FileFilter; fileFilter != nil {
        result["file_filter"] = *fileFilter
    }
    if folderPath := input.FolderPath; folderPath != nil {
        result["folder_path"] = *folderPath
    }
    result["format"] = flattenArmConnectorMappingConnectorMappingFormat(input.Format)
    if hasHeader := input.HasHeader; hasHeader != nil {
        result["has_header"] = *hasHeader
    }
    result["structure"] = flattenArmConnectorMappingConnectorMappingStructure(input.Structure)

    return []interface{}{result}
}

func flattenArmConnectorMappingConnectorMappingAvailability(input *customerinsights.ConnectorMappingAvailability) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["frequency"] = string(input.Frequency)
    if interval := input.Interval; interval != nil {
        result["interval"] = *interval
    }

    return []interface{}{result}
}

func flattenArmConnectorMappingConnectorMappingCompleteOperation(input *customerinsights.ConnectorMappingCompleteOperation) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["completion_operation_type"] = string(input.CompletionOperationType)
    if destinationFolder := input.DestinationFolder; destinationFolder != nil {
        result["destination_folder"] = *destinationFolder
    }

    return []interface{}{result}
}

func flattenArmConnectorMappingConnectorMappingErrorManagement(input *customerinsights.ConnectorMappingErrorManagement) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if errorLimit := input.ErrorLimit; errorLimit != nil {
        result["error_limit"] = *errorLimit
    }
    result["error_management_type"] = string(input.ErrorManagementType)

    return []interface{}{result}
}

func flattenArmConnectorMappingConnectorMappingFormat(input *customerinsights.ConnectorMappingFormat) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if acceptLanguage := input.AcceptLanguage; acceptLanguage != nil {
        result["accept_language"] = *acceptLanguage
    }
    if arraySeparator := input.ArraySeparator; arraySeparator != nil {
        result["array_separator"] = *arraySeparator
    }
    if columnDelimiter := input.ColumnDelimiter; columnDelimiter != nil {
        result["column_delimiter"] = *columnDelimiter
    }
    if formatType := input.FormatType; formatType != nil {
        result["format_type"] = *formatType
    }
    if quoteCharacter := input.QuoteCharacter; quoteCharacter != nil {
        result["quote_character"] = *quoteCharacter
    }
    if quoteEscapeCharacter := input.QuoteEscapeCharacter; quoteEscapeCharacter != nil {
        result["quote_escape_character"] = *quoteEscapeCharacter
    }

    return []interface{}{result}
}

func flattenArmConnectorMappingConnectorMappingStructure(input *[]customerinsights.ConnectorMappingStructure) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if columnName := item.ColumnName; columnName != nil {
            v["column_name"] = *columnName
        }
        if customFormatSpecifier := item.CustomFormatSpecifier; customFormatSpecifier != nil {
            v["custom_format_specifier"] = *customFormatSpecifier
        }
        if isEncrypted := item.IsEncrypted; isEncrypted != nil {
            v["is_encrypted"] = *isEncrypted
        }
        if propertyName := item.PropertyName; propertyName != nil {
            v["property_name"] = *propertyName
        }

        results = append(results, v)
    }

    return results
}
