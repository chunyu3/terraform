// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmEventHub() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmEventHubCreateUpdate,
        Read: resourceArmEventHubRead,
        Update: resourceArmEventHubCreateUpdate,
        Delete: resourceArmEventHubDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "event_hub_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "namespace_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "capture_description": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "destination": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "archive_name_format": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "blob_container": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "name": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "storage_account_resource_id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "enabled": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "encoding": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(eventhub.Avro),
                                string(eventhub.AvroDeflate),
                            }, false),
                            Default: string(eventhub.Avro),
                        },
                        "interval_in_seconds": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "size_limit_in_bytes": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "skip_empty_archives": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                    },
                },
            },

            "message_retention_in_days": {
                Type: schema.TypeInt,
                Optional: true,
            },

            "partition_count": {
                Type: schema.TypeInt,
                Optional: true,
            },

            "status": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(eventhub.Active),
                    string(eventhub.Disabled),
                    string(eventhub.Restoring),
                    string(eventhub.SendDisabled),
                    string(eventhub.ReceiveDisabled),
                    string(eventhub.Creating),
                    string(eventhub.Deleting),
                    string(eventhub.Renaming),
                    string(eventhub.Unknown),
                }, false),
                Default: string(eventhub.Active),
            },

            "created_at": {
                Type: schema.TypeString,
                Computed: true,
            },

            "partition_ids": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Schema{
                    Type: schema.TypeString,
                },
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "updated_at": {
                Type: schema.TypeString,
                Computed: true,
            },
        },
    }
}

func resourceArmEventHubCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).eventHubsClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    eventHubName := d.Get("event_hub_name").(string)
    namespaceName := d.Get("namespace_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, namespaceName, eventHubName)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Event Hub (Event Hub Name %q / Namespace Name %q / Resource Group %q): %+v", eventHubName, namespaceName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_event_hub", *existing.ID)
        }
    }

    captureDescription := d.Get("capture_description").([]interface{})
    messageRetentionInDays := d.Get("message_retention_in_days").(int)
    partitionCount := d.Get("partition_count").(int)
    status := d.Get("status").(string)

    parameters := eventhub.{
        Eventhub_properties: &eventhub.Eventhub_properties{
            CaptureDescription: expandArmEventHubCaptureDescription(captureDescription),
            MessageRetentionInDays: utils.Int64(int64(messageRetentionInDays)),
            PartitionCount: utils.Int64(int64(partitionCount)),
            Status: eventhub.EntityStatus(status),
        },
    }


    if _, err := client.CreateOrUpdate(ctx, resourceGroup, namespaceName, eventHubName, parameters); err != nil {
        return fmt.Errorf("Error creating Event Hub (Event Hub Name %q / Namespace Name %q / Resource Group %q): %+v", eventHubName, namespaceName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, namespaceName, eventHubName)
    if err != nil {
        return fmt.Errorf("Error retrieving Event Hub (Event Hub Name %q / Namespace Name %q / Resource Group %q): %+v", eventHubName, namespaceName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Event Hub (Event Hub Name %q / Namespace Name %q / Resource Group %q) ID", eventHubName, namespaceName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmEventHubRead(d, meta)
}

func resourceArmEventHubRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).eventHubsClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    namespaceName := id.Path["namespaces"]
    eventHubName := id.Path["eventhubs"]

    resp, err := client.Get(ctx, resourceGroup, namespaceName, eventHubName)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Event Hub %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Event Hub (Event Hub Name %q / Namespace Name %q / Resource Group %q): %+v", eventHubName, namespaceName, resourceGroup, err)
    }


    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if eventhubProperties := resp.Eventhub_properties; eventhubProperties != nil {
        if err := d.Set("capture_description", flattenArmEventHubCaptureDescription(eventhubProperties.CaptureDescription)); err != nil {
            return fmt.Errorf("Error setting `capture_description`: %+v", err)
        }
        d.Set("created_at", (eventhubProperties.CreatedAt).String())
        d.Set("message_retention_in_days", int(*eventhubProperties.MessageRetentionInDays))
        d.Set("partition_count", int(*eventhubProperties.PartitionCount))
        d.Set("partition_ids", utils.FlattenStringSlice(eventhubProperties.PartitionIds))
        d.Set("status", string(eventhubProperties.Status))
        d.Set("updated_at", (eventhubProperties.UpdatedAt).String())
    }
    d.Set("event_hub_name", eventHubName)
    d.Set("namespace_name", namespaceName)
    d.Set("type", resp.Type)

    return nil
}


func resourceArmEventHubDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).eventHubsClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    namespaceName := id.Path["namespaces"]
    eventHubName := id.Path["eventhubs"]

    if _, err := client.Delete(ctx, resourceGroup, namespaceName, eventHubName); err != nil {
        return fmt.Errorf("Error deleting Event Hub (Event Hub Name %q / Namespace Name %q / Resource Group %q): %+v", eventHubName, namespaceName, resourceGroup, err)
    }

    return nil
}

func expandArmEventHubCaptureDescription(input []interface{}) *eventhub.CaptureDescription {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enabled := v["enabled"].(bool)
    encoding := v["encoding"].(string)
    intervalInSeconds := v["interval_in_seconds"].(int)
    sizeLimitInBytes := v["size_limit_in_bytes"].(int)
    destination := v["destination"].([]interface{})
    skipEmptyArchives := v["skip_empty_archives"].(bool)

    result := eventhub.CaptureDescription{
        Destination: expandArmEventHubDestination(destination),
        Enabled: utils.Bool(enabled),
        Encoding: eventhub.EncodingCaptureDescription(encoding),
        IntervalInSeconds: utils.Int32(int32(intervalInSeconds)),
        SizeLimitInBytes: utils.Int32(int32(sizeLimitInBytes)),
        SkipEmptyArchives: utils.Bool(skipEmptyArchives),
    }
    return &result
}

func expandArmEventHubDestination(input []interface{}) *eventhub.Destination {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    name := v["name"].(string)
    storageAccountResourceId := v["storage_account_resource_id"].(string)
    blobContainer := v["blob_container"].(string)
    archiveNameFormat := v["archive_name_format"].(string)

    result := eventhub.Destination{
        Name: utils.String(name),
        Destination_properties: &eventhub.Destination_properties{
            ArchiveNameFormat: utils.String(archiveNameFormat),
            BlobContainer: utils.String(blobContainer),
            StorageAccountResourceID: utils.String(storageAccountResourceId),
        },
    }
    return &result
}


func flattenArmEventHubCaptureDescription(input *eventhub.CaptureDescription) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["destination"] = flattenArmEventHubDestination(input.Destination)
    if enabled := input.Enabled; enabled != nil {
        result["enabled"] = *enabled
    }
    result["encoding"] = string(input.Encoding)
    if intervalInSeconds := input.IntervalInSeconds; intervalInSeconds != nil {
        result["interval_in_seconds"] = int(*intervalInSeconds)
    }
    if sizeLimitInBytes := input.SizeLimitInBytes; sizeLimitInBytes != nil {
        result["size_limit_in_bytes"] = int(*sizeLimitInBytes)
    }
    if skipEmptyArchives := input.SkipEmptyArchives; skipEmptyArchives != nil {
        result["skip_empty_archives"] = *skipEmptyArchives
    }

    return []interface{}{result}
}

func flattenArmEventHubDestination(input *eventhub.Destination) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if name := input.Name; name != nil {
        result["name"] = *name
    }
    if destinationProperties := input.Destination_properties; destinationProperties != nil {
        if archiveNameFormat := destinationProperties.ArchiveNameFormat; archiveNameFormat != nil {
            result["archive_name_format"] = *archiveNameFormat
        }
        if blobContainer := destinationProperties.BlobContainer; blobContainer != nil {
            result["blob_container"] = *blobContainer
        }
        if storageAccountResourceId := destinationProperties.StorageAccountResourceID; storageAccountResourceId != nil {
            result["storage_account_resource_id"] = *storageAccountResourceId
        }
    }

    return []interface{}{result}
}
