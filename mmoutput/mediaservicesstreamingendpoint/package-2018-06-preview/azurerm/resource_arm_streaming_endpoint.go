// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmStreamingEndpoint() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmStreamingEndpointCreate,
        Read: resourceArmStreamingEndpointRead,
        Update: resourceArmStreamingEndpointUpdate,
        Delete: resourceArmStreamingEndpointDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "account_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "access_control": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "akamai": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "akamai_signature_header_authentication_key_list": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "base64key": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "expiration": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                    ValidateFunc: validateRFC3339Date,
                                                },
                                                "identifier": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "ip": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "allow": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "address": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "subnet_prefix_length": {
                                                    Type: schema.TypeInt,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "auto_start": {
                Type: schema.TypeBool,
                Optional: true,
                ForceNew: true,
            },

            "availability_set_name": {
                Type: schema.TypeString,
                Optional: true,
            },

            "cdn_enabled": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "cdn_profile": {
                Type: schema.TypeString,
                Optional: true,
            },

            "cdn_provider": {
                Type: schema.TypeString,
                Optional: true,
            },

            "cross_site_access_policies": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "client_access_policy": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "cross_domain_policy": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "custom_host_names": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Schema{
                    Type: schema.TypeString,
                },
            },

            "description": {
                Type: schema.TypeString,
                Optional: true,
            },

            "max_cache_age": {
                Type: schema.TypeInt,
                Optional: true,
            },

            "scale_unit": {
                Type: schema.TypeInt,
                Optional: true,
                ForceNew: true,
            },

            "scale_units": {
                Type: schema.TypeInt,
                Optional: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmStreamingEndpointCreate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).streamingEndpointsClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    accountName := d.Get("account_name").(string)
    autoStart := d.Get("auto_start").(bool)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, accountName, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Streaming Endpoint %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_streaming_endpoint", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    accessControl := d.Get("access_control").([]interface{})
    availabilitySetName := d.Get("availability_set_name").(string)
    cdnEnabled := d.Get("cdn_enabled").(bool)
    cdnProfile := d.Get("cdn_profile").(string)
    cdnProvider := d.Get("cdn_provider").(string)
    crossSiteAccessPolicies := d.Get("cross_site_access_policies").([]interface{})
    customHostNames := d.Get("custom_host_names").([]interface{})
    description := d.Get("description").(string)
    maxCacheAge := d.Get("max_cache_age").(int)
    scaleUnit := d.Get("scale_unit").(int)
    scaleUnits := d.Get("scale_units").(int)
    t := d.Get("tags").(map[string]interface{})

    parameters := mediaservices.StreamingEntityScaleUnit{
        Location: utils.String(location),
        StreamingEndpointProperties: &mediaservices.StreamingEndpointProperties{
            AccessControl: expandArmStreamingEndpointStreamingEndpointAccessControl(accessControl),
            AvailabilitySetName: utils.String(availabilitySetName),
            CdnEnabled: utils.Bool(cdnEnabled),
            CdnProfile: utils.String(cdnProfile),
            CdnProvider: utils.String(cdnProvider),
            CrossSiteAccessPolicies: expandArmStreamingEndpointCrossSiteAccessPolicies(crossSiteAccessPolicies),
            CustomHostNames: utils.ExpandStringSlice(customHostNames),
            Description: utils.String(description),
            MaxCacheAge: utils.Int64(int64(maxCacheAge)),
            ScaleUnits: utils.Int32(int32(scaleUnits)),
        },
        ScaleUnit: utils.Int32(int32(scaleUnit)),
        Tags: tags.Expand(t),
    }


    future, err := client.Create(ctx, resourceGroup, accountName, name, autoStart, parameters)
    if err != nil {
        return fmt.Errorf("Error creating Streaming Endpoint %q (Auto Start %q / Account Name %q / Resource Group %q): %+v", name, autoStart, accountName, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Streaming Endpoint %q (Auto Start %q / Account Name %q / Resource Group %q): %+v", name, autoStart, accountName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, accountName, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Streaming Endpoint %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Streaming Endpoint %q (Account Name %q / Resource Group %q) ID", name, accountName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmStreamingEndpointRead(d, meta)
}

func resourceArmStreamingEndpointRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).streamingEndpointsClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    accountName := id.Path["mediaservices"]
    name := id.Path["streamingEndpoints"]

    resp, err := client.Get(ctx, resourceGroup, accountName, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Streaming Endpoint %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Streaming Endpoint %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    d.Set("account_name", accountName)
    d.Set("type", resp.Type)

    return nil
}

func resourceArmStreamingEndpointUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).streamingEndpointsClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    accessControl := d.Get("access_control").([]interface{})
    accountName := d.Get("account_name").(string)
    availabilitySetName := d.Get("availability_set_name").(string)
    cdnEnabled := d.Get("cdn_enabled").(bool)
    cdnProfile := d.Get("cdn_profile").(string)
    cdnProvider := d.Get("cdn_provider").(string)
    crossSiteAccessPolicies := d.Get("cross_site_access_policies").([]interface{})
    customHostNames := d.Get("custom_host_names").([]interface{})
    description := d.Get("description").(string)
    maxCacheAge := d.Get("max_cache_age").(int)
    scaleUnit := d.Get("scale_unit").(int)
    scaleUnits := d.Get("scale_units").(int)
    t := d.Get("tags").(map[string]interface{})

    parameters := mediaservices.StreamingEntityScaleUnit{
        StreamingEndpointProperties: &mediaservices.StreamingEndpointProperties{
            AccessControl: expandArmStreamingEndpointStreamingEndpointAccessControl(accessControl),
            AvailabilitySetName: utils.String(availabilitySetName),
            CdnEnabled: utils.Bool(cdnEnabled),
            CdnProfile: utils.String(cdnProfile),
            CdnProvider: utils.String(cdnProvider),
            CrossSiteAccessPolicies: expandArmStreamingEndpointCrossSiteAccessPolicies(crossSiteAccessPolicies),
            CustomHostNames: utils.ExpandStringSlice(customHostNames),
            Description: utils.String(description),
            MaxCacheAge: utils.Int64(int64(maxCacheAge)),
            ScaleUnits: utils.Int32(int32(scaleUnits)),
        },
        ScaleUnit: utils.Int32(int32(scaleUnit)),
        Tags: tags.Expand(t),
    }


    future, err := client.Update(ctx, resourceGroup, accountName, name, parameters)
    if err != nil {
        return fmt.Errorf("Error updating Streaming Endpoint %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for update of Streaming Endpoint %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
    }

    return resourceArmStreamingEndpointRead(d, meta)
}

func resourceArmStreamingEndpointDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).streamingEndpointsClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    accountName := id.Path["mediaservices"]
    name := id.Path["streamingEndpoints"]

    future, err := client.Delete(ctx, resourceGroup, accountName, name)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Streaming Endpoint %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Streaming Endpoint %q (Account Name %q / Resource Group %q): %+v", name, accountName, resourceGroup, err)
        }
    }

    return nil
}

func expandArmStreamingEndpointStreamingEndpointAccessControl(input []interface{}) *mediaservices.StreamingEndpointAccessControl {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    akamai := v["akamai"].([]interface{})
    ip := v["ip"].([]interface{})

    result := mediaservices.StreamingEndpointAccessControl{
        Akamai: expandArmStreamingEndpointAkamaiAccessControl(akamai),
        IP: expandArmStreamingEndpointIPAccessControl(ip),
    }
    return &result
}

func expandArmStreamingEndpointCrossSiteAccessPolicies(input []interface{}) *mediaservices.CrossSiteAccessPolicies {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    clientAccessPolicy := v["client_access_policy"].(string)
    crossDomainPolicy := v["cross_domain_policy"].(string)

    result := mediaservices.CrossSiteAccessPolicies{
        ClientAccessPolicy: utils.String(clientAccessPolicy),
        CrossDomainPolicy: utils.String(crossDomainPolicy),
    }
    return &result
}

func expandArmStreamingEndpointAkamaiAccessControl(input []interface{}) *mediaservices.AkamaiAccessControl {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    akamaiSignatureHeaderAuthenticationKeyList := v["akamai_signature_header_authentication_key_list"].([]interface{})

    result := mediaservices.AkamaiAccessControl{
        AkamaiSignatureHeaderAuthenticationKeyList: expandArmStreamingEndpointAkamaiSignatureHeaderAuthenticationKey(akamaiSignatureHeaderAuthenticationKeyList),
    }
    return &result
}

func expandArmStreamingEndpointIPAccessControl(input []interface{}) *mediaservices.IPAccessControl {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    allow := v["allow"].([]interface{})

    result := mediaservices.IPAccessControl{
        Allow: expandArmStreamingEndpointIPRange(allow),
    }
    return &result
}

func expandArmStreamingEndpointAkamaiSignatureHeaderAuthenticationKey(input []interface{}) *[]mediaservices.AkamaiSignatureHeaderAuthenticationKey {
    results := make([]mediaservices.AkamaiSignatureHeaderAuthenticationKey, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        identifier := v["identifier"].(string)
        base64key := v["base64key"].(string)
        expiration := v["expiration"].(string)

        result := mediaservices.AkamaiSignatureHeaderAuthenticationKey{
            Base64Key: utils.String(base64key),
            Expiration: convertStringToDate(expiration),
            Identifier: utils.String(identifier),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmStreamingEndpointIPRange(input []interface{}) *[]mediaservices.IPRange {
    results := make([]mediaservices.IPRange, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        address := v["address"].(string)
        subnetPrefixLength := v["subnet_prefix_length"].(int)

        result := mediaservices.IPRange{
            Address: utils.String(address),
            Name: utils.String(name),
            SubnetPrefixLength: utils.Int32(int32(subnetPrefixLength)),
        }

        results = append(results, result)
    }
    return &results
}

func convertStringToDate(input interface{}) *date.Time {
  v := input.(string)

  dateTime, err := date.ParseTime(time.RFC3339, v)
  if err != nil {
      log.Printf("[ERROR] Cannot convert an invalid string to RFC3339 date %q: %+v", v, err)
      return nil
  }

  result := date.Time{
      Time: dateTime,
  }
  return &result
}
