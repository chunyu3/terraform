// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmJobStep() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmJobStepCreateUpdate,
        Read: resourceArmJobStepRead,
        Update: resourceArmJobStepCreateUpdate,
        Delete: resourceArmJobStepDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "action": {
                Type: schema.TypeList,
                Required: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "value": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "source": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(sql.Inline),
                            }, false),
                            Default: string(sql.Inline),
                        },
                        "type": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(sql.TSql),
                            }, false),
                            Default: string(sql.TSql),
                        },
                    },
                },
            },

            "credential": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "job_agent_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "job_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "server_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "target_group": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "execution_options": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "initial_retry_interval_seconds": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "maximum_retry_interval_seconds": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "retry_attempts": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "retry_interval_backoff_multiplier": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "timeout_seconds": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                    },
                },
            },

            "output": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "credential": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "database_name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "server_name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "table_name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "resource_group_name": azure.SchemaResourceGroupNameDiffSuppress(),
                        "schema_name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "subscription_id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "type": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(sql.SqlDatabase),
                            }, false),
                            Default: string(sql.SqlDatabase),
                        },
                    },
                },
            },

            "step_id": {
                Type: schema.TypeInt,
                Optional: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },
        },
    }
}

func resourceArmJobStepCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).jobStepsClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    jobAgentName := d.Get("job_agent_name").(string)
    jobName := d.Get("job_name").(string)
    serverName := d.Get("server_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, serverName, jobAgentName, jobName, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Job Step %q (Job Name %q / Job Agent Name %q / Server Name %q / Resource Group %q): %+v", name, jobName, jobAgentName, serverName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_job_step", *existing.ID)
        }
    }

    action := d.Get("action").([]interface{})
    credential := d.Get("credential").(string)
    executionOptions := d.Get("execution_options").([]interface{})
    output := d.Get("output").([]interface{})
    stepId := d.Get("step_id").(int)
    targetGroup := d.Get("target_group").(string)

    parameters := sql.JobStep{
        JobStepProperties: &sql.JobStepProperties{
            Action: expandArmJobStepJobStepAction(action),
            Credential: utils.String(credential),
            ExecutionOptions: expandArmJobStepJobStepExecutionOptions(executionOptions),
            Output: expandArmJobStepJobStepOutput(output),
            StepID: utils.Int32(int32(stepId)),
            TargetGroup: utils.String(targetGroup),
        },
    }


    if _, err := client.CreateOrUpdate(ctx, resourceGroup, serverName, jobAgentName, jobName, name, parameters); err != nil {
        return fmt.Errorf("Error creating Job Step %q (Job Name %q / Job Agent Name %q / Server Name %q / Resource Group %q): %+v", name, jobName, jobAgentName, serverName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, serverName, jobAgentName, jobName, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Job Step %q (Job Name %q / Job Agent Name %q / Server Name %q / Resource Group %q): %+v", name, jobName, jobAgentName, serverName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Job Step %q (Job Name %q / Job Agent Name %q / Server Name %q / Resource Group %q) ID", name, jobName, jobAgentName, serverName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmJobStepRead(d, meta)
}

func resourceArmJobStepRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).jobStepsClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    serverName := id.Path["servers"]
    jobAgentName := id.Path["jobAgents"]
    jobName := id.Path["jobs"]
    name := id.Path["steps"]

    resp, err := client.Get(ctx, resourceGroup, serverName, jobAgentName, jobName, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Job Step %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Job Step %q (Job Name %q / Job Agent Name %q / Server Name %q / Resource Group %q): %+v", name, jobName, jobAgentName, serverName, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if jobStepProperties := resp.JobStepProperties; jobStepProperties != nil {
        if err := d.Set("action", flattenArmJobStepJobStepAction(jobStepProperties.Action)); err != nil {
            return fmt.Errorf("Error setting `action`: %+v", err)
        }
        d.Set("credential", jobStepProperties.Credential)
        if err := d.Set("execution_options", flattenArmJobStepJobStepExecutionOptions(jobStepProperties.ExecutionOptions)); err != nil {
            return fmt.Errorf("Error setting `execution_options`: %+v", err)
        }
        if err := d.Set("output", flattenArmJobStepJobStepOutput(jobStepProperties.Output)); err != nil {
            return fmt.Errorf("Error setting `output`: %+v", err)
        }
        d.Set("step_id", int(*jobStepProperties.StepID))
        d.Set("target_group", jobStepProperties.TargetGroup)
    }
    d.Set("job_agent_name", jobAgentName)
    d.Set("job_name", jobName)
    d.Set("server_name", serverName)
    d.Set("type", resp.Type)

    return nil
}


func resourceArmJobStepDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).jobStepsClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    serverName := id.Path["servers"]
    jobAgentName := id.Path["jobAgents"]
    jobName := id.Path["jobs"]
    name := id.Path["steps"]

    if _, err := client.Delete(ctx, resourceGroup, serverName, jobAgentName, jobName, name); err != nil {
        return fmt.Errorf("Error deleting Job Step %q (Job Name %q / Job Agent Name %q / Server Name %q / Resource Group %q): %+v", name, jobName, jobAgentName, serverName, resourceGroup, err)
    }

    return nil
}

func expandArmJobStepJobStepAction(input []interface{}) *sql.JobStepAction {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    type := v["type"].(string)
    source := v["source"].(string)
    value := v["value"].(string)

    result := sql.JobStepAction{
        Source: sql.JobStepActionSource(source),
        Type: sql.JobStepActionType(type),
        Value: utils.String(value),
    }
    return &result
}

func expandArmJobStepJobStepExecutionOptions(input []interface{}) *sql.JobStepExecutionOptions {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    timeoutSeconds := v["timeout_seconds"].(int)
    retryAttempts := v["retry_attempts"].(int)
    initialRetryIntervalSeconds := v["initial_retry_interval_seconds"].(int)
    maximumRetryIntervalSeconds := v["maximum_retry_interval_seconds"].(int)
    retryIntervalBackoffMultiplier := v["retry_interval_backoff_multiplier"].(int)

    result := sql.JobStepExecutionOptions{
        InitialRetryIntervalSeconds: utils.Int32(int32(initialRetryIntervalSeconds)),
        MaximumRetryIntervalSeconds: utils.Int32(int32(maximumRetryIntervalSeconds)),
        RetryAttempts: utils.Int32(int32(retryAttempts)),
        RetryIntervalBackoffMultiplier: utils.Int(retryIntervalBackoffMultiplier),
        TimeoutSeconds: utils.Int32(int32(timeoutSeconds)),
    }
    return &result
}

func expandArmJobStepJobStepOutput(input []interface{}) *sql.JobStepOutput {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    type := v["type"].(string)
    subscriptionId := v["subscription_id"].(string)
    resourceGroupName := v["resource_group_name"].(string)
    serverName := v["server_name"].(string)
    databaseName := v["database_name"].(string)
    schemaName := v["schema_name"].(string)
    tableName := v["table_name"].(string)
    credential := v["credential"].(string)

    result := sql.JobStepOutput{
        Credential: utils.String(credential),
        DatabaseName: utils.String(databaseName),
        ResourceGroupName: expandArmJobStep(resourceGroupName),
        SchemaName: utils.String(schemaName),
        ServerName: utils.String(serverName),
        SubscriptionID: utils.String(subscriptionId),
        TableName: utils.String(tableName),
        Type: sql.JobStepOutputType(type),
    }
    return &result
}

// TODO: Expand Property 'resourceGroupName' of type Api::Azure::Type::ResourceGroupName is not supported


func flattenArmJobStepJobStepAction(input *sql.JobStepAction) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["source"] = string(input.Source)
    result["type"] = string(input.Type)
    if value := input.Value; value != nil {
        result["value"] = *value
    }

    return []interface{}{result}
}

func flattenArmJobStepJobStepExecutionOptions(input *sql.JobStepExecutionOptions) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if initialRetryIntervalSeconds := input.InitialRetryIntervalSeconds; initialRetryIntervalSeconds != nil {
        result["initial_retry_interval_seconds"] = int(*initialRetryIntervalSeconds)
    }
    if maximumRetryIntervalSeconds := input.MaximumRetryIntervalSeconds; maximumRetryIntervalSeconds != nil {
        result["maximum_retry_interval_seconds"] = int(*maximumRetryIntervalSeconds)
    }
    if retryAttempts := input.RetryAttempts; retryAttempts != nil {
        result["retry_attempts"] = int(*retryAttempts)
    }
    if retryIntervalBackoffMultiplier := input.RetryIntervalBackoffMultiplier; retryIntervalBackoffMultiplier != nil {
        result["retry_interval_backoff_multiplier"] = *retryIntervalBackoffMultiplier
    }
    if timeoutSeconds := input.TimeoutSeconds; timeoutSeconds != nil {
        result["timeout_seconds"] = int(*timeoutSeconds)
    }

    return []interface{}{result}
}

func flattenArmJobStepJobStepOutput(input *sql.JobStepOutput) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if resourceGroupName := input.ResourceGroupName; resourceGroupName != nil {
        result["resource_group_name"] = *resourceGroupName
    }
    if credential := input.Credential; credential != nil {
        result["credential"] = *credential
    }
    if databaseName := input.DatabaseName; databaseName != nil {
        result["database_name"] = *databaseName
    }
    if schemaName := input.SchemaName; schemaName != nil {
        result["schema_name"] = *schemaName
    }
    if serverName := input.ServerName; serverName != nil {
        result["server_name"] = *serverName
    }
    if subscriptionId := input.SubscriptionID; subscriptionId != nil {
        result["subscription_id"] = *subscriptionId
    }
    if tableName := input.TableName; tableName != nil {
        result["table_name"] = *tableName
    }
    result["type"] = string(input.Type)

    return []interface{}{result}
}
