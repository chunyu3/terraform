// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmOperationalizationCluster() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmOperationalizationClusterCreate,
        Read: resourceArmOperationalizationClusterRead,
        Update: resourceArmOperationalizationClusterUpdate,
        Delete: resourceArmOperationalizationClusterDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "cluster_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "cluster_type": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(machinelearningcompute.ACS),
                    string(machinelearningcompute.Local),
                }, false),
            },

            "app_insights": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "resource_id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "container_registry": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "resource_id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "container_service": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "orchestrator_type": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(machinelearningcompute.Kubernetes),
                                string(machinelearningcompute.None),
                            }, false),
                        },
                        "agent_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "agent_vm_size": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(machinelearningcompute.Standard_A0),
                                string(machinelearningcompute.Standard_A1),
                                string(machinelearningcompute.Standard_A2),
                                string(machinelearningcompute.Standard_A3),
                                string(machinelearningcompute.Standard_A4),
                                string(machinelearningcompute.Standard_A5),
                                string(machinelearningcompute.Standard_A6),
                                string(machinelearningcompute.Standard_A7),
                                string(machinelearningcompute.Standard_A8),
                                string(machinelearningcompute.Standard_A9),
                                string(machinelearningcompute.Standard_A10),
                                string(machinelearningcompute.Standard_A11),
                                string(machinelearningcompute.Standard_D1),
                                string(machinelearningcompute.Standard_D2),
                                string(machinelearningcompute.Standard_D3),
                                string(machinelearningcompute.Standard_D4),
                                string(machinelearningcompute.Standard_D11),
                                string(machinelearningcompute.Standard_D12),
                                string(machinelearningcompute.Standard_D13),
                                string(machinelearningcompute.Standard_D14),
                                string(machinelearningcompute.Standard_D1_v2),
                                string(machinelearningcompute.Standard_D2_v2),
                                string(machinelearningcompute.Standard_D3_v2),
                                string(machinelearningcompute.Standard_D4_v2),
                                string(machinelearningcompute.Standard_D5_v2),
                                string(machinelearningcompute.Standard_D11_v2),
                                string(machinelearningcompute.Standard_D12_v2),
                                string(machinelearningcompute.Standard_D13_v2),
                                string(machinelearningcompute.Standard_D14_v2),
                                string(machinelearningcompute.Standard_G1),
                                string(machinelearningcompute.Standard_G2),
                                string(machinelearningcompute.Standard_G3),
                                string(machinelearningcompute.Standard_G4),
                                string(machinelearningcompute.Standard_G5),
                                string(machinelearningcompute.Standard_DS1),
                                string(machinelearningcompute.Standard_DS2),
                                string(machinelearningcompute.Standard_DS3),
                                string(machinelearningcompute.Standard_DS4),
                                string(machinelearningcompute.Standard_DS11),
                                string(machinelearningcompute.Standard_DS12),
                                string(machinelearningcompute.Standard_DS13),
                                string(machinelearningcompute.Standard_DS14),
                                string(machinelearningcompute.Standard_GS1),
                                string(machinelearningcompute.Standard_GS2),
                                string(machinelearningcompute.Standard_GS3),
                                string(machinelearningcompute.Standard_GS4),
                                string(machinelearningcompute.Standard_GS5),
                            }, false),
                            Default: string(machinelearningcompute.Standard_A0),
                        },
                        "master_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "orchestrator_properties": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "service_principal": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "client_id": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "secret": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "system_services": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "system_service_type": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(machinelearningcompute.None),
                                            string(machinelearningcompute.ScoringFrontEnd),
                                            string(machinelearningcompute.BatchFrontEnd),
                                        }, false),
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "description": {
                Type: schema.TypeString,
                Optional: true,
            },

            "global_service_configuration": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "additional_properties": {
                            Type: schema.TypeMap,
                            Optional: true,
                            Elem: &schema.Schema{Type: schema.TypeString},
                        },
                        "auto_scale": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "max_replicas": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "min_replicas": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "refresh_period_in_seconds": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "status": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(machinelearningcompute.Enabled),
                                            string(machinelearningcompute.Disabled),
                                        }, false),
                                        Default: string(machinelearningcompute.Enabled),
                                    },
                                    "target_utilization": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "service_auth": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "primary_auth_key_hash": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "secondary_auth_key_hash": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                },
                            },
                        },
                        "ssl": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "cert": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "cname": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "key": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "status": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(machinelearningcompute.Enabled),
                                            string(machinelearningcompute.Disabled),
                                        }, false),
                                        Default: string(machinelearningcompute.Enabled),
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "storage_account": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "resource_id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "created_on": {
                Type: schema.TypeString,
                Computed: true,
            },

            "modified_on": {
                Type: schema.TypeString,
                Computed: true,
            },

            "provisioning_errors": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "error": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "code": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "message": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "details": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "code": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "message": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmOperationalizationClusterCreate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).operationalizationClustersClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    clusterName := d.Get("cluster_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, clusterName)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Operationalization Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_operationalization_cluster", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    appInsights := d.Get("app_insights").([]interface{})
    clusterType := d.Get("cluster_type").(string)
    containerRegistry := d.Get("container_registry").([]interface{})
    containerService := d.Get("container_service").([]interface{})
    description := d.Get("description").(string)
    globalServiceConfiguration := d.Get("global_service_configuration").([]interface{})
    storageAccount := d.Get("storage_account").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    parameters := machinelearningcompute.OperationalizationCluster{
        Location: utils.String(location),
        OperationalizationClusterProperties: &machinelearningcompute.OperationalizationClusterProperties{
            AppInsights: expandArmOperationalizationClusterAppInsightsProperties(appInsights),
            ClusterType: machinelearningcompute.ClusterType(clusterType),
            ContainerRegistry: expandArmOperationalizationClusterContainerRegistryProperties(containerRegistry),
            ContainerService: expandArmOperationalizationClusterAcsClusterProperties(containerService),
            Description: utils.String(description),
            GlobalServiceConfiguration: expandArmOperationalizationClusterGlobalServiceConfiguration(globalServiceConfiguration),
            StorageAccount: expandArmOperationalizationClusterStorageAccountProperties(storageAccount),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.CreateOrUpdate(ctx, resourceGroup, clusterName, parameters)
    if err != nil {
        return fmt.Errorf("Error creating Operationalization Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Operationalization Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, clusterName)
    if err != nil {
        return fmt.Errorf("Error retrieving Operationalization Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Operationalization Cluster (Cluster Name %q / Resource Group %q) ID", clusterName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmOperationalizationClusterRead(d, meta)
}

func resourceArmOperationalizationClusterRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).operationalizationClustersClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    clusterName := id.Path["operationalizationClusters"]

    resp, err := client.Get(ctx, resourceGroup, clusterName)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Operationalization Cluster %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Operationalization Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }


    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    if operationalizationClusterProperties := resp.OperationalizationClusterProperties; operationalizationClusterProperties != nil {
        if err := d.Set("app_insights", flattenArmOperationalizationClusterAppInsightsProperties(operationalizationClusterProperties.AppInsights)); err != nil {
            return fmt.Errorf("Error setting `app_insights`: %+v", err)
        }
        d.Set("cluster_type", string(operationalizationClusterProperties.ClusterType))
        if err := d.Set("container_registry", flattenArmOperationalizationClusterContainerRegistryProperties(operationalizationClusterProperties.ContainerRegistry)); err != nil {
            return fmt.Errorf("Error setting `container_registry`: %+v", err)
        }
        if err := d.Set("container_service", flattenArmOperationalizationClusterAcsClusterProperties(operationalizationClusterProperties.ContainerService)); err != nil {
            return fmt.Errorf("Error setting `container_service`: %+v", err)
        }
        d.Set("created_on", (operationalizationClusterProperties.CreatedOn).String())
        d.Set("description", operationalizationClusterProperties.Description)
        if err := d.Set("global_service_configuration", flattenArmOperationalizationClusterGlobalServiceConfiguration(operationalizationClusterProperties.GlobalServiceConfiguration)); err != nil {
            return fmt.Errorf("Error setting `global_service_configuration`: %+v", err)
        }
        d.Set("modified_on", (operationalizationClusterProperties.ModifiedOn).String())
        if err := d.Set("provisioning_errors", flattenArmOperationalizationClusterErrorResponseWrapper(operationalizationClusterProperties.ProvisioningErrors)); err != nil {
            return fmt.Errorf("Error setting `provisioning_errors`: %+v", err)
        }
        d.Set("provisioning_state", string(operationalizationClusterProperties.ProvisioningState))
        if err := d.Set("storage_account", flattenArmOperationalizationClusterStorageAccountProperties(operationalizationClusterProperties.StorageAccount)); err != nil {
            return fmt.Errorf("Error setting `storage_account`: %+v", err)
        }
    }
    d.Set("cluster_name", clusterName)
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}

func resourceArmOperationalizationClusterUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).operationalizationClustersClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    appInsights := d.Get("app_insights").([]interface{})
    clusterName := d.Get("cluster_name").(string)
    clusterType := d.Get("cluster_type").(string)
    containerRegistry := d.Get("container_registry").([]interface{})
    containerService := d.Get("container_service").([]interface{})
    description := d.Get("description").(string)
    globalServiceConfiguration := d.Get("global_service_configuration").([]interface{})
    storageAccount := d.Get("storage_account").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    parameters := machinelearningcompute.OperationalizationCluster{
        Location: utils.String(location),
        OperationalizationClusterProperties: &machinelearningcompute.OperationalizationClusterProperties{
            AppInsights: expandArmOperationalizationClusterAppInsightsProperties(appInsights),
            ClusterType: machinelearningcompute.ClusterType(clusterType),
            ContainerRegistry: expandArmOperationalizationClusterContainerRegistryProperties(containerRegistry),
            ContainerService: expandArmOperationalizationClusterAcsClusterProperties(containerService),
            Description: utils.String(description),
            GlobalServiceConfiguration: expandArmOperationalizationClusterGlobalServiceConfiguration(globalServiceConfiguration),
            StorageAccount: expandArmOperationalizationClusterStorageAccountProperties(storageAccount),
        },
        Tags: tags.Expand(t),
    }


    if _, err := client.Update(ctx, resourceGroup, clusterName, parameters); err != nil {
        return fmt.Errorf("Error updating Operationalization Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }

    return resourceArmOperationalizationClusterRead(d, meta)
}

func resourceArmOperationalizationClusterDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).operationalizationClustersClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    clusterName := id.Path["operationalizationClusters"]

    future, err := client.Delete(ctx, resourceGroup, clusterName)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Operationalization Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Operationalization Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
        }
    }

    return nil
}

func expandArmOperationalizationClusterAppInsightsProperties(input []interface{}) *machinelearningcompute.AppInsightsProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    resourceId := v["resource_id"].(string)

    result := machinelearningcompute.AppInsightsProperties{
        ResourceID: utils.String(resourceId),
    }
    return &result
}

func expandArmOperationalizationClusterContainerRegistryProperties(input []interface{}) *machinelearningcompute.ContainerRegistryProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    resourceId := v["resource_id"].(string)

    result := machinelearningcompute.ContainerRegistryProperties{
        ResourceID: utils.String(resourceId),
    }
    return &result
}

func expandArmOperationalizationClusterAcsClusterProperties(input []interface{}) *machinelearningcompute.AcsClusterProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    orchestratorType := v["orchestrator_type"].(string)
    orchestratorProperties := v["orchestrator_properties"].([]interface{})
    systemServices := v["system_services"].([]interface{})
    masterCount := v["master_count"].(int)
    agentCount := v["agent_count"].(int)
    agentVmSize := v["agent_vm_size"].(string)

    result := machinelearningcompute.AcsClusterProperties{
        AgentCount: utils.Int(agentCount),
        AgentVmSize: machinelearningcompute.AgentVMSizeTypes(agentVmSize),
        MasterCount: utils.Int(masterCount),
        OrchestratorProperties: expandArmOperationalizationClusterKubernetes(orchestratorProperties),
        OrchestratorType: machinelearningcompute.OrchestratorType(orchestratorType),
        SystemServices: expandArmOperationalizationClusterSystemService(systemServices),
    }
    return &result
}

func expandArmOperationalizationClusterGlobalServiceConfiguration(input []interface{}) *machinelearningcompute.GlobalServiceConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    additionalProperties := v["additional_properties"].(map[string]interface{})
    etag := v["etag"].(string)
    ssl := v["ssl"].([]interface{})
    serviceAuth := v["service_auth"].([]interface{})
    autoScale := v["auto_scale"].([]interface{})

    result := machinelearningcompute.GlobalServiceConfiguration{
        AdditionalProperties: utils.ExpandKeyValuePairs(additionalProperties),
        AutoScale: expandArmOperationalizationClusterAutoScaleConfiguration(autoScale),
        Etag: utils.String(etag),
        ServiceAuth: expandArmOperationalizationClusterServiceAuthConfiguration(serviceAuth),
        Ssl: expandArmOperationalizationClusterSslConfiguration(ssl),
    }
    return &result
}

func expandArmOperationalizationClusterStorageAccountProperties(input []interface{}) *machinelearningcompute.StorageAccountProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    resourceId := v["resource_id"].(string)

    result := machinelearningcompute.StorageAccountProperties{
        ResourceID: utils.String(resourceId),
    }
    return &result
}

func expandArmOperationalizationClusterKubernetes(input []interface{}) *machinelearningcompute.Kubernetes {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    servicePrincipal := v["service_principal"].([]interface{})

    result := machinelearningcompute.Kubernetes{
        ServicePrincipal: expandArmOperationalizationClusterServicePrincipalProperties(servicePrincipal),
    }
    return &result
}

func expandArmOperationalizationClusterSystemService(input []interface{}) *[]machinelearningcompute.SystemService {
    results := make([]machinelearningcompute.SystemService, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        systemServiceType := v["system_service_type"].(string)

        result := machinelearningcompute.SystemService{
            SystemServiceType: machinelearningcompute.SystemServiceType(systemServiceType),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmOperationalizationClusterAutoScaleConfiguration(input []interface{}) *machinelearningcompute.AutoScaleConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    status := v["status"].(string)
    minReplicas := v["min_replicas"].(int)
    maxReplicas := v["max_replicas"].(int)
    targetUtilization := v["target_utilization"].(int)
    refreshPeriodInSeconds := v["refresh_period_in_seconds"].(int)

    result := machinelearningcompute.AutoScaleConfiguration{
        MaxReplicas: utils.Int(maxReplicas),
        MinReplicas: utils.Int(minReplicas),
        RefreshPeriodInSeconds: utils.Int(refreshPeriodInSeconds),
        Status: machinelearningcompute.Status(status),
        TargetUtilization: utils.Int(targetUtilization),
    }
    return &result
}

func expandArmOperationalizationClusterServiceAuthConfiguration(input []interface{}) *machinelearningcompute.ServiceAuthConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    primaryAuthKeyHash := v["primary_auth_key_hash"].(string)
    secondaryAuthKeyHash := v["secondary_auth_key_hash"].(string)

    result := machinelearningcompute.ServiceAuthConfiguration{
        PrimaryAuthKeyHash: utils.String(primaryAuthKeyHash),
        SecondaryAuthKeyHash: utils.String(secondaryAuthKeyHash),
    }
    return &result
}

func expandArmOperationalizationClusterSslConfiguration(input []interface{}) *machinelearningcompute.SslConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    status := v["status"].(string)
    cert := v["cert"].(string)
    key := v["key"].(string)
    cname := v["cname"].(string)

    result := machinelearningcompute.SslConfiguration{
        Cert: utils.String(cert),
        Cname: utils.String(cname),
        Key: utils.String(key),
        Status: machinelearningcompute.Status(status),
    }
    return &result
}

func expandArmOperationalizationClusterServicePrincipalProperties(input []interface{}) *machinelearningcompute.ServicePrincipalProperties {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    clientId := v["client_id"].(string)
    secret := v["secret"].(string)

    result := machinelearningcompute.ServicePrincipalProperties{
        ClientID: utils.String(clientId),
        Secret: utils.String(secret),
    }
    return &result
}


func flattenArmOperationalizationClusterAppInsightsProperties(input *machinelearningcompute.AppInsightsProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if resourceId := input.ResourceID; resourceId != nil {
        result["resource_id"] = *resourceId
    }

    return []interface{}{result}
}

func flattenArmOperationalizationClusterContainerRegistryProperties(input *machinelearningcompute.ContainerRegistryProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if resourceId := input.ResourceID; resourceId != nil {
        result["resource_id"] = *resourceId
    }

    return []interface{}{result}
}

func flattenArmOperationalizationClusterAcsClusterProperties(input *machinelearningcompute.AcsClusterProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if agentCount := input.AgentCount; agentCount != nil {
        result["agent_count"] = *agentCount
    }
    result["agent_vm_size"] = string(input.AgentVmSize)
    if masterCount := input.MasterCount; masterCount != nil {
        result["master_count"] = *masterCount
    }
    result["orchestrator_properties"] = flattenArmOperationalizationClusterKubernetes(input.OrchestratorProperties)
    result["orchestrator_type"] = string(input.OrchestratorType)
    result["system_services"] = flattenArmOperationalizationClusterSystemService(input.SystemServices)

    return []interface{}{result}
}

func flattenArmOperationalizationClusterGlobalServiceConfiguration(input *machinelearningcompute.GlobalServiceConfiguration) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["additional_properties"] = utils.FlattenKeyValuePairs(input.AdditionalProperties)
    result["auto_scale"] = flattenArmOperationalizationClusterAutoScaleConfiguration(input.AutoScale)
    if etag := input.Etag; etag != nil {
        result["etag"] = *etag
    }
    result["service_auth"] = flattenArmOperationalizationClusterServiceAuthConfiguration(input.ServiceAuth)
    result["ssl"] = flattenArmOperationalizationClusterSslConfiguration(input.Ssl)

    return []interface{}{result}
}

func flattenArmOperationalizationClusterErrorResponseWrapper(input *[]machinelearningcompute.ErrorResponseWrapper) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})


        results = append(results, v)
    }

    return results
}

func flattenArmOperationalizationClusterStorageAccountProperties(input *machinelearningcompute.StorageAccountProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if resourceId := input.ResourceID; resourceId != nil {
        result["resource_id"] = *resourceId
    }

    return []interface{}{result}
}

func flattenArmOperationalizationClusterKubernetes(input *machinelearningcompute.Kubernetes) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["service_principal"] = flattenArmOperationalizationClusterServicePrincipalProperties(input.ServicePrincipal)

    return []interface{}{result}
}

func flattenArmOperationalizationClusterSystemService(input *[]machinelearningcompute.SystemService) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        v["system_service_type"] = string(item.SystemServiceType)

        results = append(results, v)
    }

    return results
}

func flattenArmOperationalizationClusterAutoScaleConfiguration(input *machinelearningcompute.AutoScaleConfiguration) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if maxReplicas := input.MaxReplicas; maxReplicas != nil {
        result["max_replicas"] = *maxReplicas
    }
    if minReplicas := input.MinReplicas; minReplicas != nil {
        result["min_replicas"] = *minReplicas
    }
    if refreshPeriodInSeconds := input.RefreshPeriodInSeconds; refreshPeriodInSeconds != nil {
        result["refresh_period_in_seconds"] = *refreshPeriodInSeconds
    }
    result["status"] = string(input.Status)
    if targetUtilization := input.TargetUtilization; targetUtilization != nil {
        result["target_utilization"] = *targetUtilization
    }

    return []interface{}{result}
}

func flattenArmOperationalizationClusterServiceAuthConfiguration(input *machinelearningcompute.ServiceAuthConfiguration) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if primaryAuthKeyHash := input.PrimaryAuthKeyHash; primaryAuthKeyHash != nil {
        result["primary_auth_key_hash"] = *primaryAuthKeyHash
    }
    if secondaryAuthKeyHash := input.SecondaryAuthKeyHash; secondaryAuthKeyHash != nil {
        result["secondary_auth_key_hash"] = *secondaryAuthKeyHash
    }

    return []interface{}{result}
}

func flattenArmOperationalizationClusterSslConfiguration(input *machinelearningcompute.SslConfiguration) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if cert := input.Cert; cert != nil {
        result["cert"] = *cert
    }
    if cname := input.Cname; cname != nil {
        result["cname"] = *cname
    }
    if key := input.Key; key != nil {
        result["key"] = *key
    }
    result["status"] = string(input.Status)

    return []interface{}{result}
}

func flattenArmOperationalizationClusterServicePrincipalProperties(input *machinelearningcompute.ServicePrincipalProperties) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if clientId := input.ClientID; clientId != nil {
        result["client_id"] = *clientId
    }
    if secret := input.Secret; secret != nil {
        result["secret"] = *secret
    }

    return []interface{}{result}
}
