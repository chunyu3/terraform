// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmCluster() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmClusterCreate,
        Read: resourceArmClusterRead,
        Update: resourceArmClusterUpdate,
        Delete: resourceArmClusterDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "cluster_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "user_account_settings": {
                Type: schema.TypeList,
                Required: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "admin_user_name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "admin_user_password": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "admin_user_ssh_public_key": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "vm_size": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "node_setup": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "mount_volumes": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "azure_blob_file_systems": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "account_name": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "container_name": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "relative_mount_path": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "mount_options": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "azure_file_shares": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "account_name": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "azure_file_url": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "relative_mount_path": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "directory_mode": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "file_mode": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "file_servers": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "relative_mount_path": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "mount_options": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "source_directory": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "unmanaged_file_systems": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "mount_command": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "relative_mount_path": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        "setup_task": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "command_line": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "std_out_err_path_prefix": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "environment_variables": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "name": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "value": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "run_elevated": {
                                        Type: schema.TypeBool,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "scale_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "auto_scale": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "maximum_node_count": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "minimum_node_count": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "initial_node_count": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "manual": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "target_node_count": {
                                        Type: schema.TypeInt,
                                        Required: true,
                                    },
                                    "node_deallocation_option": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(batchaisdk.requeue),
                                            string(batchaisdk.terminate),
                                            string(batchaisdk.waitforjobcompletion),
                                            string(batchaisdk.unknown),
                                        }, false),
                                        Default: string(batchaisdk.requeue),
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "subnet": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "id": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "virtual_machine_configuration": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "image_reference": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "offer": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "publisher": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "sku": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "version": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "vm_priority": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(batchaisdk.dedicated),
                    string(batchaisdk.lowpriority),
                }, false),
                Default: string(batchaisdk.dedicated),
            },

            "allocation_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "allocation_state_transition_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "creation_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "current_node_count": {
                Type: schema.TypeInt,
                Computed: true,
            },

            "errors": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "code": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "details": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "name": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "value": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "message": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "node_state_counts": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "idle_node_count": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "leaving_node_count": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "preparing_node_count": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "running_node_count": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "unusable_node_count": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                    },
                },
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "provisioning_state_transition_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmClusterCreate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    clusterName := d.Get("cluster_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, clusterName)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_cluster", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    nodeSetup := d.Get("node_setup").([]interface{})
    scaleSettings := d.Get("scale_settings").([]interface{})
    subnet := d.Get("subnet").([]interface{})
    userAccountSettings := d.Get("user_account_settings").([]interface{})
    virtualMachineConfiguration := d.Get("virtual_machine_configuration").([]interface{})
    vmPriority := d.Get("vm_priority").(string)
    vmSize := d.Get("vm_size").(string)
    t := d.Get("tags").(map[string]interface{})

    parameters := batchaisdk.ClusterCreateParameters{
        Location: utils.String(location),
        ClusterBaseProperties: &batchaisdk.ClusterBaseProperties{
            NodeSetup: expandArmClusterNodeSetup(nodeSetup),
            ScaleSettings: expandArmClusterScaleSettings(scaleSettings),
            Subnet: expandArmClusterResourceId(subnet),
            UserAccountSettings: expandArmClusterUserAccountSettings(userAccountSettings),
            VirtualMachineConfiguration: expandArmClusterVirtualMachineConfiguration(virtualMachineConfiguration),
            VmPriority: batchaisdk.VmPriority(vmPriority),
            VmSize: utils.String(vmSize),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.Create(ctx, resourceGroup, clusterName, parameters)
    if err != nil {
        return fmt.Errorf("Error creating Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, clusterName)
    if err != nil {
        return fmt.Errorf("Error retrieving Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Cluster (Cluster Name %q / Resource Group %q) ID", clusterName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmClusterRead(d, meta)
}

func resourceArmClusterRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    clusterName := id.Path["clusters"]

    resp, err := client.Get(ctx, resourceGroup, clusterName)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Cluster %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }


    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    if clusterBaseProperties := resp.ClusterBaseProperties; clusterBaseProperties != nil {
        d.Set("allocation_state", string(clusterBaseProperties.AllocationState))
        d.Set("allocation_state_transition_time", (clusterBaseProperties.AllocationStateTransitionTime).String())
        d.Set("creation_time", (clusterBaseProperties.CreationTime).String())
        d.Set("current_node_count", int(*clusterBaseProperties.CurrentNodeCount))
        if err := d.Set("errors", flattenArmClusterBatchAIError(clusterBaseProperties.Errors)); err != nil {
            return fmt.Errorf("Error setting `errors`: %+v", err)
        }
        if err := d.Set("node_setup", flattenArmClusterNodeSetup(clusterBaseProperties.NodeSetup)); err != nil {
            return fmt.Errorf("Error setting `node_setup`: %+v", err)
        }
        if err := d.Set("node_state_counts", flattenArmClusterNodeStateCounts(clusterBaseProperties.NodeStateCounts)); err != nil {
            return fmt.Errorf("Error setting `node_state_counts`: %+v", err)
        }
        d.Set("provisioning_state", string(clusterBaseProperties.ProvisioningState))
        d.Set("provisioning_state_transition_time", (clusterBaseProperties.ProvisioningStateTransitionTime).String())
        if err := d.Set("scale_settings", flattenArmClusterScaleSettings(clusterBaseProperties.ScaleSettings)); err != nil {
            return fmt.Errorf("Error setting `scale_settings`: %+v", err)
        }
        if err := d.Set("subnet", flattenArmClusterResourceId(clusterBaseProperties.Subnet)); err != nil {
            return fmt.Errorf("Error setting `subnet`: %+v", err)
        }
        if err := d.Set("user_account_settings", flattenArmClusterUserAccountSettings(clusterBaseProperties.UserAccountSettings)); err != nil {
            return fmt.Errorf("Error setting `user_account_settings`: %+v", err)
        }
        if err := d.Set("virtual_machine_configuration", flattenArmClusterVirtualMachineConfiguration(clusterBaseProperties.VirtualMachineConfiguration)); err != nil {
            return fmt.Errorf("Error setting `virtual_machine_configuration`: %+v", err)
        }
        d.Set("vm_priority", string(clusterBaseProperties.VmPriority))
        d.Set("vm_size", clusterBaseProperties.VmSize)
    }
    d.Set("cluster_name", clusterName)
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}

func resourceArmClusterUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    clusterName := d.Get("cluster_name").(string)
    nodeSetup := d.Get("node_setup").([]interface{})
    scaleSettings := d.Get("scale_settings").([]interface{})
    subnet := d.Get("subnet").([]interface{})
    userAccountSettings := d.Get("user_account_settings").([]interface{})
    virtualMachineConfiguration := d.Get("virtual_machine_configuration").([]interface{})
    vmPriority := d.Get("vm_priority").(string)
    vmSize := d.Get("vm_size").(string)
    t := d.Get("tags").(map[string]interface{})

    parameters := batchaisdk.ClusterCreateParameters{
        Location: utils.String(location),
        ClusterBaseProperties: &batchaisdk.ClusterBaseProperties{
            NodeSetup: expandArmClusterNodeSetup(nodeSetup),
            ScaleSettings: expandArmClusterScaleSettings(scaleSettings),
            Subnet: expandArmClusterResourceId(subnet),
            UserAccountSettings: expandArmClusterUserAccountSettings(userAccountSettings),
            VirtualMachineConfiguration: expandArmClusterVirtualMachineConfiguration(virtualMachineConfiguration),
            VmPriority: batchaisdk.VmPriority(vmPriority),
            VmSize: utils.String(vmSize),
        },
        Tags: tags.Expand(t),
    }


    if _, err := client.Update(ctx, resourceGroup, clusterName, parameters); err != nil {
        return fmt.Errorf("Error updating Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }

    return resourceArmClusterRead(d, meta)
}

func resourceArmClusterDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).clustersClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    clusterName := id.Path["clusters"]

    future, err := client.Delete(ctx, resourceGroup, clusterName)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Cluster (Cluster Name %q / Resource Group %q): %+v", clusterName, resourceGroup, err)
        }
    }

    return nil
}

func expandArmClusterNodeSetup(input []interface{}) *batchaisdk.NodeSetup {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    setupTask := v["setup_task"].([]interface{})
    mountVolumes := v["mount_volumes"].([]interface{})

    result := batchaisdk.NodeSetup{
        MountVolumes: expandArmClusterMountVolumes(mountVolumes),
        SetupTask: expandArmClusterSetupTask(setupTask),
    }
    return &result
}

func expandArmClusterScaleSettings(input []interface{}) *batchaisdk.ScaleSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    manual := v["manual"].([]interface{})
    autoScale := v["auto_scale"].([]interface{})

    result := batchaisdk.ScaleSettings{
        AutoScale: expandArmClusterAutoScaleSettings(autoScale),
        Manual: expandArmClusterManualScaleSettings(manual),
    }
    return &result
}

func expandArmClusterResourceId(input []interface{}) *batchaisdk.ResourceId {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    id := v["id"].(string)

    result := batchaisdk.ResourceId{
        ID: utils.String(id),
    }
    return &result
}

func expandArmClusterUserAccountSettings(input []interface{}) *batchaisdk.UserAccountSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    adminUserName := v["admin_user_name"].(string)
    adminUserSshPublicKey := v["admin_user_ssh_public_key"].(string)
    adminUserPassword := v["admin_user_password"].(string)

    result := batchaisdk.UserAccountSettings{
        AdminUserName: utils.String(adminUserName),
        AdminUserPassword: utils.String(adminUserPassword),
        AdminUserSshPublicKey: utils.String(adminUserSshPublicKey),
    }
    return &result
}

func expandArmClusterVirtualMachineConfiguration(input []interface{}) *batchaisdk.VirtualMachineConfiguration {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    imageReference := v["image_reference"].([]interface{})

    result := batchaisdk.VirtualMachineConfiguration{
        ImageReference: expandArmClusterImageReference(imageReference),
    }
    return &result
}

func expandArmClusterMountVolumes(input []interface{}) *batchaisdk.MountVolumes {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    azureFileShares := v["azure_file_shares"].([]interface{})
    azureBlobFileSystems := v["azure_blob_file_systems"].([]interface{})
    fileServers := v["file_servers"].([]interface{})
    unmanagedFileSystems := v["unmanaged_file_systems"].([]interface{})

    result := batchaisdk.MountVolumes{
        AzureBlobFileSystems: expandArmClusterAzureBlobFileSystemReference(azureBlobFileSystems),
        AzureFileShares: expandArmClusterAzureFileShareReference(azureFileShares),
        FileServers: expandArmClusterFileServerReference(fileServers),
        UnmanagedFileSystems: expandArmClusterUnmanagedFileSystemReference(unmanagedFileSystems),
    }
    return &result
}

func expandArmClusterSetupTask(input []interface{}) *batchaisdk.SetupTask {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    commandLine := v["command_line"].(string)
    environmentVariables := v["environment_variables"].([]interface{})
    runElevated := v["run_elevated"].(bool)
    stdOutErrPathPrefix := v["std_out_err_path_prefix"].(string)

    result := batchaisdk.SetupTask{
        CommandLine: utils.String(commandLine),
        EnvironmentVariables: expandArmClusterEnvironmentSetting(environmentVariables),
        RunElevated: utils.Bool(runElevated),
        StdOutErrPathPrefix: utils.String(stdOutErrPathPrefix),
    }
    return &result
}

func expandArmClusterAutoScaleSettings(input []interface{}) *batchaisdk.AutoScaleSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    minimumNodeCount := v["minimum_node_count"].(int)
    maximumNodeCount := v["maximum_node_count"].(int)
    initialNodeCount := v["initial_node_count"].(int)

    result := batchaisdk.AutoScaleSettings{
        InitialNodeCount: utils.Int32(int32(initialNodeCount)),
        MaximumNodeCount: utils.Int32(int32(maximumNodeCount)),
        MinimumNodeCount: utils.Int32(int32(minimumNodeCount)),
    }
    return &result
}

func expandArmClusterManualScaleSettings(input []interface{}) *batchaisdk.ManualScaleSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    targetNodeCount := v["target_node_count"].(int)
    nodeDeallocationOption := v["node_deallocation_option"].(string)

    result := batchaisdk.ManualScaleSettings{
        NodeDeallocationOption: batchaisdk.DeallocationOption(nodeDeallocationOption),
        TargetNodeCount: utils.Int32(int32(targetNodeCount)),
    }
    return &result
}

func expandArmClusterImageReference(input []interface{}) *batchaisdk.ImageReference {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    publisher := v["publisher"].(string)
    offer := v["offer"].(string)
    sku := v["sku"].(string)
    version := v["version"].(string)

    result := batchaisdk.ImageReference{
        Offer: utils.String(offer),
        Publisher: utils.String(publisher),
        Sku: utils.String(sku),
        Version: utils.String(version),
    }
    return &result
}

func expandArmClusterAzureBlobFileSystemReference(input []interface{}) *[]batchaisdk.AzureBlobFileSystemReference {
    results := make([]batchaisdk.AzureBlobFileSystemReference, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        accountName := v["account_name"].(string)
        containerName := v["container_name"].(string)
        relativeMountPath := v["relative_mount_path"].(string)
        mountOptions := v["mount_options"].(string)

        result := batchaisdk.AzureBlobFileSystemReference{
            AccountName: utils.String(accountName),
            ContainerName: utils.String(containerName),
            MountOptions: utils.String(mountOptions),
            RelativeMountPath: utils.String(relativeMountPath),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterAzureFileShareReference(input []interface{}) *[]batchaisdk.AzureFileShareReference {
    results := make([]batchaisdk.AzureFileShareReference, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        accountName := v["account_name"].(string)
        azureFileUrl := v["azure_file_url"].(string)
        relativeMountPath := v["relative_mount_path"].(string)
        fileMode := v["file_mode"].(string)
        directoryMode := v["directory_mode"].(string)

        result := batchaisdk.AzureFileShareReference{
            AccountName: utils.String(accountName),
            AzureFileURL: utils.String(azureFileUrl),
            DirectoryMode: utils.String(directoryMode),
            FileMode: utils.String(fileMode),
            RelativeMountPath: utils.String(relativeMountPath),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterFileServerReference(input []interface{}) *[]batchaisdk.FileServerReference {
    results := make([]batchaisdk.FileServerReference, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        sourceDirectory := v["source_directory"].(string)
        relativeMountPath := v["relative_mount_path"].(string)
        mountOptions := v["mount_options"].(string)

        result := batchaisdk.FileServerReference{
            MountOptions: utils.String(mountOptions),
            RelativeMountPath: utils.String(relativeMountPath),
            SourceDirectory: utils.String(sourceDirectory),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterUnmanagedFileSystemReference(input []interface{}) *[]batchaisdk.UnmanagedFileSystemReference {
    results := make([]batchaisdk.UnmanagedFileSystemReference, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        mountCommand := v["mount_command"].(string)
        relativeMountPath := v["relative_mount_path"].(string)

        result := batchaisdk.UnmanagedFileSystemReference{
            MountCommand: utils.String(mountCommand),
            RelativeMountPath: utils.String(relativeMountPath),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmClusterEnvironmentSetting(input []interface{}) *[]batchaisdk.EnvironmentSetting {
    results := make([]batchaisdk.EnvironmentSetting, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        value := v["value"].(string)

        result := batchaisdk.EnvironmentSetting{
            Name: utils.String(name),
            Value: utils.String(value),
        }

        results = append(results, result)
    }
    return &results
}


func flattenArmClusterBatchAIError(input *[]batchaisdk.BatchAIError) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})


        results = append(results, v)
    }

    return results
}

func flattenArmClusterNodeSetup(input *batchaisdk.NodeSetup) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["mount_volumes"] = flattenArmClusterMountVolumes(input.MountVolumes)
    result["setup_task"] = flattenArmClusterSetupTask(input.SetupTask)

    return []interface{}{result}
}

func flattenArmClusterNodeStateCounts(input *batchaisdk.NodeStateCounts) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})


    return []interface{}{result}
}

func flattenArmClusterScaleSettings(input *batchaisdk.ScaleSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["auto_scale"] = flattenArmClusterAutoScaleSettings(input.AutoScale)
    result["manual"] = flattenArmClusterManualScaleSettings(input.Manual)

    return []interface{}{result}
}

func flattenArmClusterResourceId(input *batchaisdk.ResourceId) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if id := input.ID; id != nil {
        result["id"] = *id
    }

    return []interface{}{result}
}

func flattenArmClusterUserAccountSettings(input *batchaisdk.UserAccountSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if adminUserName := input.AdminUserName; adminUserName != nil {
        result["admin_user_name"] = *adminUserName
    }
    if adminUserPassword := input.AdminUserPassword; adminUserPassword != nil {
        result["admin_user_password"] = *adminUserPassword
    }
    if adminUserSshPublicKey := input.AdminUserSshPublicKey; adminUserSshPublicKey != nil {
        result["admin_user_ssh_public_key"] = *adminUserSshPublicKey
    }

    return []interface{}{result}
}

func flattenArmClusterVirtualMachineConfiguration(input *batchaisdk.VirtualMachineConfiguration) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["image_reference"] = flattenArmClusterImageReference(input.ImageReference)

    return []interface{}{result}
}

func flattenArmClusterMountVolumes(input *batchaisdk.MountVolumes) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["azure_blob_file_systems"] = flattenArmClusterAzureBlobFileSystemReference(input.AzureBlobFileSystems)
    result["azure_file_shares"] = flattenArmClusterAzureFileShareReference(input.AzureFileShares)
    result["file_servers"] = flattenArmClusterFileServerReference(input.FileServers)
    result["unmanaged_file_systems"] = flattenArmClusterUnmanagedFileSystemReference(input.UnmanagedFileSystems)

    return []interface{}{result}
}

func flattenArmClusterSetupTask(input *batchaisdk.SetupTask) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLine := input.CommandLine; commandLine != nil {
        result["command_line"] = *commandLine
    }
    result["environment_variables"] = flattenArmClusterEnvironmentSetting(input.EnvironmentVariables)
    if runElevated := input.RunElevated; runElevated != nil {
        result["run_elevated"] = *runElevated
    }
    if stdOutErrPathPrefix := input.StdOutErrPathPrefix; stdOutErrPathPrefix != nil {
        result["std_out_err_path_prefix"] = *stdOutErrPathPrefix
    }

    return []interface{}{result}
}

func flattenArmClusterAutoScaleSettings(input *batchaisdk.AutoScaleSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if initialNodeCount := input.InitialNodeCount; initialNodeCount != nil {
        result["initial_node_count"] = int(*initialNodeCount)
    }
    if maximumNodeCount := input.MaximumNodeCount; maximumNodeCount != nil {
        result["maximum_node_count"] = int(*maximumNodeCount)
    }
    if minimumNodeCount := input.MinimumNodeCount; minimumNodeCount != nil {
        result["minimum_node_count"] = int(*minimumNodeCount)
    }

    return []interface{}{result}
}

func flattenArmClusterManualScaleSettings(input *batchaisdk.ManualScaleSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["node_deallocation_option"] = string(input.NodeDeallocationOption)
    if targetNodeCount := input.TargetNodeCount; targetNodeCount != nil {
        result["target_node_count"] = int(*targetNodeCount)
    }

    return []interface{}{result}
}

func flattenArmClusterImageReference(input *batchaisdk.ImageReference) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if offer := input.Offer; offer != nil {
        result["offer"] = *offer
    }
    if publisher := input.Publisher; publisher != nil {
        result["publisher"] = *publisher
    }
    if sku := input.Sku; sku != nil {
        result["sku"] = *sku
    }
    if version := input.Version; version != nil {
        result["version"] = *version
    }

    return []interface{}{result}
}

func flattenArmClusterAzureBlobFileSystemReference(input *[]batchaisdk.AzureBlobFileSystemReference) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if accountName := item.AccountName; accountName != nil {
            v["account_name"] = *accountName
        }
        if containerName := item.ContainerName; containerName != nil {
            v["container_name"] = *containerName
        }
        if mountOptions := item.MountOptions; mountOptions != nil {
            v["mount_options"] = *mountOptions
        }
        if relativeMountPath := item.RelativeMountPath; relativeMountPath != nil {
            v["relative_mount_path"] = *relativeMountPath
        }

        results = append(results, v)
    }

    return results
}

func flattenArmClusterAzureFileShareReference(input *[]batchaisdk.AzureFileShareReference) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if accountName := item.AccountName; accountName != nil {
            v["account_name"] = *accountName
        }
        if azureFileUrl := item.AzureFileURL; azureFileUrl != nil {
            v["azure_file_url"] = *azureFileUrl
        }
        if directoryMode := item.DirectoryMode; directoryMode != nil {
            v["directory_mode"] = *directoryMode
        }
        if fileMode := item.FileMode; fileMode != nil {
            v["file_mode"] = *fileMode
        }
        if relativeMountPath := item.RelativeMountPath; relativeMountPath != nil {
            v["relative_mount_path"] = *relativeMountPath
        }

        results = append(results, v)
    }

    return results
}

func flattenArmClusterFileServerReference(input *[]batchaisdk.FileServerReference) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if mountOptions := item.MountOptions; mountOptions != nil {
            v["mount_options"] = *mountOptions
        }
        if relativeMountPath := item.RelativeMountPath; relativeMountPath != nil {
            v["relative_mount_path"] = *relativeMountPath
        }
        if sourceDirectory := item.SourceDirectory; sourceDirectory != nil {
            v["source_directory"] = *sourceDirectory
        }

        results = append(results, v)
    }

    return results
}

func flattenArmClusterUnmanagedFileSystemReference(input *[]batchaisdk.UnmanagedFileSystemReference) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if mountCommand := item.MountCommand; mountCommand != nil {
            v["mount_command"] = *mountCommand
        }
        if relativeMountPath := item.RelativeMountPath; relativeMountPath != nil {
            v["relative_mount_path"] = *relativeMountPath
        }

        results = append(results, v)
    }

    return results
}

func flattenArmClusterEnvironmentSetting(input *[]batchaisdk.EnvironmentSetting) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if value := item.Value; value != nil {
            v["value"] = *value
        }

        results = append(results, v)
    }

    return results
}
