// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmLoadBalancer() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmLoadBalancerCreateUpdate,
        Read: resourceArmLoadBalancerRead,
        Update: resourceArmLoadBalancerCreateUpdate,
        Delete: resourceArmLoadBalancerDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "backend_address_pools": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "backend_ipconfigurations": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "load_balancing_rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "outbound_nat_rule": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "etag": {
                Type: schema.TypeString,
                Optional: true,
                ForceNew: true,
            },

            "frontend_ipconfigurations": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "inbound_nat_pools": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "inbound_nat_rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "load_balancing_rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "outbound_nat_rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "private_ip_address": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "private_ipallocation_method": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Static),
                                string(network.Dynamic),
                            }, false),
                            Default: string(network.Static),
                        },
                        "public_ip_address": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "subnet": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "inbound_nat_pools": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "backend_port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "frontend_port_range_end": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "frontend_port_range_start": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "protocol": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Udp),
                                string(network.Tcp),
                            }, false),
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "frontend_ipconfiguration": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "inbound_nat_rules": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "enable_floating_ip": {
                            Type: schema.TypeBool,
                            Required: true,
                        },
                        "frontend_port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "protocol": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Udp),
                                string(network.Tcp),
                            }, false),
                        },
                        "backend_ipconfiguration": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "backend_port": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "frontend_ipconfiguration": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "idle_timeout_in_minutes": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "load_balancing_rules": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "backend_address_pool": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "enable_floating_ip": {
                            Type: schema.TypeBool,
                            Required: true,
                        },
                        "frontend_port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "protocol": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Udp),
                                string(network.Tcp),
                            }, false),
                        },
                        "backend_port": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "frontend_ipconfiguration": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "idle_timeout_in_minutes": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "load_distribution": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Default),
                                string(network.SourceIP),
                                string(network.SourceIPProtocol),
                            }, false),
                            Default: string(network.Default),
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "probe": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "outbound_nat_rules": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "allocated_outbound_ports": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "backend_address_pool": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "frontend_ipconfigurations": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "probes": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "protocol": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Http),
                                string(network.Tcp),
                            }, false),
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "interval_in_seconds": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "load_balancing_rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "number_of_probes": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "request_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "resource_guid": {
                Type: schema.TypeString,
                Optional: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmLoadBalancerCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).loadBalancersClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Load Balancer %q (Resource Group %q): %+v", name, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_load_balancer", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    backendAddressPools := d.Get("backend_address_pools").([]interface{})
    etag := d.Get("etag").(string)
    frontendIpconfigurations := d.Get("frontend_ipconfigurations").([]interface{})
    inboundNatPools := d.Get("inbound_nat_pools").([]interface{})
    inboundNatRules := d.Get("inbound_nat_rules").([]interface{})
    loadBalancingRules := d.Get("load_balancing_rules").([]interface{})
    outboundNatRules := d.Get("outbound_nat_rules").([]interface{})
    probes := d.Get("probes").([]interface{})
    resourceGuid := d.Get("resource_guid").(string)
    t := d.Get("tags").(map[string]interface{})

    parameters := network.LoadBalancer{
        Etag: utils.String(etag),
        Location: utils.String(location),
        LoadBalancerPropertiesFormat: &network.LoadBalancerPropertiesFormat{
            BackendAddressPools: expandArmLoadBalancerBackendAddressPool(backendAddressPools),
            FrontendIPConfigurations: expandArmLoadBalancerFrontendIpConfiguration(frontendIpconfigurations),
            InboundNatPools: expandArmLoadBalancerInboundNatPool(inboundNatPools),
            InboundNatRules: expandArmLoadBalancerInboundNatRule(inboundNatRules),
            LoadBalancingRules: expandArmLoadBalancerLoadBalancingRule(loadBalancingRules),
            OutboundNatRules: expandArmLoadBalancerOutboundNatRule(outboundNatRules),
            Probes: expandArmLoadBalancerProbe(probes),
            ResourceGUID: utils.String(resourceGuid),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.CreateOrUpdate(ctx, resourceGroup, name, parameters)
    if err != nil {
        return fmt.Errorf("Error creating Load Balancer %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Load Balancer %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        return fmt.Errorf("Error retrieving Load Balancer %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Load Balancer %q (Resource Group %q) ID", name, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmLoadBalancerRead(d, meta)
}

func resourceArmLoadBalancerRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).loadBalancersClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["loadBalancers"]

    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Load Balancer %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Load Balancer %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    d.Set("name", name)
    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    d.Set("type", resp.Type)

    return nil
}


func resourceArmLoadBalancerDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).loadBalancersClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["loadBalancers"]

    future, err := client.Delete(ctx, resourceGroup, name)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Load Balancer %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Load Balancer %q (Resource Group %q): %+v", name, resourceGroup, err)
        }
    }

    return nil
}

func expandArmLoadBalancerBackendAddressPool(input []interface{}) *[]network.BackendAddressPool {
    results := make([]network.BackendAddressPool, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        backendIpconfigurations := v["backend_ipconfigurations"].([]interface{})
        loadBalancingRules := v["load_balancing_rules"].([]interface{})
        outboundNatRule := v["outbound_nat_rule"].([]interface{})
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.BackendAddressPool{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            BackendAddressPoolPropertiesFormat: &network.BackendAddressPoolPropertiesFormat{
                BackendIPConfigurations: expandArmLoadBalancerSubResource(backendIpconfigurations),
                LoadBalancingRules: expandArmLoadBalancerSubResource(loadBalancingRules),
                OutboundNatRule: expandArmLoadBalancerSubResource(outboundNatRule),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerFrontendIpConfiguration(input []interface{}) *[]network.FrontendIpConfiguration {
    results := make([]network.FrontendIpConfiguration, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        privateIpAddress := v["private_ip_address"].(string)
        privateIpallocationMethod := v["private_ipallocation_method"].(string)
        subnet := v["subnet"].([]interface{})
        publicIpAddress := v["public_ip_address"].([]interface{})
        inboundNatRules := v["inbound_nat_rules"].([]interface{})
        inboundNatPools := v["inbound_nat_pools"].([]interface{})
        outboundNatRules := v["outbound_nat_rules"].([]interface{})
        loadBalancingRules := v["load_balancing_rules"].([]interface{})
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.FrontendIpConfiguration{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            FrontendIpConfigurationPropertiesFormat: &network.FrontendIpConfigurationPropertiesFormat{
                InboundNatPools: expandArmLoadBalancerSubResource(inboundNatPools),
                InboundNatRules: expandArmLoadBalancerSubResource(inboundNatRules),
                LoadBalancingRules: expandArmLoadBalancerSubResource(loadBalancingRules),
                OutboundNatRules: expandArmLoadBalancerSubResource(outboundNatRules),
                PrivateIPAddress: utils.String(privateIpAddress),
                PrivateIPAllocationMethod: network.IpAllocationMethod(privateIpallocationMethod),
                PublicIPAddress: expandArmLoadBalancerSubResource(publicIpAddress),
                Subnet: expandArmLoadBalancerSubResource(subnet),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerInboundNatPool(input []interface{}) *[]network.InboundNatPool {
    results := make([]network.InboundNatPool, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        frontendIpconfiguration := v["frontend_ipconfiguration"].([]interface{})
        protocol := v["protocol"].(string)
        frontendPortRangeStart := v["frontend_port_range_start"].(int)
        frontendPortRangeEnd := v["frontend_port_range_end"].(int)
        backendPort := v["backend_port"].(int)
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.InboundNatPool{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            InboundNatPoolPropertiesFormat: &network.InboundNatPoolPropertiesFormat{
                BackendPort: utils.Int32(int32(backendPort)),
                FrontendIPConfiguration: expandArmLoadBalancerSubResource(frontendIpconfiguration),
                FrontendPortRangeEnd: utils.Int32(int32(frontendPortRangeEnd)),
                FrontendPortRangeStart: utils.Int32(int32(frontendPortRangeStart)),
                Protocol: network.TransportProtocol(protocol),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerInboundNatRule(input []interface{}) *[]network.InboundNatRule {
    results := make([]network.InboundNatRule, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        frontendIpconfiguration := v["frontend_ipconfiguration"].([]interface{})
        backendIpconfiguration := v["backend_ipconfiguration"].([]interface{})
        protocol := v["protocol"].(string)
        frontendPort := v["frontend_port"].(int)
        backendPort := v["backend_port"].(int)
        idleTimeoutInMinutes := v["idle_timeout_in_minutes"].(int)
        enableFloatingIp := v["enable_floating_ip"].(bool)
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.InboundNatRule{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            InboundNatRulePropertiesFormat: &network.InboundNatRulePropertiesFormat{
                BackendIPConfiguration: expandArmLoadBalancerSubResource(backendIpconfiguration),
                BackendPort: utils.Int32(int32(backendPort)),
                EnableFloatingIP: utils.Bool(enableFloatingIp),
                FrontendIPConfiguration: expandArmLoadBalancerSubResource(frontendIpconfiguration),
                FrontendPort: utils.Int32(int32(frontendPort)),
                IdleTimeoutInMinutes: utils.Int32(int32(idleTimeoutInMinutes)),
                Protocol: network.TransportProtocol(protocol),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerLoadBalancingRule(input []interface{}) *[]network.LoadBalancingRule {
    results := make([]network.LoadBalancingRule, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        frontendIpconfiguration := v["frontend_ipconfiguration"].([]interface{})
        backendAddressPool := v["backend_address_pool"].([]interface{})
        probe := v["probe"].([]interface{})
        protocol := v["protocol"].(string)
        loadDistribution := v["load_distribution"].(string)
        frontendPort := v["frontend_port"].(int)
        backendPort := v["backend_port"].(int)
        idleTimeoutInMinutes := v["idle_timeout_in_minutes"].(int)
        enableFloatingIp := v["enable_floating_ip"].(bool)
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.LoadBalancingRule{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            LoadBalancingRulePropertiesFormat: &network.LoadBalancingRulePropertiesFormat{
                BackendAddressPool: expandArmLoadBalancerSubResource(backendAddressPool),
                BackendPort: utils.Int32(int32(backendPort)),
                EnableFloatingIP: utils.Bool(enableFloatingIp),
                FrontendIPConfiguration: expandArmLoadBalancerSubResource(frontendIpconfiguration),
                FrontendPort: utils.Int32(int32(frontendPort)),
                IdleTimeoutInMinutes: utils.Int32(int32(idleTimeoutInMinutes)),
                LoadDistribution: network.LoadDistribution(loadDistribution),
                Probe: expandArmLoadBalancerSubResource(probe),
                Protocol: network.TransportProtocol(protocol),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerOutboundNatRule(input []interface{}) *[]network.OutboundNatRule {
    results := make([]network.OutboundNatRule, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        allocatedOutboundPorts := v["allocated_outbound_ports"].(int)
        frontendIpconfigurations := v["frontend_ipconfigurations"].([]interface{})
        backendAddressPool := v["backend_address_pool"].([]interface{})
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.OutboundNatRule{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            OutboundNatRulePropertiesFormat: &network.OutboundNatRulePropertiesFormat{
                AllocatedOutboundPorts: utils.Int32(int32(allocatedOutboundPorts)),
                BackendAddressPool: expandArmLoadBalancerSubResource(backendAddressPool),
                FrontendIPConfigurations: expandArmLoadBalancerSubResource(frontendIpconfigurations),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerProbe(input []interface{}) *[]network.Probe {
    results := make([]network.Probe, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        loadBalancingRules := v["load_balancing_rules"].([]interface{})
        protocol := v["protocol"].(string)
        port := v["port"].(int)
        intervalInSeconds := v["interval_in_seconds"].(int)
        numberOfProbes := v["number_of_probes"].(int)
        requestPath := v["request_path"].(string)
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.Probe{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            ProbePropertiesFormat: &network.ProbePropertiesFormat{
                IntervalInSeconds: utils.Int32(int32(intervalInSeconds)),
                LoadBalancingRules: expandArmLoadBalancerSubResource(loadBalancingRules),
                NumberOfProbes: utils.Int32(int32(numberOfProbes)),
                Port: utils.Int32(int32(port)),
                Protocol: network.ProbeProtocol(protocol),
                RequestPath: utils.String(requestPath),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerSubResource(input []interface{}) *[]network.SubResource {
    results := make([]network.SubResource, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)

        result := network.SubResource{
            ID: utils.String(id),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerSubResource(input []interface{}) *network.SubResource {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    id := v["id"].(string)

    result := network.SubResource{
        ID: utils.String(id),
    }
    return &result
}
