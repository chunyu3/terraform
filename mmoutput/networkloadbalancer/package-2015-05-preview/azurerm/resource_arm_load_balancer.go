// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmLoadBalancer() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmLoadBalancerCreateUpdate,
        Read: resourceArmLoadBalancerRead,
        Update: resourceArmLoadBalancerCreateUpdate,
        Delete: resourceArmLoadBalancerDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "load_balancer_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "backend_address_pools": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "backend_ipconfigurations": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "load_balancing_rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "outbound_nat_rule": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "etag": {
                Type: schema.TypeString,
                Optional: true,
                ForceNew: true,
            },

            "frontend_ipconfigurations": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "inbound_nat_pools": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "inbound_nat_rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "load_balancing_rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "outbound_nat_rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "private_ip_address": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "private_ipallocation_method": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Static),
                                string(network.Dynamic),
                            }, false),
                            Default: string(network.Static),
                        },
                        "public_ip_address": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "subnet": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "inbound_nat_pools": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "backend_port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "frontend_port_range_end": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "frontend_port_range_start": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "protocol": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Udp),
                                string(network.Tcp),
                            }, false),
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "frontend_ipconfiguration": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "inbound_nat_rules": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "enable_floating_ip": {
                            Type: schema.TypeBool,
                            Required: true,
                        },
                        "frontend_port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "protocol": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Udp),
                                string(network.Tcp),
                            }, false),
                        },
                        "backend_ipconfiguration": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "backend_port": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "frontend_ipconfiguration": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "idle_timeout_in_minutes": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "load_balancing_rules": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "backend_address_pool": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "enable_floating_ip": {
                            Type: schema.TypeBool,
                            Required: true,
                        },
                        "frontend_port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "protocol": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Udp),
                                string(network.Tcp),
                            }, false),
                        },
                        "backend_port": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "frontend_ipconfiguration": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "idle_timeout_in_minutes": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "load_distribution": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Default),
                                string(network.SourceIP),
                                string(network.SourceIPProtocol),
                            }, false),
                            Default: string(network.Default),
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "probe": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "outbound_nat_rules": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "allocated_outbound_ports": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "backend_address_pool": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "frontend_ipconfigurations": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "probes": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "port": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                        "protocol": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(network.Http),
                                string(network.Tcp),
                            }, false),
                        },
                        "etag": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "interval_in_seconds": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "load_balancing_rules": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "id": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "number_of_probes": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "request_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "resource_guid": {
                Type: schema.TypeString,
                Optional: true,
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmLoadBalancerCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).loadBalancersClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    loadBalancerName := d.Get("load_balancer_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, loadBalancerName)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Load Balancer (Load Balancer Name %q / Resource Group %q): %+v", loadBalancerName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_load_balancer", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    backendAddressPools := d.Get("backend_address_pools").([]interface{})
    etag := d.Get("etag").(string)
    frontendIpconfigurations := d.Get("frontend_ipconfigurations").([]interface{})
    inboundNatPools := d.Get("inbound_nat_pools").([]interface{})
    inboundNatRules := d.Get("inbound_nat_rules").([]interface{})
    loadBalancingRules := d.Get("load_balancing_rules").([]interface{})
    outboundNatRules := d.Get("outbound_nat_rules").([]interface{})
    probes := d.Get("probes").([]interface{})
    resourceGuid := d.Get("resource_guid").(string)
    t := d.Get("tags").(map[string]interface{})

    parameters := network.LoadBalancer{
        Etag: utils.String(etag),
        Location: utils.String(location),
        LoadBalancerPropertiesFormat: &network.LoadBalancerPropertiesFormat{
            BackendAddressPools: expandArmLoadBalancerBackendAddressPool(backendAddressPools),
            FrontendIpconfigurations: expandArmLoadBalancerFrontendIpConfiguration(frontendIpconfigurations),
            InboundNatPools: expandArmLoadBalancerInboundNatPool(inboundNatPools),
            InboundNatRules: expandArmLoadBalancerInboundNatRule(inboundNatRules),
            LoadBalancingRules: expandArmLoadBalancerLoadBalancingRule(loadBalancingRules),
            OutboundNatRules: expandArmLoadBalancerOutboundNatRule(outboundNatRules),
            Probes: expandArmLoadBalancerProbe(probes),
            ResourceGuid: utils.String(resourceGuid),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.CreateOrUpdate(ctx, resourceGroup, loadBalancerName, parameters)
    if err != nil {
        return fmt.Errorf("Error creating Load Balancer (Load Balancer Name %q / Resource Group %q): %+v", loadBalancerName, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Load Balancer (Load Balancer Name %q / Resource Group %q): %+v", loadBalancerName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, loadBalancerName)
    if err != nil {
        return fmt.Errorf("Error retrieving Load Balancer (Load Balancer Name %q / Resource Group %q): %+v", loadBalancerName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Load Balancer (Load Balancer Name %q / Resource Group %q) ID", loadBalancerName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmLoadBalancerRead(d, meta)
}

func resourceArmLoadBalancerRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).loadBalancersClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    loadBalancerName := id.Path["loadBalancers"]

    resp, err := client.Get(ctx, resourceGroup, loadBalancerName)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Load Balancer %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Load Balancer (Load Balancer Name %q / Resource Group %q): %+v", loadBalancerName, resourceGroup, err)
    }


    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    if loadBalancerPropertiesFormat := resp.LoadBalancerPropertiesFormat; loadBalancerPropertiesFormat != nil {
        if err := d.Set("backend_address_pools", flattenArmLoadBalancerBackendAddressPool(loadBalancerPropertiesFormat.BackendAddressPools)); err != nil {
            return fmt.Errorf("Error setting `backend_address_pools`: %+v", err)
        }
        if err := d.Set("frontend_ipconfigurations", flattenArmLoadBalancerFrontendIpConfiguration(loadBalancerPropertiesFormat.FrontendIpconfigurations)); err != nil {
            return fmt.Errorf("Error setting `frontend_ipconfigurations`: %+v", err)
        }
        if err := d.Set("inbound_nat_pools", flattenArmLoadBalancerInboundNatPool(loadBalancerPropertiesFormat.InboundNatPools)); err != nil {
            return fmt.Errorf("Error setting `inbound_nat_pools`: %+v", err)
        }
        if err := d.Set("inbound_nat_rules", flattenArmLoadBalancerInboundNatRule(loadBalancerPropertiesFormat.InboundNatRules)); err != nil {
            return fmt.Errorf("Error setting `inbound_nat_rules`: %+v", err)
        }
        if err := d.Set("load_balancing_rules", flattenArmLoadBalancerLoadBalancingRule(loadBalancerPropertiesFormat.LoadBalancingRules)); err != nil {
            return fmt.Errorf("Error setting `load_balancing_rules`: %+v", err)
        }
        if err := d.Set("outbound_nat_rules", flattenArmLoadBalancerOutboundNatRule(loadBalancerPropertiesFormat.OutboundNatRules)); err != nil {
            return fmt.Errorf("Error setting `outbound_nat_rules`: %+v", err)
        }
        if err := d.Set("probes", flattenArmLoadBalancerProbe(loadBalancerPropertiesFormat.Probes)); err != nil {
            return fmt.Errorf("Error setting `probes`: %+v", err)
        }
        d.Set("provisioning_state", loadBalancerPropertiesFormat.ProvisioningState)
        d.Set("resource_guid", loadBalancerPropertiesFormat.ResourceGuid)
    }
    d.Set("etag", resp.Etag)
    d.Set("load_balancer_name", loadBalancerName)
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}


func resourceArmLoadBalancerDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).loadBalancersClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    loadBalancerName := id.Path["loadBalancers"]

    future, err := client.Delete(ctx, resourceGroup, loadBalancerName)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Load Balancer (Load Balancer Name %q / Resource Group %q): %+v", loadBalancerName, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Load Balancer (Load Balancer Name %q / Resource Group %q): %+v", loadBalancerName, resourceGroup, err)
        }
    }

    return nil
}

func expandArmLoadBalancerBackendAddressPool(input []interface{}) *[]network.BackendAddressPool {
    results := make([]network.BackendAddressPool, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        backendIpconfigurations := v["backend_ipconfigurations"].([]interface{})
        loadBalancingRules := v["load_balancing_rules"].([]interface{})
        outboundNatRule := v["outbound_nat_rule"].([]interface{})
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.BackendAddressPool{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            BackendAddressPoolPropertiesFormat: &network.BackendAddressPoolPropertiesFormat{
                BackendIpconfigurations: expandArmLoadBalancerSubResource(backendIpconfigurations),
                LoadBalancingRules: expandArmLoadBalancerSubResource(loadBalancingRules),
                OutboundNatRule: expandArmLoadBalancerSubResource(outboundNatRule),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerFrontendIpConfiguration(input []interface{}) *[]network.FrontendIpConfiguration {
    results := make([]network.FrontendIpConfiguration, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        privateIpAddress := v["private_ip_address"].(string)
        privateIpallocationMethod := v["private_ipallocation_method"].(string)
        subnet := v["subnet"].([]interface{})
        publicIpAddress := v["public_ip_address"].([]interface{})
        inboundNatRules := v["inbound_nat_rules"].([]interface{})
        inboundNatPools := v["inbound_nat_pools"].([]interface{})
        outboundNatRules := v["outbound_nat_rules"].([]interface{})
        loadBalancingRules := v["load_balancing_rules"].([]interface{})
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.FrontendIpConfiguration{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            FrontendIpConfigurationPropertiesFormat: &network.FrontendIpConfigurationPropertiesFormat{
                InboundNatPools: expandArmLoadBalancerSubResource(inboundNatPools),
                InboundNatRules: expandArmLoadBalancerSubResource(inboundNatRules),
                LoadBalancingRules: expandArmLoadBalancerSubResource(loadBalancingRules),
                OutboundNatRules: expandArmLoadBalancerSubResource(outboundNatRules),
                PrivateIpAddress: utils.String(privateIpAddress),
                PrivateIpallocationMethod: network.IpAllocationMethod(privateIpallocationMethod),
                PublicIpAddress: expandArmLoadBalancerSubResource(publicIpAddress),
                Subnet: expandArmLoadBalancerSubResource(subnet),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerInboundNatPool(input []interface{}) *[]network.InboundNatPool {
    results := make([]network.InboundNatPool, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        frontendIpconfiguration := v["frontend_ipconfiguration"].([]interface{})
        protocol := v["protocol"].(string)
        frontendPortRangeStart := v["frontend_port_range_start"].(int)
        frontendPortRangeEnd := v["frontend_port_range_end"].(int)
        backendPort := v["backend_port"].(int)
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.InboundNatPool{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            InboundNatPoolPropertiesFormat: &network.InboundNatPoolPropertiesFormat{
                BackendPort: utils.Int32(int32(backendPort)),
                FrontendIpconfiguration: expandArmLoadBalancerSubResource(frontendIpconfiguration),
                FrontendPortRangeEnd: utils.Int32(int32(frontendPortRangeEnd)),
                FrontendPortRangeStart: utils.Int32(int32(frontendPortRangeStart)),
                Protocol: network.TransportProtocol(protocol),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerInboundNatRule(input []interface{}) *[]network.InboundNatRule {
    results := make([]network.InboundNatRule, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        frontendIpconfiguration := v["frontend_ipconfiguration"].([]interface{})
        backendIpconfiguration := v["backend_ipconfiguration"].([]interface{})
        protocol := v["protocol"].(string)
        frontendPort := v["frontend_port"].(int)
        backendPort := v["backend_port"].(int)
        idleTimeoutInMinutes := v["idle_timeout_in_minutes"].(int)
        enableFloatingIp := v["enable_floating_ip"].(bool)
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.InboundNatRule{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            InboundNatRulePropertiesFormat: &network.InboundNatRulePropertiesFormat{
                BackendIpconfiguration: expandArmLoadBalancerSubResource(backendIpconfiguration),
                BackendPort: utils.Int32(int32(backendPort)),
                EnableFloatingIp: utils.Bool(enableFloatingIp),
                FrontendIpconfiguration: expandArmLoadBalancerSubResource(frontendIpconfiguration),
                FrontendPort: utils.Int32(int32(frontendPort)),
                IdleTimeoutInMinutes: utils.Int32(int32(idleTimeoutInMinutes)),
                Protocol: network.TransportProtocol(protocol),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerLoadBalancingRule(input []interface{}) *[]network.LoadBalancingRule {
    results := make([]network.LoadBalancingRule, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        frontendIpconfiguration := v["frontend_ipconfiguration"].([]interface{})
        backendAddressPool := v["backend_address_pool"].([]interface{})
        probe := v["probe"].([]interface{})
        protocol := v["protocol"].(string)
        loadDistribution := v["load_distribution"].(string)
        frontendPort := v["frontend_port"].(int)
        backendPort := v["backend_port"].(int)
        idleTimeoutInMinutes := v["idle_timeout_in_minutes"].(int)
        enableFloatingIp := v["enable_floating_ip"].(bool)
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.LoadBalancingRule{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            LoadBalancingRulePropertiesFormat: &network.LoadBalancingRulePropertiesFormat{
                BackendAddressPool: expandArmLoadBalancerSubResource(backendAddressPool),
                BackendPort: utils.Int32(int32(backendPort)),
                EnableFloatingIp: utils.Bool(enableFloatingIp),
                FrontendIpconfiguration: expandArmLoadBalancerSubResource(frontendIpconfiguration),
                FrontendPort: utils.Int32(int32(frontendPort)),
                IdleTimeoutInMinutes: utils.Int32(int32(idleTimeoutInMinutes)),
                LoadDistribution: network.LoadDistribution(loadDistribution),
                Probe: expandArmLoadBalancerSubResource(probe),
                Protocol: network.TransportProtocol(protocol),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerOutboundNatRule(input []interface{}) *[]network.OutboundNatRule {
    results := make([]network.OutboundNatRule, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        allocatedOutboundPorts := v["allocated_outbound_ports"].(int)
        frontendIpconfigurations := v["frontend_ipconfigurations"].([]interface{})
        backendAddressPool := v["backend_address_pool"].([]interface{})
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.OutboundNatRule{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            OutboundNatRulePropertiesFormat: &network.OutboundNatRulePropertiesFormat{
                AllocatedOutboundPorts: utils.Int32(int32(allocatedOutboundPorts)),
                BackendAddressPool: expandArmLoadBalancerSubResource(backendAddressPool),
                FrontendIpconfigurations: expandArmLoadBalancerSubResource(frontendIpconfigurations),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerProbe(input []interface{}) *[]network.Probe {
    results := make([]network.Probe, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        loadBalancingRules := v["load_balancing_rules"].([]interface{})
        protocol := v["protocol"].(string)
        port := v["port"].(int)
        intervalInSeconds := v["interval_in_seconds"].(int)
        numberOfProbes := v["number_of_probes"].(int)
        requestPath := v["request_path"].(string)
        name := v["name"].(string)
        etag := v["etag"].(string)

        result := network.Probe{
            Etag: utils.String(etag),
            ID: utils.String(id),
            Name: utils.String(name),
            ProbePropertiesFormat: &network.ProbePropertiesFormat{
                IntervalInSeconds: utils.Int32(int32(intervalInSeconds)),
                LoadBalancingRules: expandArmLoadBalancerSubResource(loadBalancingRules),
                NumberOfProbes: utils.Int32(int32(numberOfProbes)),
                Port: utils.Int32(int32(port)),
                Protocol: network.ProbeProtocol(protocol),
                RequestPath: utils.String(requestPath),
            },
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerSubResource(input []interface{}) *[]network.SubResource {
    results := make([]network.SubResource, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)

        result := network.SubResource{
            ID: utils.String(id),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmLoadBalancerSubResource(input []interface{}) *network.SubResource {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    id := v["id"].(string)

    result := network.SubResource{
        ID: utils.String(id),
    }
    return &result
}


func flattenArmLoadBalancerBackendAddressPool(input *[]network.BackendAddressPool) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }
        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if backendAddressPoolPropertiesFormat := item.BackendAddressPoolPropertiesFormat; backendAddressPoolPropertiesFormat != nil {
            v["backend_ipconfigurations"] = flattenArmLoadBalancerSubResource(backendAddressPoolPropertiesFormat.BackendIpconfigurations)
            v["load_balancing_rules"] = flattenArmLoadBalancerSubResource(backendAddressPoolPropertiesFormat.LoadBalancingRules)
            v["outbound_nat_rule"] = flattenArmLoadBalancerSubResource(backendAddressPoolPropertiesFormat.OutboundNatRule)
        }
        if etag := item.Etag; etag != nil {
            v["etag"] = *etag
        }

        results = append(results, v)
    }

    return results
}

func flattenArmLoadBalancerFrontendIpConfiguration(input *[]network.FrontendIpConfiguration) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }
        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if etag := item.Etag; etag != nil {
            v["etag"] = *etag
        }
        if frontendIpConfigurationPropertiesFormat := item.FrontendIpConfigurationPropertiesFormat; frontendIpConfigurationPropertiesFormat != nil {
            v["inbound_nat_pools"] = flattenArmLoadBalancerSubResource(frontendIpConfigurationPropertiesFormat.InboundNatPools)
            v["inbound_nat_rules"] = flattenArmLoadBalancerSubResource(frontendIpConfigurationPropertiesFormat.InboundNatRules)
            v["load_balancing_rules"] = flattenArmLoadBalancerSubResource(frontendIpConfigurationPropertiesFormat.LoadBalancingRules)
            v["outbound_nat_rules"] = flattenArmLoadBalancerSubResource(frontendIpConfigurationPropertiesFormat.OutboundNatRules)
            if privateIpAddress := frontendIpConfigurationPropertiesFormat.PrivateIpAddress; privateIpAddress != nil {
                v["private_ip_address"] = *privateIpAddress
            }
            v["private_ipallocation_method"] = string(frontendIpConfigurationPropertiesFormat.PrivateIpallocationMethod)
            v["public_ip_address"] = flattenArmLoadBalancerSubResource(frontendIpConfigurationPropertiesFormat.PublicIpAddress)
            v["subnet"] = flattenArmLoadBalancerSubResource(frontendIpConfigurationPropertiesFormat.Subnet)
        }

        results = append(results, v)
    }

    return results
}

func flattenArmLoadBalancerInboundNatPool(input *[]network.InboundNatPool) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }
        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if inboundNatPoolPropertiesFormat := item.InboundNatPoolPropertiesFormat; inboundNatPoolPropertiesFormat != nil {
            if backendPort := inboundNatPoolPropertiesFormat.BackendPort; backendPort != nil {
                v["backend_port"] = int(*backendPort)
            }
            v["frontend_ipconfiguration"] = flattenArmLoadBalancerSubResource(inboundNatPoolPropertiesFormat.FrontendIpconfiguration)
            if frontendPortRangeEnd := inboundNatPoolPropertiesFormat.FrontendPortRangeEnd; frontendPortRangeEnd != nil {
                v["frontend_port_range_end"] = int(*frontendPortRangeEnd)
            }
            if frontendPortRangeStart := inboundNatPoolPropertiesFormat.FrontendPortRangeStart; frontendPortRangeStart != nil {
                v["frontend_port_range_start"] = int(*frontendPortRangeStart)
            }
            v["protocol"] = string(inboundNatPoolPropertiesFormat.Protocol)
        }
        if etag := item.Etag; etag != nil {
            v["etag"] = *etag
        }

        results = append(results, v)
    }

    return results
}

func flattenArmLoadBalancerInboundNatRule(input *[]network.InboundNatRule) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }
        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if inboundNatRulePropertiesFormat := item.InboundNatRulePropertiesFormat; inboundNatRulePropertiesFormat != nil {
            v["backend_ipconfiguration"] = flattenArmLoadBalancerSubResource(inboundNatRulePropertiesFormat.BackendIpconfiguration)
            if backendPort := inboundNatRulePropertiesFormat.BackendPort; backendPort != nil {
                v["backend_port"] = int(*backendPort)
            }
            if enableFloatingIp := inboundNatRulePropertiesFormat.EnableFloatingIp; enableFloatingIp != nil {
                v["enable_floating_ip"] = *enableFloatingIp
            }
            v["frontend_ipconfiguration"] = flattenArmLoadBalancerSubResource(inboundNatRulePropertiesFormat.FrontendIpconfiguration)
            if frontendPort := inboundNatRulePropertiesFormat.FrontendPort; frontendPort != nil {
                v["frontend_port"] = int(*frontendPort)
            }
            if idleTimeoutInMinutes := inboundNatRulePropertiesFormat.IdleTimeoutInMinutes; idleTimeoutInMinutes != nil {
                v["idle_timeout_in_minutes"] = int(*idleTimeoutInMinutes)
            }
            v["protocol"] = string(inboundNatRulePropertiesFormat.Protocol)
        }
        if etag := item.Etag; etag != nil {
            v["etag"] = *etag
        }

        results = append(results, v)
    }

    return results
}

func flattenArmLoadBalancerLoadBalancingRule(input *[]network.LoadBalancingRule) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }
        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if loadBalancingRulePropertiesFormat := item.LoadBalancingRulePropertiesFormat; loadBalancingRulePropertiesFormat != nil {
            v["backend_address_pool"] = flattenArmLoadBalancerSubResource(loadBalancingRulePropertiesFormat.BackendAddressPool)
            if backendPort := loadBalancingRulePropertiesFormat.BackendPort; backendPort != nil {
                v["backend_port"] = int(*backendPort)
            }
            if enableFloatingIp := loadBalancingRulePropertiesFormat.EnableFloatingIp; enableFloatingIp != nil {
                v["enable_floating_ip"] = *enableFloatingIp
            }
            v["frontend_ipconfiguration"] = flattenArmLoadBalancerSubResource(loadBalancingRulePropertiesFormat.FrontendIpconfiguration)
            if frontendPort := loadBalancingRulePropertiesFormat.FrontendPort; frontendPort != nil {
                v["frontend_port"] = int(*frontendPort)
            }
            if idleTimeoutInMinutes := loadBalancingRulePropertiesFormat.IdleTimeoutInMinutes; idleTimeoutInMinutes != nil {
                v["idle_timeout_in_minutes"] = int(*idleTimeoutInMinutes)
            }
            v["load_distribution"] = string(loadBalancingRulePropertiesFormat.LoadDistribution)
            v["probe"] = flattenArmLoadBalancerSubResource(loadBalancingRulePropertiesFormat.Probe)
            v["protocol"] = string(loadBalancingRulePropertiesFormat.Protocol)
        }
        if etag := item.Etag; etag != nil {
            v["etag"] = *etag
        }

        results = append(results, v)
    }

    return results
}

func flattenArmLoadBalancerOutboundNatRule(input *[]network.OutboundNatRule) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }
        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if outboundNatRulePropertiesFormat := item.OutboundNatRulePropertiesFormat; outboundNatRulePropertiesFormat != nil {
            if allocatedOutboundPorts := outboundNatRulePropertiesFormat.AllocatedOutboundPorts; allocatedOutboundPorts != nil {
                v["allocated_outbound_ports"] = int(*allocatedOutboundPorts)
            }
            v["backend_address_pool"] = flattenArmLoadBalancerSubResource(outboundNatRulePropertiesFormat.BackendAddressPool)
            v["frontend_ipconfigurations"] = flattenArmLoadBalancerSubResource(outboundNatRulePropertiesFormat.FrontendIpconfigurations)
        }
        if etag := item.Etag; etag != nil {
            v["etag"] = *etag
        }

        results = append(results, v)
    }

    return results
}

func flattenArmLoadBalancerProbe(input *[]network.Probe) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }
        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if etag := item.Etag; etag != nil {
            v["etag"] = *etag
        }
        if probePropertiesFormat := item.ProbePropertiesFormat; probePropertiesFormat != nil {
            if intervalInSeconds := probePropertiesFormat.IntervalInSeconds; intervalInSeconds != nil {
                v["interval_in_seconds"] = int(*intervalInSeconds)
            }
            v["load_balancing_rules"] = flattenArmLoadBalancerSubResource(probePropertiesFormat.LoadBalancingRules)
            if numberOfProbes := probePropertiesFormat.NumberOfProbes; numberOfProbes != nil {
                v["number_of_probes"] = int(*numberOfProbes)
            }
            if port := probePropertiesFormat.Port; port != nil {
                v["port"] = int(*port)
            }
            v["protocol"] = string(probePropertiesFormat.Protocol)
            if requestPath := probePropertiesFormat.RequestPath; requestPath != nil {
                v["request_path"] = *requestPath
            }
        }

        results = append(results, v)
    }

    return results
}

func flattenArmLoadBalancerSubResource(input *[]network.SubResource) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }

        results = append(results, v)
    }

    return results
}

func flattenArmLoadBalancerSubResource(input *network.SubResource) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if id := input.ID; id != nil {
        result["id"] = *id
    }

    return []interface{}{result}
}
