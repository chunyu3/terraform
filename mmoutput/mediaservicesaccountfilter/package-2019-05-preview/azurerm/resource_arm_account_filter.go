// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmAccountFilter() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmAccountFilterCreate,
        Read: resourceArmAccountFilterRead,
        Update: resourceArmAccountFilterUpdate,
        Delete: resourceArmAccountFilterDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "account_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "filter_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "first_quality": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "bitrate": {
                            Type: schema.TypeInt,
                            Required: true,
                        },
                    },
                },
            },

            "presentation_time_range": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "end_timestamp": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "force_end_timestamp": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "live_backoff_duration": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "presentation_window_duration": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "start_timestamp": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "timescale": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                    },
                },
            },

            "tracks": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "track_selections": {
                            Type: schema.TypeList,
                            Required: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "operation": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(mediaservices.Equal),
                                            string(mediaservices.NotEqual),
                                        }, false),
                                    },
                                    "property": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(mediaservices.Unknown),
                                            string(mediaservices.Type),
                                            string(mediaservices.Name),
                                            string(mediaservices.Language),
                                            string(mediaservices.FourCC),
                                            string(mediaservices.Bitrate),
                                        }, false),
                                    },
                                    "value": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },
        },
    }
}

func resourceArmAccountFilterCreate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).accountFiltersClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    accountName := d.Get("account_name").(string)
    filterName := d.Get("filter_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, accountName, filterName)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Account Filter (Filter Name %q / Account Name %q / Resource Group %q): %+v", filterName, accountName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_account_filter", *existing.ID)
        }
    }

    firstQuality := d.Get("first_quality").([]interface{})
    presentationTimeRange := d.Get("presentation_time_range").([]interface{})
    tracks := d.Get("tracks").([]interface{})

    parameters := mediaservices.AccountFilter{
        MediaFilterProperties: &mediaservices.MediaFilterProperties{
            FirstQuality: expandArmAccountFilterFirstQuality(firstQuality),
            PresentationTimeRange: expandArmAccountFilterPresentationTimeRange(presentationTimeRange),
            Tracks: expandArmAccountFilterFilterTrackSelection(tracks),
        },
    }


    if _, err := client.CreateOrUpdate(ctx, resourceGroup, accountName, filterName, parameters); err != nil {
        return fmt.Errorf("Error creating Account Filter (Filter Name %q / Account Name %q / Resource Group %q): %+v", filterName, accountName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, accountName, filterName)
    if err != nil {
        return fmt.Errorf("Error retrieving Account Filter (Filter Name %q / Account Name %q / Resource Group %q): %+v", filterName, accountName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Account Filter (Filter Name %q / Account Name %q / Resource Group %q) ID", filterName, accountName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmAccountFilterRead(d, meta)
}

func resourceArmAccountFilterRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).accountFiltersClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    accountName := id.Path["mediaServices"]
    filterName := id.Path["accountFilters"]

    resp, err := client.Get(ctx, resourceGroup, accountName, filterName)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Account Filter %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Account Filter (Filter Name %q / Account Name %q / Resource Group %q): %+v", filterName, accountName, resourceGroup, err)
    }


    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    d.Set("account_name", accountName)
    d.Set("filter_name", filterName)
    if mediaFilterProperties := resp.MediaFilterProperties; mediaFilterProperties != nil {
        if err := d.Set("first_quality", flattenArmAccountFilterFirstQuality(mediaFilterProperties.FirstQuality)); err != nil {
            return fmt.Errorf("Error setting `first_quality`: %+v", err)
        }
        if err := d.Set("presentation_time_range", flattenArmAccountFilterPresentationTimeRange(mediaFilterProperties.PresentationTimeRange)); err != nil {
            return fmt.Errorf("Error setting `presentation_time_range`: %+v", err)
        }
        if err := d.Set("tracks", flattenArmAccountFilterFilterTrackSelection(mediaFilterProperties.Tracks)); err != nil {
            return fmt.Errorf("Error setting `tracks`: %+v", err)
        }
    }
    d.Set("type", resp.Type)

    return nil
}

func resourceArmAccountFilterUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).accountFiltersClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    accountName := d.Get("account_name").(string)
    filterName := d.Get("filter_name").(string)
    firstQuality := d.Get("first_quality").([]interface{})
    presentationTimeRange := d.Get("presentation_time_range").([]interface{})
    tracks := d.Get("tracks").([]interface{})

    parameters := mediaservices.AccountFilter{
        MediaFilterProperties: &mediaservices.MediaFilterProperties{
            FirstQuality: expandArmAccountFilterFirstQuality(firstQuality),
            PresentationTimeRange: expandArmAccountFilterPresentationTimeRange(presentationTimeRange),
            Tracks: expandArmAccountFilterFilterTrackSelection(tracks),
        },
    }


    if _, err := client.Update(ctx, resourceGroup, accountName, filterName, parameters); err != nil {
        return fmt.Errorf("Error updating Account Filter (Filter Name %q / Account Name %q / Resource Group %q): %+v", filterName, accountName, resourceGroup, err)
    }

    return resourceArmAccountFilterRead(d, meta)
}

func resourceArmAccountFilterDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).accountFiltersClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    accountName := id.Path["mediaServices"]
    filterName := id.Path["accountFilters"]

    if _, err := client.Delete(ctx, resourceGroup, accountName, filterName); err != nil {
        return fmt.Errorf("Error deleting Account Filter (Filter Name %q / Account Name %q / Resource Group %q): %+v", filterName, accountName, resourceGroup, err)
    }

    return nil
}

func expandArmAccountFilterFirstQuality(input []interface{}) *mediaservices.FirstQuality {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    bitrate := v["bitrate"].(int)

    result := mediaservices.FirstQuality{
        Bitrate: utils.Int32(int32(bitrate)),
    }
    return &result
}

func expandArmAccountFilterPresentationTimeRange(input []interface{}) *mediaservices.PresentationTimeRange {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    startTimestamp := v["start_timestamp"].(int)
    endTimestamp := v["end_timestamp"].(int)
    presentationWindowDuration := v["presentation_window_duration"].(int)
    liveBackoffDuration := v["live_backoff_duration"].(int)
    timescale := v["timescale"].(int)
    forceEndTimestamp := v["force_end_timestamp"].(bool)

    result := mediaservices.PresentationTimeRange{
        EndTimestamp: utils.Int64(int64(endTimestamp)),
        ForceEndTimestamp: utils.Bool(forceEndTimestamp),
        LiveBackoffDuration: utils.Int64(int64(liveBackoffDuration)),
        PresentationWindowDuration: utils.Int64(int64(presentationWindowDuration)),
        StartTimestamp: utils.Int64(int64(startTimestamp)),
        Timescale: utils.Int64(int64(timescale)),
    }
    return &result
}

func expandArmAccountFilterFilterTrackSelection(input []interface{}) *[]mediaservices.FilterTrackSelection {
    results := make([]mediaservices.FilterTrackSelection, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        trackSelections := v["track_selections"].([]interface{})

        result := mediaservices.FilterTrackSelection{
            TrackSelections: expandArmAccountFilterFilterTrackPropertyCondition(trackSelections),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmAccountFilterFilterTrackPropertyCondition(input []interface{}) *[]mediaservices.FilterTrackPropertyCondition {
    results := make([]mediaservices.FilterTrackPropertyCondition, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        property := v["property"].(string)
        value := v["value"].(string)
        operation := v["operation"].(string)

        result := mediaservices.FilterTrackPropertyCondition{
            Operation: mediaservices.FilterTrackPropertyCompareOperation(operation),
            Property: mediaservices.FilterTrackPropertyType(property),
            Value: utils.String(value),
        }

        results = append(results, result)
    }
    return &results
}


func flattenArmAccountFilterFirstQuality(input *mediaservices.FirstQuality) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if bitrate := input.Bitrate; bitrate != nil {
        result["bitrate"] = int(*bitrate)
    }

    return []interface{}{result}
}

func flattenArmAccountFilterPresentationTimeRange(input *mediaservices.PresentationTimeRange) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if endTimestamp := input.EndTimestamp; endTimestamp != nil {
        result["end_timestamp"] = int(*endTimestamp)
    }
    if forceEndTimestamp := input.ForceEndTimestamp; forceEndTimestamp != nil {
        result["force_end_timestamp"] = *forceEndTimestamp
    }
    if liveBackoffDuration := input.LiveBackoffDuration; liveBackoffDuration != nil {
        result["live_backoff_duration"] = int(*liveBackoffDuration)
    }
    if presentationWindowDuration := input.PresentationWindowDuration; presentationWindowDuration != nil {
        result["presentation_window_duration"] = int(*presentationWindowDuration)
    }
    if startTimestamp := input.StartTimestamp; startTimestamp != nil {
        result["start_timestamp"] = int(*startTimestamp)
    }
    if timescale := input.Timescale; timescale != nil {
        result["timescale"] = int(*timescale)
    }

    return []interface{}{result}
}

func flattenArmAccountFilterFilterTrackSelection(input *[]mediaservices.FilterTrackSelection) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        v["track_selections"] = flattenArmAccountFilterFilterTrackPropertyCondition(item.TrackSelections)

        results = append(results, v)
    }

    return results
}

func flattenArmAccountFilterFilterTrackPropertyCondition(input *[]mediaservices.FilterTrackPropertyCondition) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        v["operation"] = string(item.Operation)
        v["property"] = string(item.Property)
        if value := item.Value; value != nil {
            v["value"] = *value
        }

        results = append(results, v)
    }

    return results
}
