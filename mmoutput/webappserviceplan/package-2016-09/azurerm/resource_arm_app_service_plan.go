// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmAppServicePlan() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmAppServicePlanCreate,
        Read: resourceArmAppServicePlanRead,
        Update: resourceArmAppServicePlanUpdate,
        Delete: resourceArmAppServicePlanDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "name": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "resource_group": {
                Type: schema.TypeString,
                Computed: true,
            },

            "admin_site_name": {
                Type: schema.TypeString,
                Optional: true,
            },

            "hosting_environment_profile": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "id": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "is_spot": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "kind": {
                Type: schema.TypeString,
                Optional: true,
                ForceNew: true,
            },

            "per_site_scaling": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "reserved": {
                Type: schema.TypeBool,
                Optional: true,
            },

            "sku": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "capabilities": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "name": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "reason": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "value": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "capacity": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "family": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "locations": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Schema{
                                Type: schema.TypeString,
                            },
                        },
                        "name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "size": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "sku_capacity": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "default": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "maximum": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "minimum": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "scale_type": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "tier": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "spot_expiration_time": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validateRFC3339Date,
            },

            "target_worker_count": {
                Type: schema.TypeInt,
                Optional: true,
            },

            "target_worker_size_id": {
                Type: schema.TypeInt,
                Optional: true,
            },

            "worker_tier_name": {
                Type: schema.TypeString,
                Optional: true,
            },

            "geo_region": {
                Type: schema.TypeString,
                Computed: true,
            },

            "maximum_number_of_workers": {
                Type: schema.TypeInt,
                Computed: true,
            },

            "number_of_sites": {
                Type: schema.TypeInt,
                Computed: true,
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "status": {
                Type: schema.TypeString,
                Computed: true,
            },

            "subscription": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmAppServicePlanCreate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).appServicePlansClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, name)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing App Service Plan %q (Resource Group %q): %+v", name, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_app_service_plan", *existing.ID)
        }
    }

    name := d.Get("name").(string)
    location := azure.NormalizeLocation(d.Get("location").(string))
    adminSiteName := d.Get("admin_site_name").(string)
    hostingEnvironmentProfile := d.Get("hosting_environment_profile").([]interface{})
    isSpot := d.Get("is_spot").(bool)
    kind := d.Get("kind").(string)
    perSiteScaling := d.Get("per_site_scaling").(bool)
    reserved := d.Get("reserved").(bool)
    sku := d.Get("sku").([]interface{})
    spotExpirationTime := d.Get("spot_expiration_time").(string)
    targetWorkerCount := d.Get("target_worker_count").(int)
    targetWorkerSizeId := d.Get("target_worker_size_id").(int)
    workerTierName := d.Get("worker_tier_name").(string)
    t := d.Get("tags").(map[string]interface{})

    appServicePlan := web.AppServicePlan{
        Kind: utils.String(kind),
        Location: utils.String(location),
        AppServicePlan_properties: &web.AppServicePlan_properties{
            AdminSiteName: utils.String(adminSiteName),
            HostingEnvironmentProfile: expandArmAppServicePlanHostingEnvironmentProfile(hostingEnvironmentProfile),
            IsSpot: utils.Bool(isSpot),
            Name: utils.String(name),
            PerSiteScaling: utils.Bool(perSiteScaling),
            Reserved: utils.Bool(reserved),
            SpotExpirationTime: convertStringToDate(spotExpirationTime),
            TargetWorkerCount: utils.Int32(int32(targetWorkerCount)),
            TargetWorkerSizeID: utils.Int32(int32(targetWorkerSizeId)),
            WorkerTierName: utils.String(workerTierName),
        },
        Sku: expandArmAppServicePlanSkuDescription(sku),
        Tags: tags.Expand(t),
    }


    future, err := client.CreateOrUpdate(ctx, resourceGroup, name, appServicePlan)
    if err != nil {
        return fmt.Errorf("Error creating App Service Plan %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of App Service Plan %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        return fmt.Errorf("Error retrieving App Service Plan %q (Resource Group %q): %+v", name, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read App Service Plan %q (Resource Group %q) ID", name, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmAppServicePlanRead(d, meta)
}

func resourceArmAppServicePlanRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).appServicePlansClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["serverfarms"]

    resp, err := client.Get(ctx, resourceGroup, name)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] App Service Plan %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading App Service Plan %q (Resource Group %q): %+v", name, resourceGroup, err)
    }


    d.Set("name", name)
    if appServicePlanProperties := resp.AppServicePlan_properties; appServicePlanProperties != nil {
        d.Set("name", appServicePlanProperties.Name)
        d.Set("admin_site_name", appServicePlanProperties.AdminSiteName)
        d.Set("geo_region", appServicePlanProperties.GeoRegion)
        if err := d.Set("hosting_environment_profile", flattenArmAppServicePlanHostingEnvironmentProfile(appServicePlanProperties.HostingEnvironmentProfile)); err != nil {
            return fmt.Errorf("Error setting `hosting_environment_profile`: %+v", err)
        }
        d.Set("is_spot", appServicePlanProperties.IsSpot)
        d.Set("maximum_number_of_workers", int(*appServicePlanProperties.MaximumNumberOfWorkers))
        d.Set("number_of_sites", int(*appServicePlanProperties.NumberOfSites))
        d.Set("per_site_scaling", appServicePlanProperties.PerSiteScaling)
        d.Set("provisioning_state", string(appServicePlanProperties.ProvisioningState))
        d.Set("reserved", appServicePlanProperties.Reserved)
        d.Set("resource_group", appServicePlanProperties.ResourceGroup)
        d.Set("spot_expiration_time", (appServicePlanProperties.SpotExpirationTime).String())
        d.Set("status", string(appServicePlanProperties.Status))
        d.Set("subscription", appServicePlanProperties.Subscription)
        d.Set("target_worker_count", int(*appServicePlanProperties.TargetWorkerCount))
        d.Set("target_worker_size_id", int(*appServicePlanProperties.TargetWorkerSizeID))
        d.Set("worker_tier_name", appServicePlanProperties.WorkerTierName)
    }
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    d.Set("kind", resp.Kind)
    if err := d.Set("sku", flattenArmAppServicePlanSkuDescription(resp.Sku)); err != nil {
        return fmt.Errorf("Error setting `sku`: %+v", err)
    }
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}

func resourceArmAppServicePlanUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).appServicePlansClient
    ctx := meta.(*ArmClient).StopContext

    name := d.Get("name").(string)
    name := d.Get("name").(string)
    resourceGroup := d.Get("resource_group").(string)
    adminSiteName := d.Get("admin_site_name").(string)
    hostingEnvironmentProfile := d.Get("hosting_environment_profile").([]interface{})
    isSpot := d.Get("is_spot").(bool)
    kind := d.Get("kind").(string)
    perSiteScaling := d.Get("per_site_scaling").(bool)
    reserved := d.Get("reserved").(bool)
    sku := d.Get("sku").([]interface{})
    spotExpirationTime := d.Get("spot_expiration_time").(string)
    targetWorkerCount := d.Get("target_worker_count").(int)
    targetWorkerSizeId := d.Get("target_worker_size_id").(int)
    workerTierName := d.Get("worker_tier_name").(string)
    t := d.Get("tags").(map[string]interface{})

    appServicePlan := web.AppServicePlan{
        Kind: utils.String(kind),
        Location: utils.String(location),
        AppServicePlan_properties: &web.AppServicePlan_properties{
            AdminSiteName: utils.String(adminSiteName),
            HostingEnvironmentProfile: expandArmAppServicePlanHostingEnvironmentProfile(hostingEnvironmentProfile),
            IsSpot: utils.Bool(isSpot),
            Name: utils.String(name),
            PerSiteScaling: utils.Bool(perSiteScaling),
            Reserved: utils.Bool(reserved),
            SpotExpirationTime: convertStringToDate(spotExpirationTime),
            TargetWorkerCount: utils.Int32(int32(targetWorkerCount)),
            TargetWorkerSizeID: utils.Int32(int32(targetWorkerSizeId)),
            WorkerTierName: utils.String(workerTierName),
        },
        Sku: expandArmAppServicePlanSkuDescription(sku),
        Tags: tags.Expand(t),
    }


    if _, err := client.Update(ctx, resourceGroup, name, appServicePlan); err != nil {
        return fmt.Errorf("Error updating App Service Plan %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    return resourceArmAppServicePlanRead(d, meta)
}

func resourceArmAppServicePlanDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).appServicePlansClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    name := id.Path["serverfarms"]

    if _, err := client.Delete(ctx, resourceGroup, name); err != nil {
        return fmt.Errorf("Error deleting App Service Plan %q (Resource Group %q): %+v", name, resourceGroup, err)
    }

    return nil
}

func expandArmAppServicePlanHostingEnvironmentProfile(input []interface{}) *web.HostingEnvironmentProfile {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    id := v["id"].(string)

    result := web.HostingEnvironmentProfile{
        ID: utils.String(id),
    }
    return &result
}

func convertStringToDate(input interface{}) *date.Time {
  v := input.(string)

  dateTime, err := date.ParseTime(time.RFC3339, v)
  if err != nil {
      log.Printf("[ERROR] Cannot convert an invalid string to RFC3339 date %q: %+v", v, err)
      return nil
  }

  result := date.Time{
      Time: dateTime,
  }
  return &result
}

func expandArmAppServicePlanSkuDescription(input []interface{}) *web.SkuDescription {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    name := v["name"].(string)
    tier := v["tier"].(string)
    size := v["size"].(string)
    family := v["family"].(string)
    capacity := v["capacity"].(int)
    skuCapacity := v["sku_capacity"].([]interface{})
    locations := v["locations"].([]interface{})
    capabilities := v["capabilities"].([]interface{})

    result := web.SkuDescription{
        Capabilities: expandArmAppServicePlanCapability(capabilities),
        Capacity: utils.Int32(int32(capacity)),
        Family: utils.String(family),
        Locations: utils.ExpandStringSlice(locations),
        Name: utils.String(name),
        Size: utils.String(size),
        SkuCapacity: expandArmAppServicePlanSkuCapacity(skuCapacity),
        Tier: utils.String(tier),
    }
    return &result
}

func expandArmAppServicePlanCapability(input []interface{}) *[]web.Capability {
    results := make([]web.Capability, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        value := v["value"].(string)
        reason := v["reason"].(string)

        result := web.Capability{
            Name: utils.String(name),
            Reason: utils.String(reason),
            Value: utils.String(value),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmAppServicePlanSkuCapacity(input []interface{}) *web.SkuCapacity {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    minimum := v["minimum"].(int)
    maximum := v["maximum"].(int)
    default := v["default"].(int)
    scaleType := v["scale_type"].(string)

    result := web.SkuCapacity{
        Default: utils.Int32(int32(default)),
        Maximum: utils.Int32(int32(maximum)),
        Minimum: utils.Int32(int32(minimum)),
        ScaleType: utils.String(scaleType),
    }
    return &result
}


func flattenArmAppServicePlanHostingEnvironmentProfile(input *web.HostingEnvironmentProfile) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if id := input.ID; id != nil {
        result["id"] = *id
    }

    return []interface{}{result}
}

func flattenArmAppServicePlanSkuDescription(input *web.SkuDescription) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if name := input.Name; name != nil {
        result["name"] = *name
    }
    result["capabilities"] = flattenArmAppServicePlanCapability(input.Capabilities)
    if capacity := input.Capacity; capacity != nil {
        result["capacity"] = int(*capacity)
    }
    if family := input.Family; family != nil {
        result["family"] = *family
    }
    result["locations"] = utils.FlattenStringSlice(input.Locations)
    if size := input.Size; size != nil {
        result["size"] = *size
    }
    result["sku_capacity"] = flattenArmAppServicePlanSkuCapacity(input.SkuCapacity)
    if tier := input.Tier; tier != nil {
        result["tier"] = *tier
    }

    return []interface{}{result}
}

func flattenArmAppServicePlanCapability(input *[]web.Capability) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if reason := item.Reason; reason != nil {
            v["reason"] = *reason
        }
        if value := item.Value; value != nil {
            v["value"] = *value
        }

        results = append(results, v)
    }

    return results
}

func flattenArmAppServicePlanSkuCapacity(input *web.SkuCapacity) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if default := input.Default; default != nil {
        result["default"] = int(*default)
    }
    if maximum := input.Maximum; maximum != nil {
        result["maximum"] = int(*maximum)
    }
    if minimum := input.Minimum; minimum != nil {
        result["minimum"] = int(*minimum)
    }
    if scaleType := input.ScaleType; scaleType != nil {
        result["scale_type"] = *scaleType
    }

    return []interface{}{result}
}
