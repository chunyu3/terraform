// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmSqlVirtualMachine() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmSqlVirtualMachineCreate,
        Read: resourceArmSqlVirtualMachineRead,
        Update: resourceArmSqlVirtualMachineUpdate,
        Delete: resourceArmSqlVirtualMachineDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "sql_virtual_machine_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "auto_backup_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "backup_schedule_type": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(sqlvirtualmachine.Manual),
                                string(sqlvirtualmachine.Automated),
                            }, false),
                            Default: string(sqlvirtualmachine.Manual),
                        },
                        "backup_system_dbs": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "enable": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "enable_encryption": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "full_backup_frequency": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(sqlvirtualmachine.Daily),
                                string(sqlvirtualmachine.Weekly),
                            }, false),
                            Default: string(sqlvirtualmachine.Daily),
                        },
                        "full_backup_start_time": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "full_backup_window_hours": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "log_backup_frequency": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "password": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "retention_period": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "storage_access_key": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "storage_account_url": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "auto_patching_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "day_of_week": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(sqlvirtualmachine.Monday),
                                string(sqlvirtualmachine.Tuesday),
                                string(sqlvirtualmachine.Wednesday),
                                string(sqlvirtualmachine.Thursday),
                                string(sqlvirtualmachine.Friday),
                                string(sqlvirtualmachine.Saturday),
                                string(sqlvirtualmachine.Sunday),
                            }, false),
                            Default: string(sqlvirtualmachine.Monday),
                        },
                        "enable": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "maintenance_window_duration": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "maintenance_window_starting_hour": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                    },
                },
            },

            "identity": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "type": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(sqlvirtualmachine.SystemAssigned),
                            }, false),
                            Default: string(sqlvirtualmachine.SystemAssigned),
                        },
                    },
                },
            },

            "key_vault_credential_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "azure_key_vault_url": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "credential_name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "enable": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "service_principal_name": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "service_principal_secret": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "server_configurations_management_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "additional_features_server_configurations": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "is_rservices_enabled": {
                                        Type: schema.TypeBool,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "sql_connectivity_update_settings": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "connectivity_type": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(sqlvirtualmachine.LOCAL),
                                            string(sqlvirtualmachine.PRIVATE),
                                            string(sqlvirtualmachine.PUBLIC),
                                        }, false),
                                        Default: string(sqlvirtualmachine.LOCAL),
                                    },
                                    "port": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "sql_auth_update_password": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "sql_auth_update_user_name": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "sql_storage_update_settings": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "disk_configuration_type": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(sqlvirtualmachine.NEW),
                                            string(sqlvirtualmachine.EXTEND),
                                            string(sqlvirtualmachine.ADD),
                                        }, false),
                                        Default: string(sqlvirtualmachine.NEW),
                                    },
                                    "disk_count": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                    "starting_device_id": {
                                        Type: schema.TypeInt,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "sql_workload_type_update_settings": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "sql_workload_type": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                        ValidateFunc: validation.StringInSlice([]string{
                                            string(sqlvirtualmachine.GENERAL),
                                            string(sqlvirtualmachine.OLTP),
                                            string(sqlvirtualmachine.DW),
                                        }, false),
                                        Default: string(sqlvirtualmachine.GENERAL),
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "sql_image_offer": {
                Type: schema.TypeString,
                Optional: true,
            },

            "sql_image_sku": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(sqlvirtualmachine.Developer),
                    string(sqlvirtualmachine.Express),
                    string(sqlvirtualmachine.Standard),
                    string(sqlvirtualmachine.Enterprise),
                    string(sqlvirtualmachine.Web),
                }, false),
                Default: string(sqlvirtualmachine.Developer),
            },

            "sql_management": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(sqlvirtualmachine.Full),
                    string(sqlvirtualmachine.LightWeight),
                    string(sqlvirtualmachine.NoAgent),
                }, false),
                Default: string(sqlvirtualmachine.Full),
            },

            "sql_server_license_type": {
                Type: schema.TypeString,
                Optional: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(sqlvirtualmachine.PAYG),
                    string(sqlvirtualmachine.AHUB),
                }, false),
                Default: string(sqlvirtualmachine.PAYG),
            },

            "sql_virtual_machine_group_resource_id": {
                Type: schema.TypeString,
                Optional: true,
            },

            "storage_configuration_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "disk_configuration_type": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(sqlvirtualmachine.NEW),
                                string(sqlvirtualmachine.EXTEND),
                                string(sqlvirtualmachine.ADD),
                            }, false),
                            Default: string(sqlvirtualmachine.NEW),
                        },
                        "sql_data_settings": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "default_file_path": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "luns": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeInt,
                                        },
                                    },
                                },
                            },
                        },
                        "sql_log_settings": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "default_file_path": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "luns": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeInt,
                                        },
                                    },
                                },
                            },
                        },
                        "sql_temp_db_settings": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "default_file_path": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "luns": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Schema{
                                            Type: schema.TypeInt,
                                        },
                                    },
                                },
                            },
                        },
                        "storage_workload_type": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(sqlvirtualmachine.GENERAL),
                                string(sqlvirtualmachine.OLTP),
                                string(sqlvirtualmachine.DW),
                            }, false),
                            Default: string(sqlvirtualmachine.GENERAL),
                        },
                    },
                },
            },

            "virtual_machine_resource_id": {
                Type: schema.TypeString,
                Optional: true,
            },

            "wsfc_domain_credentials": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "cluster_bootstrap_account_password": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "cluster_operator_account_password": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "sql_service_account_password": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmSqlVirtualMachineCreate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).sqlVirtualMachinesClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    sqlVirtualMachineName := d.Get("sql_virtual_machine_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, sqlVirtualMachineName)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Sql Virtual Machine (Sql Virtual Machine Name %q / Resource Group %q): %+v", sqlVirtualMachineName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_sql_virtual_machine", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    autoBackupSettings := d.Get("auto_backup_settings").([]interface{})
    autoPatchingSettings := d.Get("auto_patching_settings").([]interface{})
    identity := d.Get("identity").([]interface{})
    keyVaultCredentialSettings := d.Get("key_vault_credential_settings").([]interface{})
    serverConfigurationsManagementSettings := d.Get("server_configurations_management_settings").([]interface{})
    sqlImageOffer := d.Get("sql_image_offer").(string)
    sqlImageSku := d.Get("sql_image_sku").(string)
    sqlManagement := d.Get("sql_management").(string)
    sqlServerLicenseType := d.Get("sql_server_license_type").(string)
    sqlVirtualMachineGroupResourceId := d.Get("sql_virtual_machine_group_resource_id").(string)
    storageConfigurationSettings := d.Get("storage_configuration_settings").([]interface{})
    virtualMachineResourceId := d.Get("virtual_machine_resource_id").(string)
    wsfcDomainCredentials := d.Get("wsfc_domain_credentials").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    parameters := sqlvirtualmachine.{
        Identity: expandArmSqlVirtualMachineResourceIdentity(identity),
        Location: utils.String(location),
        Properties: &sqlvirtualmachine.Properties{
            AutoBackupSettings: expandArmSqlVirtualMachineAutoBackupSettings(autoBackupSettings),
            AutoPatchingSettings: expandArmSqlVirtualMachineAutoPatchingSettings(autoPatchingSettings),
            KeyVaultCredentialSettings: expandArmSqlVirtualMachineKeyVaultCredentialSettings(keyVaultCredentialSettings),
            ServerConfigurationsManagementSettings: expandArmSqlVirtualMachineServerConfigurationsManagementSettings(serverConfigurationsManagementSettings),
            SqlImageOffer: utils.String(sqlImageOffer),
            SqlImageSku: sqlvirtualmachine.SqlImageSku(sqlImageSku),
            SqlManagement: sqlvirtualmachine.SqlManagementMode(sqlManagement),
            SqlServerLicenseType: sqlvirtualmachine.SqlServerLicenseType(sqlServerLicenseType),
            SqlVirtualMachineGroupResourceID: utils.String(sqlVirtualMachineGroupResourceId),
            StorageConfigurationSettings: expandArmSqlVirtualMachineStorageConfigurationSettings(storageConfigurationSettings),
            VirtualMachineResourceID: utils.String(virtualMachineResourceId),
            WsfcDomainCredentials: expandArmSqlVirtualMachineWsfcDomainCredentials(wsfcDomainCredentials),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.CreateOrUpdate(ctx, resourceGroup, sqlVirtualMachineName, parameters)
    if err != nil {
        return fmt.Errorf("Error creating Sql Virtual Machine (Sql Virtual Machine Name %q / Resource Group %q): %+v", sqlVirtualMachineName, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Sql Virtual Machine (Sql Virtual Machine Name %q / Resource Group %q): %+v", sqlVirtualMachineName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, sqlVirtualMachineName)
    if err != nil {
        return fmt.Errorf("Error retrieving Sql Virtual Machine (Sql Virtual Machine Name %q / Resource Group %q): %+v", sqlVirtualMachineName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Sql Virtual Machine (Sql Virtual Machine Name %q / Resource Group %q) ID", sqlVirtualMachineName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmSqlVirtualMachineRead(d, meta)
}

func resourceArmSqlVirtualMachineRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).sqlVirtualMachinesClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    sqlVirtualMachineName := id.Path["sqlVirtualMachines"]

    resp, err := client.Get(ctx, resourceGroup, sqlVirtualMachineName)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Sql Virtual Machine %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Sql Virtual Machine (Sql Virtual Machine Name %q / Resource Group %q): %+v", sqlVirtualMachineName, resourceGroup, err)
    }


    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    if properties := resp.Properties; properties != nil {
        if err := d.Set("auto_backup_settings", flattenArmSqlVirtualMachineAutoBackupSettings(properties.AutoBackupSettings)); err != nil {
            return fmt.Errorf("Error setting `auto_backup_settings`: %+v", err)
        }
        if err := d.Set("auto_patching_settings", flattenArmSqlVirtualMachineAutoPatchingSettings(properties.AutoPatchingSettings)); err != nil {
            return fmt.Errorf("Error setting `auto_patching_settings`: %+v", err)
        }
        if err := d.Set("key_vault_credential_settings", flattenArmSqlVirtualMachineKeyVaultCredentialSettings(properties.KeyVaultCredentialSettings)); err != nil {
            return fmt.Errorf("Error setting `key_vault_credential_settings`: %+v", err)
        }
        d.Set("provisioning_state", properties.ProvisioningState)
        if err := d.Set("server_configurations_management_settings", flattenArmSqlVirtualMachineServerConfigurationsManagementSettings(properties.ServerConfigurationsManagementSettings)); err != nil {
            return fmt.Errorf("Error setting `server_configurations_management_settings`: %+v", err)
        }
        d.Set("sql_image_offer", properties.SqlImageOffer)
        d.Set("sql_image_sku", string(properties.SqlImageSku))
        d.Set("sql_management", string(properties.SqlManagement))
        d.Set("sql_server_license_type", string(properties.SqlServerLicenseType))
        d.Set("sql_virtual_machine_group_resource_id", properties.SqlVirtualMachineGroupResourceID)
        if err := d.Set("storage_configuration_settings", flattenArmSqlVirtualMachineStorageConfigurationSettings(properties.StorageConfigurationSettings)); err != nil {
            return fmt.Errorf("Error setting `storage_configuration_settings`: %+v", err)
        }
        d.Set("virtual_machine_resource_id", properties.VirtualMachineResourceID)
        if err := d.Set("wsfc_domain_credentials", flattenArmSqlVirtualMachineWsfcDomainCredentials(properties.WsfcDomainCredentials)); err != nil {
            return fmt.Errorf("Error setting `wsfc_domain_credentials`: %+v", err)
        }
    }
    if err := d.Set("identity", flattenArmSqlVirtualMachineResourceIdentity(resp.Identity)); err != nil {
        return fmt.Errorf("Error setting `identity`: %+v", err)
    }
    d.Set("sql_virtual_machine_name", sqlVirtualMachineName)
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}

func resourceArmSqlVirtualMachineUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).sqlVirtualMachinesClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    autoBackupSettings := d.Get("auto_backup_settings").([]interface{})
    autoPatchingSettings := d.Get("auto_patching_settings").([]interface{})
    identity := d.Get("identity").([]interface{})
    keyVaultCredentialSettings := d.Get("key_vault_credential_settings").([]interface{})
    serverConfigurationsManagementSettings := d.Get("server_configurations_management_settings").([]interface{})
    sqlImageOffer := d.Get("sql_image_offer").(string)
    sqlImageSku := d.Get("sql_image_sku").(string)
    sqlManagement := d.Get("sql_management").(string)
    sqlServerLicenseType := d.Get("sql_server_license_type").(string)
    sqlVirtualMachineGroupResourceId := d.Get("sql_virtual_machine_group_resource_id").(string)
    sqlVirtualMachineName := d.Get("sql_virtual_machine_name").(string)
    storageConfigurationSettings := d.Get("storage_configuration_settings").([]interface{})
    virtualMachineResourceId := d.Get("virtual_machine_resource_id").(string)
    wsfcDomainCredentials := d.Get("wsfc_domain_credentials").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    parameters := sqlvirtualmachine.{
        Identity: expandArmSqlVirtualMachineResourceIdentity(identity),
        Location: utils.String(location),
        Properties: &sqlvirtualmachine.Properties{
            AutoBackupSettings: expandArmSqlVirtualMachineAutoBackupSettings(autoBackupSettings),
            AutoPatchingSettings: expandArmSqlVirtualMachineAutoPatchingSettings(autoPatchingSettings),
            KeyVaultCredentialSettings: expandArmSqlVirtualMachineKeyVaultCredentialSettings(keyVaultCredentialSettings),
            ServerConfigurationsManagementSettings: expandArmSqlVirtualMachineServerConfigurationsManagementSettings(serverConfigurationsManagementSettings),
            SqlImageOffer: utils.String(sqlImageOffer),
            SqlImageSku: sqlvirtualmachine.SqlImageSku(sqlImageSku),
            SqlManagement: sqlvirtualmachine.SqlManagementMode(sqlManagement),
            SqlServerLicenseType: sqlvirtualmachine.SqlServerLicenseType(sqlServerLicenseType),
            SqlVirtualMachineGroupResourceID: utils.String(sqlVirtualMachineGroupResourceId),
            StorageConfigurationSettings: expandArmSqlVirtualMachineStorageConfigurationSettings(storageConfigurationSettings),
            VirtualMachineResourceID: utils.String(virtualMachineResourceId),
            WsfcDomainCredentials: expandArmSqlVirtualMachineWsfcDomainCredentials(wsfcDomainCredentials),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.Update(ctx, resourceGroup, sqlVirtualMachineName, parameters)
    if err != nil {
        return fmt.Errorf("Error updating Sql Virtual Machine (Sql Virtual Machine Name %q / Resource Group %q): %+v", sqlVirtualMachineName, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for update of Sql Virtual Machine (Sql Virtual Machine Name %q / Resource Group %q): %+v", sqlVirtualMachineName, resourceGroup, err)
    }

    return resourceArmSqlVirtualMachineRead(d, meta)
}

func resourceArmSqlVirtualMachineDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).sqlVirtualMachinesClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    sqlVirtualMachineName := id.Path["sqlVirtualMachines"]

    future, err := client.Delete(ctx, resourceGroup, sqlVirtualMachineName)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Sql Virtual Machine (Sql Virtual Machine Name %q / Resource Group %q): %+v", sqlVirtualMachineName, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Sql Virtual Machine (Sql Virtual Machine Name %q / Resource Group %q): %+v", sqlVirtualMachineName, resourceGroup, err)
        }
    }

    return nil
}

func expandArmSqlVirtualMachineResourceIdentity(input []interface{}) *sqlvirtualmachine.ResourceIdentity {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    type := v["type"].(string)

    result := sqlvirtualmachine.ResourceIdentity{
        Type: sqlvirtualmachine.IdentityType(type),
    }
    return &result
}

func expandArmSqlVirtualMachineAutoBackupSettings(input []interface{}) *sqlvirtualmachine.AutoBackupSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enable := v["enable"].(bool)
    enableEncryption := v["enable_encryption"].(bool)
    retentionPeriod := v["retention_period"].(int)
    storageAccountUrl := v["storage_account_url"].(string)
    storageAccessKey := v["storage_access_key"].(string)
    password := v["password"].(string)
    backupSystemDbs := v["backup_system_dbs"].(bool)
    backupScheduleType := v["backup_schedule_type"].(string)
    fullBackupFrequency := v["full_backup_frequency"].(string)
    fullBackupStartTime := v["full_backup_start_time"].(int)
    fullBackupWindowHours := v["full_backup_window_hours"].(int)
    logBackupFrequency := v["log_backup_frequency"].(int)

    result := sqlvirtualmachine.AutoBackupSettings{
        BackupScheduleType: sqlvirtualmachine.BackupScheduleType(backupScheduleType),
        BackupSystemDbs: utils.Bool(backupSystemDbs),
        Enable: utils.Bool(enable),
        EnableEncryption: utils.Bool(enableEncryption),
        FullBackupFrequency: sqlvirtualmachine.FullBackupFrequencyType(fullBackupFrequency),
        FullBackupStartTime: utils.Int32(int32(fullBackupStartTime)),
        FullBackupWindowHours: utils.Int32(int32(fullBackupWindowHours)),
        LogBackupFrequency: utils.Int32(int32(logBackupFrequency)),
        Password: utils.String(password),
        RetentionPeriod: utils.Int32(int32(retentionPeriod)),
        StorageAccessKey: utils.String(storageAccessKey),
        StorageAccountURL: utils.String(storageAccountUrl),
    }
    return &result
}

func expandArmSqlVirtualMachineAutoPatchingSettings(input []interface{}) *sqlvirtualmachine.AutoPatchingSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enable := v["enable"].(bool)
    dayOfWeek := v["day_of_week"].(string)
    maintenanceWindowStartingHour := v["maintenance_window_starting_hour"].(int)
    maintenanceWindowDuration := v["maintenance_window_duration"].(int)

    result := sqlvirtualmachine.AutoPatchingSettings{
        DayOfWeek: sqlvirtualmachine.DayOfWeek(dayOfWeek),
        Enable: utils.Bool(enable),
        MaintenanceWindowDuration: utils.Int32(int32(maintenanceWindowDuration)),
        MaintenanceWindowStartingHour: utils.Int32(int32(maintenanceWindowStartingHour)),
    }
    return &result
}

func expandArmSqlVirtualMachineKeyVaultCredentialSettings(input []interface{}) *sqlvirtualmachine.KeyVaultCredentialSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    enable := v["enable"].(bool)
    credentialName := v["credential_name"].(string)
    azureKeyVaultUrl := v["azure_key_vault_url"].(string)
    servicePrincipalName := v["service_principal_name"].(string)
    servicePrincipalSecret := v["service_principal_secret"].(string)

    result := sqlvirtualmachine.KeyVaultCredentialSettings{
        AzureKeyVaultURL: utils.String(azureKeyVaultUrl),
        CredentialName: utils.String(credentialName),
        Enable: utils.Bool(enable),
        ServicePrincipalName: utils.String(servicePrincipalName),
        ServicePrincipalSecret: utils.String(servicePrincipalSecret),
    }
    return &result
}

func expandArmSqlVirtualMachineServerConfigurationsManagementSettings(input []interface{}) *sqlvirtualmachine.ServerConfigurationsManagementSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    sqlConnectivityUpdateSettings := v["sql_connectivity_update_settings"].([]interface{})
    sqlWorkloadTypeUpdateSettings := v["sql_workload_type_update_settings"].([]interface{})
    sqlStorageUpdateSettings := v["sql_storage_update_settings"].([]interface{})
    additionalFeaturesServerConfigurations := v["additional_features_server_configurations"].([]interface{})

    result := sqlvirtualmachine.ServerConfigurationsManagementSettings{
        AdditionalFeaturesServerConfigurations: expandArmSqlVirtualMachineAdditionalFeaturesServerConfigurations(additionalFeaturesServerConfigurations),
        SqlConnectivityUpdateSettings: expandArmSqlVirtualMachineSqlConnectivityUpdateSettings(sqlConnectivityUpdateSettings),
        SqlStorageUpdateSettings: expandArmSqlVirtualMachineSqlStorageUpdateSettings(sqlStorageUpdateSettings),
        SqlWorkloadTypeUpdateSettings: expandArmSqlVirtualMachineSqlWorkloadTypeUpdateSettings(sqlWorkloadTypeUpdateSettings),
    }
    return &result
}

func expandArmSqlVirtualMachineStorageConfigurationSettings(input []interface{}) *sqlvirtualmachine.StorageConfigurationSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    sqlDataSettings := v["sql_data_settings"].([]interface{})
    sqlLogSettings := v["sql_log_settings"].([]interface{})
    sqlTempDbSettings := v["sql_temp_db_settings"].([]interface{})
    diskConfigurationType := v["disk_configuration_type"].(string)
    storageWorkloadType := v["storage_workload_type"].(string)

    result := sqlvirtualmachine.StorageConfigurationSettings{
        DiskConfigurationType: sqlvirtualmachine.DiskConfigurationType(diskConfigurationType),
        SqlDataSettings: expandArmSqlVirtualMachineSQLStorageSettings(sqlDataSettings),
        SqlLogSettings: expandArmSqlVirtualMachineSQLStorageSettings(sqlLogSettings),
        SqlTempDbSettings: expandArmSqlVirtualMachineSQLStorageSettings(sqlTempDbSettings),
        StorageWorkloadType: sqlvirtualmachine.StorageWorkloadType(storageWorkloadType),
    }
    return &result
}

func expandArmSqlVirtualMachineWsfcDomainCredentials(input []interface{}) *sqlvirtualmachine.WsfcDomainCredentials {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    clusterBootstrapAccountPassword := v["cluster_bootstrap_account_password"].(string)
    clusterOperatorAccountPassword := v["cluster_operator_account_password"].(string)
    sqlServiceAccountPassword := v["sql_service_account_password"].(string)

    result := sqlvirtualmachine.WsfcDomainCredentials{
        ClusterBootstrapAccountPassword: utils.String(clusterBootstrapAccountPassword),
        ClusterOperatorAccountPassword: utils.String(clusterOperatorAccountPassword),
        SqlServiceAccountPassword: utils.String(sqlServiceAccountPassword),
    }
    return &result
}

func expandArmSqlVirtualMachineAdditionalFeaturesServerConfigurations(input []interface{}) *sqlvirtualmachine.AdditionalFeaturesServerConfigurations {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    isRservicesEnabled := v["is_rservices_enabled"].(bool)

    result := sqlvirtualmachine.AdditionalFeaturesServerConfigurations{
        IsRservicesEnabled: utils.Bool(isRservicesEnabled),
    }
    return &result
}

func expandArmSqlVirtualMachineSqlConnectivityUpdateSettings(input []interface{}) *sqlvirtualmachine.SqlConnectivityUpdateSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    connectivityType := v["connectivity_type"].(string)
    port := v["port"].(int)
    sqlAuthUpdateUserName := v["sql_auth_update_user_name"].(string)
    sqlAuthUpdatePassword := v["sql_auth_update_password"].(string)

    result := sqlvirtualmachine.SqlConnectivityUpdateSettings{
        ConnectivityType: sqlvirtualmachine.ConnectivityType(connectivityType),
        Port: utils.Int32(int32(port)),
        SqlAuthUpdatePassword: utils.String(sqlAuthUpdatePassword),
        SqlAuthUpdateUserName: utils.String(sqlAuthUpdateUserName),
    }
    return &result
}

func expandArmSqlVirtualMachineSqlStorageUpdateSettings(input []interface{}) *sqlvirtualmachine.SqlStorageUpdateSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    diskCount := v["disk_count"].(int)
    startingDeviceId := v["starting_device_id"].(int)
    diskConfigurationType := v["disk_configuration_type"].(string)

    result := sqlvirtualmachine.SqlStorageUpdateSettings{
        DiskConfigurationType: sqlvirtualmachine.DiskConfigurationType(diskConfigurationType),
        DiskCount: utils.Int32(int32(diskCount)),
        StartingDeviceID: utils.Int32(int32(startingDeviceId)),
    }
    return &result
}

func expandArmSqlVirtualMachineSqlWorkloadTypeUpdateSettings(input []interface{}) *sqlvirtualmachine.SqlWorkloadTypeUpdateSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    sqlWorkloadType := v["sql_workload_type"].(string)

    result := sqlvirtualmachine.SqlWorkloadTypeUpdateSettings{
        SqlWorkloadType: sqlvirtualmachine.SqlWorkloadType(sqlWorkloadType),
    }
    return &result
}

func expandArmSqlVirtualMachineSQLStorageSettings(input []interface{}) *sqlvirtualmachine.SQLStorageSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    luns := v["luns"].([]interface{})
    defaultFilePath := v["default_file_path"].(string)

    result := sqlvirtualmachine.SQLStorageSettings{
        DefaultFilePath: utils.String(defaultFilePath),
        Luns: utils.ExpandInteger32Slice(luns),
    }
    return &result
}


func flattenArmSqlVirtualMachineAutoBackupSettings(input *sqlvirtualmachine.AutoBackupSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["backup_schedule_type"] = string(input.BackupScheduleType)
    if backupSystemDbs := input.BackupSystemDbs; backupSystemDbs != nil {
        result["backup_system_dbs"] = *backupSystemDbs
    }
    if enable := input.Enable; enable != nil {
        result["enable"] = *enable
    }
    if enableEncryption := input.EnableEncryption; enableEncryption != nil {
        result["enable_encryption"] = *enableEncryption
    }
    result["full_backup_frequency"] = string(input.FullBackupFrequency)
    if fullBackupStartTime := input.FullBackupStartTime; fullBackupStartTime != nil {
        result["full_backup_start_time"] = int(*fullBackupStartTime)
    }
    if fullBackupWindowHours := input.FullBackupWindowHours; fullBackupWindowHours != nil {
        result["full_backup_window_hours"] = int(*fullBackupWindowHours)
    }
    if logBackupFrequency := input.LogBackupFrequency; logBackupFrequency != nil {
        result["log_backup_frequency"] = int(*logBackupFrequency)
    }
    if password := input.Password; password != nil {
        result["password"] = *password
    }
    if retentionPeriod := input.RetentionPeriod; retentionPeriod != nil {
        result["retention_period"] = int(*retentionPeriod)
    }
    if storageAccessKey := input.StorageAccessKey; storageAccessKey != nil {
        result["storage_access_key"] = *storageAccessKey
    }
    if storageAccountUrl := input.StorageAccountURL; storageAccountUrl != nil {
        result["storage_account_url"] = *storageAccountUrl
    }

    return []interface{}{result}
}

func flattenArmSqlVirtualMachineAutoPatchingSettings(input *sqlvirtualmachine.AutoPatchingSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["day_of_week"] = string(input.DayOfWeek)
    if enable := input.Enable; enable != nil {
        result["enable"] = *enable
    }
    if maintenanceWindowDuration := input.MaintenanceWindowDuration; maintenanceWindowDuration != nil {
        result["maintenance_window_duration"] = int(*maintenanceWindowDuration)
    }
    if maintenanceWindowStartingHour := input.MaintenanceWindowStartingHour; maintenanceWindowStartingHour != nil {
        result["maintenance_window_starting_hour"] = int(*maintenanceWindowStartingHour)
    }

    return []interface{}{result}
}

func flattenArmSqlVirtualMachineKeyVaultCredentialSettings(input *sqlvirtualmachine.KeyVaultCredentialSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if azureKeyVaultUrl := input.AzureKeyVaultURL; azureKeyVaultUrl != nil {
        result["azure_key_vault_url"] = *azureKeyVaultUrl
    }
    if credentialName := input.CredentialName; credentialName != nil {
        result["credential_name"] = *credentialName
    }
    if enable := input.Enable; enable != nil {
        result["enable"] = *enable
    }
    if servicePrincipalName := input.ServicePrincipalName; servicePrincipalName != nil {
        result["service_principal_name"] = *servicePrincipalName
    }
    if servicePrincipalSecret := input.ServicePrincipalSecret; servicePrincipalSecret != nil {
        result["service_principal_secret"] = *servicePrincipalSecret
    }

    return []interface{}{result}
}

func flattenArmSqlVirtualMachineServerConfigurationsManagementSettings(input *sqlvirtualmachine.ServerConfigurationsManagementSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["additional_features_server_configurations"] = flattenArmSqlVirtualMachineAdditionalFeaturesServerConfigurations(input.AdditionalFeaturesServerConfigurations)
    result["sql_connectivity_update_settings"] = flattenArmSqlVirtualMachineSqlConnectivityUpdateSettings(input.SqlConnectivityUpdateSettings)
    result["sql_storage_update_settings"] = flattenArmSqlVirtualMachineSqlStorageUpdateSettings(input.SqlStorageUpdateSettings)
    result["sql_workload_type_update_settings"] = flattenArmSqlVirtualMachineSqlWorkloadTypeUpdateSettings(input.SqlWorkloadTypeUpdateSettings)

    return []interface{}{result}
}

func flattenArmSqlVirtualMachineStorageConfigurationSettings(input *sqlvirtualmachine.StorageConfigurationSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["disk_configuration_type"] = string(input.DiskConfigurationType)
    result["sql_data_settings"] = flattenArmSqlVirtualMachineSQLStorageSettings(input.SqlDataSettings)
    result["sql_log_settings"] = flattenArmSqlVirtualMachineSQLStorageSettings(input.SqlLogSettings)
    result["sql_temp_db_settings"] = flattenArmSqlVirtualMachineSQLStorageSettings(input.SqlTempDbSettings)
    result["storage_workload_type"] = string(input.StorageWorkloadType)

    return []interface{}{result}
}

func flattenArmSqlVirtualMachineWsfcDomainCredentials(input *sqlvirtualmachine.WsfcDomainCredentials) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if clusterBootstrapAccountPassword := input.ClusterBootstrapAccountPassword; clusterBootstrapAccountPassword != nil {
        result["cluster_bootstrap_account_password"] = *clusterBootstrapAccountPassword
    }
    if clusterOperatorAccountPassword := input.ClusterOperatorAccountPassword; clusterOperatorAccountPassword != nil {
        result["cluster_operator_account_password"] = *clusterOperatorAccountPassword
    }
    if sqlServiceAccountPassword := input.SqlServiceAccountPassword; sqlServiceAccountPassword != nil {
        result["sql_service_account_password"] = *sqlServiceAccountPassword
    }

    return []interface{}{result}
}

func flattenArmSqlVirtualMachineResourceIdentity(input *sqlvirtualmachine.ResourceIdentity) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["type"] = string(input.Type)

    return []interface{}{result}
}

func flattenArmSqlVirtualMachineAdditionalFeaturesServerConfigurations(input *sqlvirtualmachine.AdditionalFeaturesServerConfigurations) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if isRservicesEnabled := input.IsRservicesEnabled; isRservicesEnabled != nil {
        result["is_rservices_enabled"] = *isRservicesEnabled
    }

    return []interface{}{result}
}

func flattenArmSqlVirtualMachineSqlConnectivityUpdateSettings(input *sqlvirtualmachine.SqlConnectivityUpdateSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["connectivity_type"] = string(input.ConnectivityType)
    if port := input.Port; port != nil {
        result["port"] = int(*port)
    }
    if sqlAuthUpdatePassword := input.SqlAuthUpdatePassword; sqlAuthUpdatePassword != nil {
        result["sql_auth_update_password"] = *sqlAuthUpdatePassword
    }
    if sqlAuthUpdateUserName := input.SqlAuthUpdateUserName; sqlAuthUpdateUserName != nil {
        result["sql_auth_update_user_name"] = *sqlAuthUpdateUserName
    }

    return []interface{}{result}
}

func flattenArmSqlVirtualMachineSqlStorageUpdateSettings(input *sqlvirtualmachine.SqlStorageUpdateSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["disk_configuration_type"] = string(input.DiskConfigurationType)
    if diskCount := input.DiskCount; diskCount != nil {
        result["disk_count"] = int(*diskCount)
    }
    if startingDeviceId := input.StartingDeviceID; startingDeviceId != nil {
        result["starting_device_id"] = int(*startingDeviceId)
    }

    return []interface{}{result}
}

func flattenArmSqlVirtualMachineSqlWorkloadTypeUpdateSettings(input *sqlvirtualmachine.SqlWorkloadTypeUpdateSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["sql_workload_type"] = string(input.SqlWorkloadType)

    return []interface{}{result}
}

func flattenArmSqlVirtualMachineSQLStorageSettings(input *sqlvirtualmachine.SQLStorageSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if defaultFilePath := input.DefaultFilePath; defaultFilePath != nil {
        result["default_file_path"] = *defaultFilePath
    }
    result["luns"] = utils.FlattenInteger32Slice(input.Luns)

    return []interface{}{result}
}
