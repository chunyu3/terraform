// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmJob() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmJobCreateUpdate,
        Read: resourceArmJobRead,
        Update: resourceArmJobCreateUpdate,
        Delete: resourceArmJobDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "cluster": {
                Type: schema.TypeList,
                Required: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "id": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "job_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "node_count": {
                Type: schema.TypeInt,
                Required: true,
            },

            "std_out_err_path_prefix": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "caffe2settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "python_script_file_path": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "python_interpreter_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "caffe_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "config_file_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "process_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "python_interpreter_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "python_script_file_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "chainer_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "python_script_file_path": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "process_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "python_interpreter_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "cntk_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "config_file_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "language_type": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "process_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "python_interpreter_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "python_script_file_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "constraints": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "max_wall_clock_time": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateIso8601Duration(),
                        },
                    },
                },
            },

            "container_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "image_source_registry": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "image": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "credentials": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "username": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "password": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "server_url": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "custom_toolkit_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "command_line": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "environment_variables": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "value": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "experiment_name": {
                Type: schema.TypeString,
                Optional: true,
            },

            "input_directories": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "id": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "path": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "job_preparation": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "command_line": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "output_directories": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "id": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "path_prefix": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "create_new": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "path_suffix": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "type": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(batchaisdk.model),
                                string(batchaisdk.logs),
                                string(batchaisdk.summary),
                                string(batchaisdk.custom),
                            }, false),
                            Default: string(batchaisdk.model),
                        },
                    },
                },
            },

            "priority": {
                Type: schema.TypeInt,
                Optional: true,
            },

            "tensor_flow_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "master_command_line_args": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "python_script_file_path": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "parameter_server_command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "parameter_server_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "python_interpreter_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "worker_command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "worker_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                    },
                },
            },

            "creation_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "execution_info": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "start_time": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                            ValidateFunc: validateRFC3339Date,
                        },
                        "end_time": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateRFC3339Date,
                        },
                        "errors": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "code": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "details": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "value": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "message": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "exit_code": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                    },
                },
            },

            "execution_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "execution_state_transition_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "provisioning_state_transition_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tool_type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmJobCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).jobsClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    jobName := d.Get("job_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, jobName)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_job", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    caffe2settings := d.Get("caffe2settings").([]interface{})
    caffeSettings := d.Get("caffe_settings").([]interface{})
    chainerSettings := d.Get("chainer_settings").([]interface{})
    cluster := d.Get("cluster").([]interface{})
    cntkSettings := d.Get("cntk_settings").([]interface{})
    constraints := d.Get("constraints").([]interface{})
    containerSettings := d.Get("container_settings").([]interface{})
    customToolkitSettings := d.Get("custom_toolkit_settings").([]interface{})
    environmentVariables := d.Get("environment_variables").([]interface{})
    experimentName := d.Get("experiment_name").(string)
    inputDirectories := d.Get("input_directories").([]interface{})
    jobPreparation := d.Get("job_preparation").([]interface{})
    nodeCount := d.Get("node_count").(int)
    outputDirectories := d.Get("output_directories").([]interface{})
    priority := d.Get("priority").(int)
    stdOutErrPathPrefix := d.Get("std_out_err_path_prefix").(string)
    tensorFlowSettings := d.Get("tensor_flow_settings").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    parameters := batchaisdk.JobCreateParameters{
        Location: utils.String(location),
        JobBaseProperties: &batchaisdk.JobBaseProperties{
            Caffe2settings: expandArmJobCaffe2Settings(caffe2settings),
            CaffeSettings: expandArmJobCaffeSettings(caffeSettings),
            ChainerSettings: expandArmJobChainerSettings(chainerSettings),
            Cluster: expandArmJobResourceId(cluster),
            CntkSettings: expandArmJobCNTKsettings(cntkSettings),
            Constraints: expandArmJobJobBaseProperties_constraints(constraints),
            ContainerSettings: expandArmJobContainerSettings(containerSettings),
            CustomToolkitSettings: expandArmJobCustomToolkitSettings(customToolkitSettings),
            EnvironmentVariables: expandArmJobEnvironmentSetting(environmentVariables),
            ExperimentName: utils.String(experimentName),
            InputDirectories: expandArmJobInputDirectory(inputDirectories),
            JobPreparation: expandArmJobJobPreparation(jobPreparation),
            NodeCount: utils.Int32(int32(nodeCount)),
            OutputDirectories: expandArmJobOutputDirectory(outputDirectories),
            Priority: utils.Int32(int32(priority)),
            StdOutErrPathPrefix: utils.String(stdOutErrPathPrefix),
            TensorFlowSettings: expandArmJobTensorFlowSettings(tensorFlowSettings),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.Create(ctx, resourceGroup, jobName, parameters)
    if err != nil {
        return fmt.Errorf("Error creating Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, jobName)
    if err != nil {
        return fmt.Errorf("Error retrieving Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Job (Job Name %q / Resource Group %q) ID", jobName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmJobRead(d, meta)
}

func resourceArmJobRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).jobsClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    jobName := id.Path["jobs"]

    resp, err := client.Get(ctx, resourceGroup, jobName)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Job %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
    }


    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    if jobBaseProperties := resp.JobBaseProperties; jobBaseProperties != nil {
        if err := d.Set("caffe_settings", flattenArmJobCaffeSettings(jobBaseProperties.CaffeSettings)); err != nil {
            return fmt.Errorf("Error setting `caffe_settings`: %+v", err)
        }
        if err := d.Set("chainer_settings", flattenArmJobChainerSettings(jobBaseProperties.ChainerSettings)); err != nil {
            return fmt.Errorf("Error setting `chainer_settings`: %+v", err)
        }
        if err := d.Set("cluster", flattenArmJobResourceId(jobBaseProperties.Cluster)); err != nil {
            return fmt.Errorf("Error setting `cluster`: %+v", err)
        }
        if err := d.Set("cntk_settings", flattenArmJobCNTKsettings(jobBaseProperties.CntkSettings)); err != nil {
            return fmt.Errorf("Error setting `cntk_settings`: %+v", err)
        }
        if err := d.Set("constraints", flattenArmJobJobBaseProperties_constraints(jobBaseProperties.Constraints)); err != nil {
            return fmt.Errorf("Error setting `constraints`: %+v", err)
        }
        if err := d.Set("container_settings", flattenArmJobContainerSettings(jobBaseProperties.ContainerSettings)); err != nil {
            return fmt.Errorf("Error setting `container_settings`: %+v", err)
        }
        d.Set("creation_time", (jobBaseProperties.CreationTime).String())
        if err := d.Set("custom_toolkit_settings", flattenArmJobCustomToolkitSettings(jobBaseProperties.CustomToolkitSettings)); err != nil {
            return fmt.Errorf("Error setting `custom_toolkit_settings`: %+v", err)
        }
        if err := d.Set("environment_variables", flattenArmJobEnvironmentSetting(jobBaseProperties.EnvironmentVariables)); err != nil {
            return fmt.Errorf("Error setting `environment_variables`: %+v", err)
        }
        if err := d.Set("execution_info", flattenArmJobJobProperties_executionInfo(jobBaseProperties.ExecutionInfo)); err != nil {
            return fmt.Errorf("Error setting `execution_info`: %+v", err)
        }
        d.Set("execution_state", string(jobBaseProperties.ExecutionState))
        d.Set("execution_state_transition_time", (jobBaseProperties.ExecutionStateTransitionTime).String())
        d.Set("experiment_name", jobBaseProperties.ExperimentName)
        if err := d.Set("input_directories", flattenArmJobInputDirectory(jobBaseProperties.InputDirectories)); err != nil {
            return fmt.Errorf("Error setting `input_directories`: %+v", err)
        }
        if err := d.Set("job_preparation", flattenArmJobJobPreparation(jobBaseProperties.JobPreparation)); err != nil {
            return fmt.Errorf("Error setting `job_preparation`: %+v", err)
        }
        d.Set("node_count", int(*jobBaseProperties.NodeCount))
        if err := d.Set("output_directories", flattenArmJobOutputDirectory(jobBaseProperties.OutputDirectories)); err != nil {
            return fmt.Errorf("Error setting `output_directories`: %+v", err)
        }
        d.Set("priority", int(*jobBaseProperties.Priority))
        d.Set("provisioning_state", string(jobBaseProperties.ProvisioningState))
        d.Set("provisioning_state_transition_time", (jobBaseProperties.ProvisioningStateTransitionTime).String())
        d.Set("std_out_err_path_prefix", jobBaseProperties.StdOutErrPathPrefix)
        if err := d.Set("tensor_flow_settings", flattenArmJobTensorFlowSettings(jobBaseProperties.TensorFlowSettings)); err != nil {
            return fmt.Errorf("Error setting `tensor_flow_settings`: %+v", err)
        }
        d.Set("tool_type", string(jobBaseProperties.ToolType))
    }
    d.Set("job_name", jobName)
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}


func resourceArmJobDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).jobsClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    jobName := id.Path["jobs"]

    future, err := client.Delete(ctx, resourceGroup, jobName)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
        }
    }

    return nil
}

func expandArmJobCaffe2Settings(input []interface{}) *batchaisdk.Caffe2Settings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    pythonScriptFilePath := v["python_script_file_path"].(string)
    pythonInterpreterPath := v["python_interpreter_path"].(string)
    commandLineArgs := v["command_line_args"].(string)

    result := batchaisdk.Caffe2Settings{
        CommandLineArgs: utils.String(commandLineArgs),
        PythonInterpreterPath: utils.String(pythonInterpreterPath),
        PythonScriptFilePath: utils.String(pythonScriptFilePath),
    }
    return &result
}

func expandArmJobCaffeSettings(input []interface{}) *batchaisdk.CaffeSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    configFilePath := v["config_file_path"].(string)
    pythonScriptFilePath := v["python_script_file_path"].(string)
    pythonInterpreterPath := v["python_interpreter_path"].(string)
    commandLineArgs := v["command_line_args"].(string)
    processCount := v["process_count"].(int)

    result := batchaisdk.CaffeSettings{
        CommandLineArgs: utils.String(commandLineArgs),
        ConfigFilePath: utils.String(configFilePath),
        ProcessCount: utils.Int32(int32(processCount)),
        PythonInterpreterPath: utils.String(pythonInterpreterPath),
        PythonScriptFilePath: utils.String(pythonScriptFilePath),
    }
    return &result
}

func expandArmJobChainerSettings(input []interface{}) *batchaisdk.ChainerSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    pythonScriptFilePath := v["python_script_file_path"].(string)
    pythonInterpreterPath := v["python_interpreter_path"].(string)
    commandLineArgs := v["command_line_args"].(string)
    processCount := v["process_count"].(int)

    result := batchaisdk.ChainerSettings{
        CommandLineArgs: utils.String(commandLineArgs),
        ProcessCount: utils.Int32(int32(processCount)),
        PythonInterpreterPath: utils.String(pythonInterpreterPath),
        PythonScriptFilePath: utils.String(pythonScriptFilePath),
    }
    return &result
}

func expandArmJobResourceId(input []interface{}) *batchaisdk.ResourceId {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    id := v["id"].(string)

    result := batchaisdk.ResourceId{
        ID: utils.String(id),
    }
    return &result
}

func expandArmJobCNTKsettings(input []interface{}) *batchaisdk.CNTKsettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    languageType := v["language_type"].(string)
    configFilePath := v["config_file_path"].(string)
    pythonScriptFilePath := v["python_script_file_path"].(string)
    pythonInterpreterPath := v["python_interpreter_path"].(string)
    commandLineArgs := v["command_line_args"].(string)
    processCount := v["process_count"].(int)

    result := batchaisdk.CNTKsettings{
        CommandLineArgs: utils.String(commandLineArgs),
        ConfigFilePath: utils.String(configFilePath),
        LanguageType: utils.String(languageType),
        ProcessCount: utils.Int32(int32(processCount)),
        PythonInterpreterPath: utils.String(pythonInterpreterPath),
        PythonScriptFilePath: utils.String(pythonScriptFilePath),
    }
    return &result
}

func expandArmJobJobBaseProperties_constraints(input []interface{}) *batchaisdk.JobBaseProperties_constraints {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    maxWallClockTime := v["max_wall_clock_time"].(string)

    result := batchaisdk.JobBaseProperties_constraints{
        MaxWallClockTime: utils.String(maxWallClockTime),
    }
    return &result
}

func expandArmJobContainerSettings(input []interface{}) *batchaisdk.ContainerSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    imageSourceRegistry := v["image_source_registry"].([]interface{})

    result := batchaisdk.ContainerSettings{
        ImageSourceRegistry: expandArmJobImageSourceRegistry(imageSourceRegistry),
    }
    return &result
}

func expandArmJobCustomToolkitSettings(input []interface{}) *batchaisdk.CustomToolkitSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    commandLine := v["command_line"].(string)

    result := batchaisdk.CustomToolkitSettings{
        CommandLine: utils.String(commandLine),
    }
    return &result
}

func expandArmJobEnvironmentSetting(input []interface{}) *[]batchaisdk.EnvironmentSetting {
    results := make([]batchaisdk.EnvironmentSetting, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        value := v["value"].(string)

        result := batchaisdk.EnvironmentSetting{
            Name: utils.String(name),
            Value: utils.String(value),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmJobInputDirectory(input []interface{}) *[]batchaisdk.InputDirectory {
    results := make([]batchaisdk.InputDirectory, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        path := v["path"].(string)

        result := batchaisdk.InputDirectory{
            ID: utils.String(id),
            Path: utils.String(path),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmJobJobPreparation(input []interface{}) *batchaisdk.JobPreparation {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    commandLine := v["command_line"].(string)

    result := batchaisdk.JobPreparation{
        CommandLine: utils.String(commandLine),
    }
    return &result
}

func expandArmJobOutputDirectory(input []interface{}) *[]batchaisdk.OutputDirectory {
    results := make([]batchaisdk.OutputDirectory, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        pathPrefix := v["path_prefix"].(string)
        pathSuffix := v["path_suffix"].(string)
        type := v["type"].(string)
        createNew := v["create_new"].(bool)

        result := batchaisdk.OutputDirectory{
            CreateNew: utils.Bool(createNew),
            ID: utils.String(id),
            PathPrefix: utils.String(pathPrefix),
            PathSuffix: utils.String(pathSuffix),
            Type: batchaisdk.OutputType(type),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmJobTensorFlowSettings(input []interface{}) *batchaisdk.TensorFlowSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    pythonScriptFilePath := v["python_script_file_path"].(string)
    pythonInterpreterPath := v["python_interpreter_path"].(string)
    masterCommandLineArgs := v["master_command_line_args"].(string)
    workerCommandLineArgs := v["worker_command_line_args"].(string)
    parameterServerCommandLineArgs := v["parameter_server_command_line_args"].(string)
    workerCount := v["worker_count"].(int)
    parameterServerCount := v["parameter_server_count"].(int)

    result := batchaisdk.TensorFlowSettings{
        MasterCommandLineArgs: utils.String(masterCommandLineArgs),
        ParameterServerCommandLineArgs: utils.String(parameterServerCommandLineArgs),
        ParameterServerCount: utils.Int32(int32(parameterServerCount)),
        PythonInterpreterPath: utils.String(pythonInterpreterPath),
        PythonScriptFilePath: utils.String(pythonScriptFilePath),
        WorkerCommandLineArgs: utils.String(workerCommandLineArgs),
        WorkerCount: utils.Int32(int32(workerCount)),
    }
    return &result
}

func expandArmJobImageSourceRegistry(input []interface{}) *batchaisdk.ImageSourceRegistry {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    serverUrl := v["server_url"].(string)
    image := v["image"].(string)
    credentials := v["credentials"].([]interface{})

    result := batchaisdk.ImageSourceRegistry{
        Credentials: expandArmJobPrivateRegistryCredentials(credentials),
        Image: utils.String(image),
        ServerURL: utils.String(serverUrl),
    }
    return &result
}

func expandArmJobPrivateRegistryCredentials(input []interface{}) *batchaisdk.PrivateRegistryCredentials {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    username := v["username"].(string)
    password := v["password"].(string)

    result := batchaisdk.PrivateRegistryCredentials{
        Password: utils.String(password),
        Username: utils.String(username),
    }
    return &result
}


func flattenArmJobCaffeSettings(input *batchaisdk.CaffeSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLineArgs := input.CommandLineArgs; commandLineArgs != nil {
        result["command_line_args"] = *commandLineArgs
    }
    if configFilePath := input.ConfigFilePath; configFilePath != nil {
        result["config_file_path"] = *configFilePath
    }
    if processCount := input.ProcessCount; processCount != nil {
        result["process_count"] = int(*processCount)
    }
    if pythonInterpreterPath := input.PythonInterpreterPath; pythonInterpreterPath != nil {
        result["python_interpreter_path"] = *pythonInterpreterPath
    }
    if pythonScriptFilePath := input.PythonScriptFilePath; pythonScriptFilePath != nil {
        result["python_script_file_path"] = *pythonScriptFilePath
    }

    return []interface{}{result}
}

func flattenArmJobChainerSettings(input *batchaisdk.ChainerSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLineArgs := input.CommandLineArgs; commandLineArgs != nil {
        result["command_line_args"] = *commandLineArgs
    }
    if processCount := input.ProcessCount; processCount != nil {
        result["process_count"] = int(*processCount)
    }
    if pythonInterpreterPath := input.PythonInterpreterPath; pythonInterpreterPath != nil {
        result["python_interpreter_path"] = *pythonInterpreterPath
    }
    if pythonScriptFilePath := input.PythonScriptFilePath; pythonScriptFilePath != nil {
        result["python_script_file_path"] = *pythonScriptFilePath
    }

    return []interface{}{result}
}

func flattenArmJobResourceId(input *batchaisdk.ResourceId) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if id := input.ID; id != nil {
        result["id"] = *id
    }

    return []interface{}{result}
}

func flattenArmJobCNTKsettings(input *batchaisdk.CNTKsettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLineArgs := input.CommandLineArgs; commandLineArgs != nil {
        result["command_line_args"] = *commandLineArgs
    }
    if configFilePath := input.ConfigFilePath; configFilePath != nil {
        result["config_file_path"] = *configFilePath
    }
    if languageType := input.LanguageType; languageType != nil {
        result["language_type"] = *languageType
    }
    if processCount := input.ProcessCount; processCount != nil {
        result["process_count"] = int(*processCount)
    }
    if pythonInterpreterPath := input.PythonInterpreterPath; pythonInterpreterPath != nil {
        result["python_interpreter_path"] = *pythonInterpreterPath
    }
    if pythonScriptFilePath := input.PythonScriptFilePath; pythonScriptFilePath != nil {
        result["python_script_file_path"] = *pythonScriptFilePath
    }

    return []interface{}{result}
}

func flattenArmJobJobBaseProperties_constraints(input *batchaisdk.JobBaseProperties_constraints) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if maxWallClockTime := input.MaxWallClockTime; maxWallClockTime != nil {
        result["max_wall_clock_time"] = *maxWallClockTime
    }

    return []interface{}{result}
}

func flattenArmJobContainerSettings(input *batchaisdk.ContainerSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["image_source_registry"] = flattenArmJobImageSourceRegistry(input.ImageSourceRegistry)

    return []interface{}{result}
}

func flattenArmJobCustomToolkitSettings(input *batchaisdk.CustomToolkitSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLine := input.CommandLine; commandLine != nil {
        result["command_line"] = *commandLine
    }

    return []interface{}{result}
}

func flattenArmJobEnvironmentSetting(input *[]batchaisdk.EnvironmentSetting) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if value := item.Value; value != nil {
            v["value"] = *value
        }

        results = append(results, v)
    }

    return results
}

func flattenArmJobJobProperties_executionInfo(input *batchaisdk.JobProperties_executionInfo) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})


    return []interface{}{result}
}

func flattenArmJobInputDirectory(input *[]batchaisdk.InputDirectory) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }
        if path := item.Path; path != nil {
            v["path"] = *path
        }

        results = append(results, v)
    }

    return results
}

func flattenArmJobJobPreparation(input *batchaisdk.JobPreparation) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLine := input.CommandLine; commandLine != nil {
        result["command_line"] = *commandLine
    }

    return []interface{}{result}
}

func flattenArmJobOutputDirectory(input *[]batchaisdk.OutputDirectory) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }
        if createNew := item.CreateNew; createNew != nil {
            v["create_new"] = *createNew
        }
        if pathPrefix := item.PathPrefix; pathPrefix != nil {
            v["path_prefix"] = *pathPrefix
        }
        if pathSuffix := item.PathSuffix; pathSuffix != nil {
            v["path_suffix"] = *pathSuffix
        }
        v["type"] = string(item.Type)

        results = append(results, v)
    }

    return results
}

func flattenArmJobTensorFlowSettings(input *batchaisdk.TensorFlowSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if masterCommandLineArgs := input.MasterCommandLineArgs; masterCommandLineArgs != nil {
        result["master_command_line_args"] = *masterCommandLineArgs
    }
    if parameterServerCommandLineArgs := input.ParameterServerCommandLineArgs; parameterServerCommandLineArgs != nil {
        result["parameter_server_command_line_args"] = *parameterServerCommandLineArgs
    }
    if parameterServerCount := input.ParameterServerCount; parameterServerCount != nil {
        result["parameter_server_count"] = int(*parameterServerCount)
    }
    if pythonInterpreterPath := input.PythonInterpreterPath; pythonInterpreterPath != nil {
        result["python_interpreter_path"] = *pythonInterpreterPath
    }
    if pythonScriptFilePath := input.PythonScriptFilePath; pythonScriptFilePath != nil {
        result["python_script_file_path"] = *pythonScriptFilePath
    }
    if workerCommandLineArgs := input.WorkerCommandLineArgs; workerCommandLineArgs != nil {
        result["worker_command_line_args"] = *workerCommandLineArgs
    }
    if workerCount := input.WorkerCount; workerCount != nil {
        result["worker_count"] = int(*workerCount)
    }

    return []interface{}{result}
}

func flattenArmJobImageSourceRegistry(input *batchaisdk.ImageSourceRegistry) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["credentials"] = flattenArmJobPrivateRegistryCredentials(input.Credentials)
    if image := input.Image; image != nil {
        result["image"] = *image
    }
    if serverUrl := input.ServerURL; serverUrl != nil {
        result["server_url"] = *serverUrl
    }

    return []interface{}{result}
}

func flattenArmJobPrivateRegistryCredentials(input *batchaisdk.PrivateRegistryCredentials) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if password := input.Password; password != nil {
        result["password"] = *password
    }
    if username := input.Username; username != nil {
        result["username"] = *username
    }

    return []interface{}{result}
}
