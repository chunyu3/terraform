// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm



func resourceArmJob() *schema.Resource {
    return &schema.Resource{
        Create: resourceArmJobCreateUpdate,
        Read: resourceArmJobRead,
        Update: resourceArmJobCreateUpdate,
        Delete: resourceArmJobDelete,

        Importer: &schema.ResourceImporter{
            State: schema.ImportStatePassthrough,
        },


        Schema: map[string]*schema.Schema{
            "name": {
                Type: schema.TypeString,
                Computed: true,
            },

            "location": azure.SchemaLocation(),

            "resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

            "cluster": {
                Type: schema.TypeList,
                Required: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "id": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "job_name": {
                Type: schema.TypeString,
                Required: true,
                ForceNew: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "node_count": {
                Type: schema.TypeInt,
                Required: true,
            },

            "std_out_err_path_prefix": {
                Type: schema.TypeString,
                Required: true,
                ValidateFunc: validate.NoEmptyStrings,
            },

            "caffe2settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "python_script_file_path": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "python_interpreter_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "caffe_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "config_file_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "process_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "python_interpreter_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "python_script_file_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "chainer_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "python_script_file_path": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "process_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "python_interpreter_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "cntk_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "config_file_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "language_type": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "process_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "python_interpreter_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "python_script_file_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "constraints": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "max_wall_clock_time": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateIso8601Duration(),
                        },
                    },
                },
            },

            "container_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "image_source_registry": {
                            Type: schema.TypeList,
                            Required: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "image": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "credentials": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "username": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                                "password": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "server_url": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "custom_toolkit_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "command_line": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "environment_variables": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "value": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "experiment_name": {
                Type: schema.TypeString,
                Optional: true,
            },

            "input_directories": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "id": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "path": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "job_preparation": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "command_line": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                    },
                },
            },

            "mount_volumes": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "azure_blob_file_systems": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "account_name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "container_name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "credentials": {
                                        Type: schema.TypeList,
                                        Required: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "account_key": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "relative_mount_path": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "mount_options": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "azure_file_shares": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "account_name": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "azure_file_url": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "credentials": {
                                        Type: schema.TypeList,
                                        Required: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "account_key": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "relative_mount_path": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "directory_mode": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "file_mode": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "file_servers": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "file_server": {
                                        Type: schema.TypeList,
                                        Required: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "id": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                            },
                                        },
                                    },
                                    "relative_mount_path": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "mount_options": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "source_directory": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "unmanaged_file_systems": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "mount_command": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "relative_mount_path": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "output_directories": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "id": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "path_prefix": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "create_new": {
                            Type: schema.TypeBool,
                            Optional: true,
                        },
                        "path_suffix": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "type": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validation.StringInSlice([]string{
                                string(batchaisdk.model),
                                string(batchaisdk.logs),
                                string(batchaisdk.summary),
                                string(batchaisdk.custom),
                            }, false),
                            Default: string(batchaisdk.model),
                        },
                    },
                },
            },

            "priority": {
                Type: schema.TypeInt,
                Optional: true,
            },

            "py_torch_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "python_script_file_path": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "communication_backend": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "process_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "python_interpreter_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                    },
                },
            },

            "secrets": {
                Type: schema.TypeList,
                Optional: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "name": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "value": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "value_secret_reference": {
                            Type: schema.TypeList,
                            Optional: true,
                            MaxItems: 1,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "secret_url": {
                                        Type: schema.TypeString,
                                        Required: true,
                                        ValidateFunc: validate.NoEmptyStrings,
                                    },
                                    "source_vault": {
                                        Type: schema.TypeList,
                                        Required: true,
                                        MaxItems: 1,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "id": {
                                                    Type: schema.TypeString,
                                                    Required: true,
                                                    ValidateFunc: validate.NoEmptyStrings,
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },

            "tensor_flow_settings": {
                Type: schema.TypeList,
                Optional: true,
                MaxItems: 1,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "python_script_file_path": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                        },
                        "master_command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "parameter_server_command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "parameter_server_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                        "python_interpreter_path": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "worker_command_line_args": {
                            Type: schema.TypeString,
                            Optional: true,
                        },
                        "worker_count": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                    },
                },
            },

            "creation_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "execution_info": {
                Type: schema.TypeList,
                Computed: true,
                Elem: &schema.Resource{
                    Schema: map[string]*schema.Schema{
                        "start_time": {
                            Type: schema.TypeString,
                            Required: true,
                            ValidateFunc: validate.NoEmptyStrings,
                            ValidateFunc: validateRFC3339Date,
                        },
                        "end_time": {
                            Type: schema.TypeString,
                            Optional: true,
                            ValidateFunc: validateRFC3339Date,
                        },
                        "errors": {
                            Type: schema.TypeList,
                            Optional: true,
                            Elem: &schema.Resource{
                                Schema: map[string]*schema.Schema{
                                    "code": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                    "details": {
                                        Type: schema.TypeList,
                                        Optional: true,
                                        Elem: &schema.Resource{
                                            Schema: map[string]*schema.Schema{
                                                "name": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                                "value": {
                                                    Type: schema.TypeString,
                                                    Optional: true,
                                                },
                                            },
                                        },
                                    },
                                    "message": {
                                        Type: schema.TypeString,
                                        Optional: true,
                                    },
                                },
                            },
                        },
                        "exit_code": {
                            Type: schema.TypeInt,
                            Optional: true,
                        },
                    },
                },
            },

            "execution_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "execution_state_transition_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "job_output_directory_path_segment": {
                Type: schema.TypeString,
                Computed: true,
            },

            "provisioning_state": {
                Type: schema.TypeString,
                Computed: true,
            },

            "provisioning_state_transition_time": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tool_type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "type": {
                Type: schema.TypeString,
                Computed: true,
            },

            "tags": tags.Schema(),
        },
    }
}

func resourceArmJobCreateUpdate(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).jobsClient
    ctx := meta.(*ArmClient).StopContext

    resourceGroup := d.Get("resource_group").(string)
    jobName := d.Get("job_name").(string)

    if features.ShouldResourcesBeImported() && d.IsNewResource() {
        existing, err := client.Get(ctx, resourceGroup, jobName)
        if err != nil {
            if !utils.ResponseWasNotFound(existing.Response) {
                return fmt.Errorf("Error checking for present of existing Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
            }
        }
        if existing.ID != nil && *existing.ID != "" {
            return tf.ImportAsExistsError("azurerm_job", *existing.ID)
        }
    }

    location := azure.NormalizeLocation(d.Get("location").(string))
    caffe2settings := d.Get("caffe2settings").([]interface{})
    caffeSettings := d.Get("caffe_settings").([]interface{})
    chainerSettings := d.Get("chainer_settings").([]interface{})
    cluster := d.Get("cluster").([]interface{})
    cntkSettings := d.Get("cntk_settings").([]interface{})
    constraints := d.Get("constraints").([]interface{})
    containerSettings := d.Get("container_settings").([]interface{})
    customToolkitSettings := d.Get("custom_toolkit_settings").([]interface{})
    environmentVariables := d.Get("environment_variables").([]interface{})
    experimentName := d.Get("experiment_name").(string)
    inputDirectories := d.Get("input_directories").([]interface{})
    jobPreparation := d.Get("job_preparation").([]interface{})
    mountVolumes := d.Get("mount_volumes").([]interface{})
    nodeCount := d.Get("node_count").(int)
    outputDirectories := d.Get("output_directories").([]interface{})
    priority := d.Get("priority").(int)
    pyTorchSettings := d.Get("py_torch_settings").([]interface{})
    secrets := d.Get("secrets").([]interface{})
    stdOutErrPathPrefix := d.Get("std_out_err_path_prefix").(string)
    tensorFlowSettings := d.Get("tensor_flow_settings").([]interface{})
    t := d.Get("tags").(map[string]interface{})

    parameters := batchaisdk.JobCreateParameters{
        Location: utils.String(location),
        JobBaseProperties: &batchaisdk.JobBaseProperties{
            Caffe2settings: expandArmJobCaffe2Settings(caffe2settings),
            CaffeSettings: expandArmJobCaffeSettings(caffeSettings),
            ChainerSettings: expandArmJobChainerSettings(chainerSettings),
            Cluster: expandArmJobResourceId(cluster),
            CntkSettings: expandArmJobCNTKsettings(cntkSettings),
            Constraints: expandArmJobJobBaseProperties_constraints(constraints),
            ContainerSettings: expandArmJobContainerSettings(containerSettings),
            CustomToolkitSettings: expandArmJobCustomToolkitSettings(customToolkitSettings),
            EnvironmentVariables: expandArmJobEnvironmentVariable(environmentVariables),
            ExperimentName: utils.String(experimentName),
            InputDirectories: expandArmJobInputDirectory(inputDirectories),
            JobPreparation: expandArmJobJobPreparation(jobPreparation),
            MountVolumes: expandArmJobMountVolumes(mountVolumes),
            NodeCount: utils.Int32(int32(nodeCount)),
            OutputDirectories: expandArmJobOutputDirectory(outputDirectories),
            Priority: utils.Int32(int32(priority)),
            PyTorchSettings: expandArmJobPyTorchSettings(pyTorchSettings),
            Secrets: expandArmJobEnvironmentVariableWithSecretValue(secrets),
            StdOutErrPathPrefix: utils.String(stdOutErrPathPrefix),
            TensorFlowSettings: expandArmJobTensorFlowSettings(tensorFlowSettings),
        },
        Tags: tags.Expand(t),
    }


    future, err := client.Create(ctx, resourceGroup, jobName, parameters)
    if err != nil {
        return fmt.Errorf("Error creating Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
    }
    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        return fmt.Errorf("Error waiting for creation of Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
    }


    resp, err := client.Get(ctx, resourceGroup, jobName)
    if err != nil {
        return fmt.Errorf("Error retrieving Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
    }
    if resp.ID == nil {
        return fmt.Errorf("Cannot read Job (Job Name %q / Resource Group %q) ID", jobName, resourceGroup)
    }
    d.SetId(*resp.ID)

    return resourceArmJobRead(d, meta)
}

func resourceArmJobRead(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).jobsClient
    ctx := meta.(*ArmClient).StopContext

    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    jobName := id.Path["jobs"]

    resp, err := client.Get(ctx, resourceGroup, jobName)
    if err != nil {
        if utils.ResponseWasNotFound(resp.Response) {
            log.Printf("[INFO] Job %q does not exist - removing from state", d.Id())
            d.SetId("")
            return nil
        }
        return fmt.Errorf("Error reading Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
    }


    d.Set("name", resp.Name)
    d.Set("resource_group", resourceGroup)
    if location := resp.Location; location != nil {
        d.Set("location", azure.NormalizeLocation(*location))
    }
    if jobBaseProperties := resp.JobBaseProperties; jobBaseProperties != nil {
        if err := d.Set("caffe_settings", flattenArmJobCaffeSettings(jobBaseProperties.CaffeSettings)); err != nil {
            return fmt.Errorf("Error setting `caffe_settings`: %+v", err)
        }
        if err := d.Set("chainer_settings", flattenArmJobChainerSettings(jobBaseProperties.ChainerSettings)); err != nil {
            return fmt.Errorf("Error setting `chainer_settings`: %+v", err)
        }
        if err := d.Set("cluster", flattenArmJobResourceId(jobBaseProperties.Cluster)); err != nil {
            return fmt.Errorf("Error setting `cluster`: %+v", err)
        }
        if err := d.Set("cntk_settings", flattenArmJobCNTKsettings(jobBaseProperties.CntkSettings)); err != nil {
            return fmt.Errorf("Error setting `cntk_settings`: %+v", err)
        }
        if err := d.Set("constraints", flattenArmJobJobBaseProperties_constraints(jobBaseProperties.Constraints)); err != nil {
            return fmt.Errorf("Error setting `constraints`: %+v", err)
        }
        if err := d.Set("container_settings", flattenArmJobContainerSettings(jobBaseProperties.ContainerSettings)); err != nil {
            return fmt.Errorf("Error setting `container_settings`: %+v", err)
        }
        d.Set("creation_time", (jobBaseProperties.CreationTime).String())
        if err := d.Set("custom_toolkit_settings", flattenArmJobCustomToolkitSettings(jobBaseProperties.CustomToolkitSettings)); err != nil {
            return fmt.Errorf("Error setting `custom_toolkit_settings`: %+v", err)
        }
        if err := d.Set("environment_variables", flattenArmJobEnvironmentVariable(jobBaseProperties.EnvironmentVariables)); err != nil {
            return fmt.Errorf("Error setting `environment_variables`: %+v", err)
        }
        if err := d.Set("execution_info", flattenArmJobJobProperties_executionInfo(jobBaseProperties.ExecutionInfo)); err != nil {
            return fmt.Errorf("Error setting `execution_info`: %+v", err)
        }
        d.Set("execution_state", string(jobBaseProperties.ExecutionState))
        d.Set("execution_state_transition_time", (jobBaseProperties.ExecutionStateTransitionTime).String())
        d.Set("experiment_name", jobBaseProperties.ExperimentName)
        if err := d.Set("input_directories", flattenArmJobInputDirectory(jobBaseProperties.InputDirectories)); err != nil {
            return fmt.Errorf("Error setting `input_directories`: %+v", err)
        }
        d.Set("job_output_directory_path_segment", jobBaseProperties.JobOutputDirectoryPathSegment)
        if err := d.Set("job_preparation", flattenArmJobJobPreparation(jobBaseProperties.JobPreparation)); err != nil {
            return fmt.Errorf("Error setting `job_preparation`: %+v", err)
        }
        if err := d.Set("mount_volumes", flattenArmJobMountVolumes(jobBaseProperties.MountVolumes)); err != nil {
            return fmt.Errorf("Error setting `mount_volumes`: %+v", err)
        }
        d.Set("node_count", int(*jobBaseProperties.NodeCount))
        if err := d.Set("output_directories", flattenArmJobOutputDirectory(jobBaseProperties.OutputDirectories)); err != nil {
            return fmt.Errorf("Error setting `output_directories`: %+v", err)
        }
        d.Set("priority", int(*jobBaseProperties.Priority))
        d.Set("provisioning_state", string(jobBaseProperties.ProvisioningState))
        d.Set("provisioning_state_transition_time", (jobBaseProperties.ProvisioningStateTransitionTime).String())
        if err := d.Set("py_torch_settings", flattenArmJobPyTorchSettings(jobBaseProperties.PyTorchSettings)); err != nil {
            return fmt.Errorf("Error setting `py_torch_settings`: %+v", err)
        }
        if err := d.Set("secrets", flattenArmJobEnvironmentVariableWithSecretValue(jobBaseProperties.Secrets)); err != nil {
            return fmt.Errorf("Error setting `secrets`: %+v", err)
        }
        d.Set("std_out_err_path_prefix", jobBaseProperties.StdOutErrPathPrefix)
        if err := d.Set("tensor_flow_settings", flattenArmJobTensorFlowSettings(jobBaseProperties.TensorFlowSettings)); err != nil {
            return fmt.Errorf("Error setting `tensor_flow_settings`: %+v", err)
        }
        d.Set("tool_type", string(jobBaseProperties.ToolType))
    }
    d.Set("job_name", jobName)
    d.Set("type", resp.Type)

    return tags.FlattenAndSet(d, resp.Tags)
}


func resourceArmJobDelete(d *schema.ResourceData, meta interface{}) error {
    client := meta.(*ArmClient).jobsClient
    ctx := meta.(*ArmClient).StopContext


    id, err := azure.ParseAzureResourceID(d.Id())
    if err != nil {
        return err
    }
    resourceGroup := id.ResourceGroup
    jobName := id.Path["jobs"]

    future, err := client.Delete(ctx, resourceGroup, jobName)
    if err != nil {
        if response.WasNotFound(future.Response()) {
            return nil
        }
        return fmt.Errorf("Error deleting Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
    }

    if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
        if !response.WasNotFound(future.Response()) {
            return fmt.Errorf("Error waiting for deleting Job (Job Name %q / Resource Group %q): %+v", jobName, resourceGroup, err)
        }
    }

    return nil
}

func expandArmJobCaffe2Settings(input []interface{}) *batchaisdk.Caffe2Settings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    pythonScriptFilePath := v["python_script_file_path"].(string)
    pythonInterpreterPath := v["python_interpreter_path"].(string)
    commandLineArgs := v["command_line_args"].(string)

    result := batchaisdk.Caffe2Settings{
        CommandLineArgs: utils.String(commandLineArgs),
        PythonInterpreterPath: utils.String(pythonInterpreterPath),
        PythonScriptFilePath: utils.String(pythonScriptFilePath),
    }
    return &result
}

func expandArmJobCaffeSettings(input []interface{}) *batchaisdk.CaffeSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    configFilePath := v["config_file_path"].(string)
    pythonScriptFilePath := v["python_script_file_path"].(string)
    pythonInterpreterPath := v["python_interpreter_path"].(string)
    commandLineArgs := v["command_line_args"].(string)
    processCount := v["process_count"].(int)

    result := batchaisdk.CaffeSettings{
        CommandLineArgs: utils.String(commandLineArgs),
        ConfigFilePath: utils.String(configFilePath),
        ProcessCount: utils.Int32(int32(processCount)),
        PythonInterpreterPath: utils.String(pythonInterpreterPath),
        PythonScriptFilePath: utils.String(pythonScriptFilePath),
    }
    return &result
}

func expandArmJobChainerSettings(input []interface{}) *batchaisdk.ChainerSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    pythonScriptFilePath := v["python_script_file_path"].(string)
    pythonInterpreterPath := v["python_interpreter_path"].(string)
    commandLineArgs := v["command_line_args"].(string)
    processCount := v["process_count"].(int)

    result := batchaisdk.ChainerSettings{
        CommandLineArgs: utils.String(commandLineArgs),
        ProcessCount: utils.Int32(int32(processCount)),
        PythonInterpreterPath: utils.String(pythonInterpreterPath),
        PythonScriptFilePath: utils.String(pythonScriptFilePath),
    }
    return &result
}

func expandArmJobResourceId(input []interface{}) *batchaisdk.ResourceId {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    id := v["id"].(string)

    result := batchaisdk.ResourceId{
        ID: utils.String(id),
    }
    return &result
}

func expandArmJobCNTKsettings(input []interface{}) *batchaisdk.CNTKsettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    languageType := v["language_type"].(string)
    configFilePath := v["config_file_path"].(string)
    pythonScriptFilePath := v["python_script_file_path"].(string)
    pythonInterpreterPath := v["python_interpreter_path"].(string)
    commandLineArgs := v["command_line_args"].(string)
    processCount := v["process_count"].(int)

    result := batchaisdk.CNTKsettings{
        CommandLineArgs: utils.String(commandLineArgs),
        ConfigFilePath: utils.String(configFilePath),
        LanguageType: utils.String(languageType),
        ProcessCount: utils.Int32(int32(processCount)),
        PythonInterpreterPath: utils.String(pythonInterpreterPath),
        PythonScriptFilePath: utils.String(pythonScriptFilePath),
    }
    return &result
}

func expandArmJobJobBaseProperties_constraints(input []interface{}) *batchaisdk.JobBaseProperties_constraints {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    maxWallClockTime := v["max_wall_clock_time"].(string)

    result := batchaisdk.JobBaseProperties_constraints{
        MaxWallClockTime: utils.String(maxWallClockTime),
    }
    return &result
}

func expandArmJobContainerSettings(input []interface{}) *batchaisdk.ContainerSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    imageSourceRegistry := v["image_source_registry"].([]interface{})

    result := batchaisdk.ContainerSettings{
        ImageSourceRegistry: expandArmJobImageSourceRegistry(imageSourceRegistry),
    }
    return &result
}

func expandArmJobCustomToolkitSettings(input []interface{}) *batchaisdk.CustomToolkitSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    commandLine := v["command_line"].(string)

    result := batchaisdk.CustomToolkitSettings{
        CommandLine: utils.String(commandLine),
    }
    return &result
}

func expandArmJobEnvironmentVariable(input []interface{}) *[]batchaisdk.EnvironmentVariable {
    results := make([]batchaisdk.EnvironmentVariable, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        value := v["value"].(string)

        result := batchaisdk.EnvironmentVariable{
            Name: utils.String(name),
            Value: utils.String(value),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmJobInputDirectory(input []interface{}) *[]batchaisdk.InputDirectory {
    results := make([]batchaisdk.InputDirectory, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        path := v["path"].(string)

        result := batchaisdk.InputDirectory{
            ID: utils.String(id),
            Path: utils.String(path),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmJobJobPreparation(input []interface{}) *batchaisdk.JobPreparation {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    commandLine := v["command_line"].(string)

    result := batchaisdk.JobPreparation{
        CommandLine: utils.String(commandLine),
    }
    return &result
}

func expandArmJobMountVolumes(input []interface{}) *batchaisdk.MountVolumes {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    azureFileShares := v["azure_file_shares"].([]interface{})
    azureBlobFileSystems := v["azure_blob_file_systems"].([]interface{})
    fileServers := v["file_servers"].([]interface{})
    unmanagedFileSystems := v["unmanaged_file_systems"].([]interface{})

    result := batchaisdk.MountVolumes{
        AzureBlobFileSystems: expandArmJobAzureBlobFileSystemReference(azureBlobFileSystems),
        AzureFileShares: expandArmJobAzureFileShareReference(azureFileShares),
        FileServers: expandArmJobFileServerReference(fileServers),
        UnmanagedFileSystems: expandArmJobUnmanagedFileSystemReference(unmanagedFileSystems),
    }
    return &result
}

func expandArmJobOutputDirectory(input []interface{}) *[]batchaisdk.OutputDirectory {
    results := make([]batchaisdk.OutputDirectory, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        id := v["id"].(string)
        pathPrefix := v["path_prefix"].(string)
        pathSuffix := v["path_suffix"].(string)
        type := v["type"].(string)
        createNew := v["create_new"].(bool)

        result := batchaisdk.OutputDirectory{
            CreateNew: utils.Bool(createNew),
            ID: utils.String(id),
            PathPrefix: utils.String(pathPrefix),
            PathSuffix: utils.String(pathSuffix),
            Type: batchaisdk.OutputType(type),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmJobPyTorchSettings(input []interface{}) *batchaisdk.PyTorchSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    pythonScriptFilePath := v["python_script_file_path"].(string)
    pythonInterpreterPath := v["python_interpreter_path"].(string)
    commandLineArgs := v["command_line_args"].(string)
    processCount := v["process_count"].(int)
    communicationBackend := v["communication_backend"].(string)

    result := batchaisdk.PyTorchSettings{
        CommandLineArgs: utils.String(commandLineArgs),
        CommunicationBackend: utils.String(communicationBackend),
        ProcessCount: utils.Int32(int32(processCount)),
        PythonInterpreterPath: utils.String(pythonInterpreterPath),
        PythonScriptFilePath: utils.String(pythonScriptFilePath),
    }
    return &result
}

func expandArmJobEnvironmentVariableWithSecretValue(input []interface{}) *[]batchaisdk.EnvironmentVariableWithSecretValue {
    results := make([]batchaisdk.EnvironmentVariableWithSecretValue, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        name := v["name"].(string)
        value := v["value"].(string)
        valueSecretReference := v["value_secret_reference"].([]interface{})

        result := batchaisdk.EnvironmentVariableWithSecretValue{
            Name: utils.String(name),
            Value: utils.String(value),
            ValueSecretReference: expandArmJobKeyVaultSecretReference(valueSecretReference),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmJobTensorFlowSettings(input []interface{}) *batchaisdk.TensorFlowSettings {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    pythonScriptFilePath := v["python_script_file_path"].(string)
    pythonInterpreterPath := v["python_interpreter_path"].(string)
    masterCommandLineArgs := v["master_command_line_args"].(string)
    workerCommandLineArgs := v["worker_command_line_args"].(string)
    parameterServerCommandLineArgs := v["parameter_server_command_line_args"].(string)
    workerCount := v["worker_count"].(int)
    parameterServerCount := v["parameter_server_count"].(int)

    result := batchaisdk.TensorFlowSettings{
        MasterCommandLineArgs: utils.String(masterCommandLineArgs),
        ParameterServerCommandLineArgs: utils.String(parameterServerCommandLineArgs),
        ParameterServerCount: utils.Int32(int32(parameterServerCount)),
        PythonInterpreterPath: utils.String(pythonInterpreterPath),
        PythonScriptFilePath: utils.String(pythonScriptFilePath),
        WorkerCommandLineArgs: utils.String(workerCommandLineArgs),
        WorkerCount: utils.Int32(int32(workerCount)),
    }
    return &result
}

func expandArmJobImageSourceRegistry(input []interface{}) *batchaisdk.ImageSourceRegistry {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    serverUrl := v["server_url"].(string)
    image := v["image"].(string)
    credentials := v["credentials"].([]interface{})

    result := batchaisdk.ImageSourceRegistry{
        Credentials: expandArmJobPrivateRegistryCredentials(credentials),
        Image: utils.String(image),
        ServerURL: utils.String(serverUrl),
    }
    return &result
}

func expandArmJobAzureBlobFileSystemReference(input []interface{}) *[]batchaisdk.AzureBlobFileSystemReference {
    results := make([]batchaisdk.AzureBlobFileSystemReference, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        accountName := v["account_name"].(string)
        containerName := v["container_name"].(string)
        credentials := v["credentials"].([]interface{})
        relativeMountPath := v["relative_mount_path"].(string)
        mountOptions := v["mount_options"].(string)

        result := batchaisdk.AzureBlobFileSystemReference{
            AccountName: utils.String(accountName),
            ContainerName: utils.String(containerName),
            Credentials: expandArmJobAzureStorageCredentialsInfo(credentials),
            MountOptions: utils.String(mountOptions),
            RelativeMountPath: utils.String(relativeMountPath),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmJobAzureFileShareReference(input []interface{}) *[]batchaisdk.AzureFileShareReference {
    results := make([]batchaisdk.AzureFileShareReference, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        accountName := v["account_name"].(string)
        azureFileUrl := v["azure_file_url"].(string)
        credentials := v["credentials"].([]interface{})
        relativeMountPath := v["relative_mount_path"].(string)
        fileMode := v["file_mode"].(string)
        directoryMode := v["directory_mode"].(string)

        result := batchaisdk.AzureFileShareReference{
            AccountName: utils.String(accountName),
            AzureFileURL: utils.String(azureFileUrl),
            Credentials: expandArmJobAzureStorageCredentialsInfo(credentials),
            DirectoryMode: utils.String(directoryMode),
            FileMode: utils.String(fileMode),
            RelativeMountPath: utils.String(relativeMountPath),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmJobFileServerReference(input []interface{}) *[]batchaisdk.FileServerReference {
    results := make([]batchaisdk.FileServerReference, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        fileServer := v["file_server"].([]interface{})
        sourceDirectory := v["source_directory"].(string)
        relativeMountPath := v["relative_mount_path"].(string)
        mountOptions := v["mount_options"].(string)

        result := batchaisdk.FileServerReference{
            FileServer: expandArmJobResourceId(fileServer),
            MountOptions: utils.String(mountOptions),
            RelativeMountPath: utils.String(relativeMountPath),
            SourceDirectory: utils.String(sourceDirectory),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmJobUnmanagedFileSystemReference(input []interface{}) *[]batchaisdk.UnmanagedFileSystemReference {
    results := make([]batchaisdk.UnmanagedFileSystemReference, 0)
    for _, item := range input {
        v := item.(map[string]interface{})
        mountCommand := v["mount_command"].(string)
        relativeMountPath := v["relative_mount_path"].(string)

        result := batchaisdk.UnmanagedFileSystemReference{
            MountCommand: utils.String(mountCommand),
            RelativeMountPath: utils.String(relativeMountPath),
        }

        results = append(results, result)
    }
    return &results
}

func expandArmJobKeyVaultSecretReference(input []interface{}) *batchaisdk.KeyVaultSecretReference {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    sourceVault := v["source_vault"].([]interface{})
    secretUrl := v["secret_url"].(string)

    result := batchaisdk.KeyVaultSecretReference{
        SecretURL: utils.String(secretUrl),
        SourceVault: expandArmJobResourceId(sourceVault),
    }
    return &result
}

func expandArmJobPrivateRegistryCredentials(input []interface{}) *batchaisdk.PrivateRegistryCredentials {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    username := v["username"].(string)
    password := v["password"].(string)

    result := batchaisdk.PrivateRegistryCredentials{
        Password: utils.String(password),
        Username: utils.String(username),
    }
    return &result
}

func expandArmJobAzureStorageCredentialsInfo(input []interface{}) *batchaisdk.AzureStorageCredentialsInfo {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})

    accountKey := v["account_key"].(string)

    result := batchaisdk.AzureStorageCredentialsInfo{
        AccountKey: utils.String(accountKey),
    }
    return &result
}


func flattenArmJobCaffeSettings(input *batchaisdk.CaffeSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLineArgs := input.CommandLineArgs; commandLineArgs != nil {
        result["command_line_args"] = *commandLineArgs
    }
    if configFilePath := input.ConfigFilePath; configFilePath != nil {
        result["config_file_path"] = *configFilePath
    }
    if processCount := input.ProcessCount; processCount != nil {
        result["process_count"] = int(*processCount)
    }
    if pythonInterpreterPath := input.PythonInterpreterPath; pythonInterpreterPath != nil {
        result["python_interpreter_path"] = *pythonInterpreterPath
    }
    if pythonScriptFilePath := input.PythonScriptFilePath; pythonScriptFilePath != nil {
        result["python_script_file_path"] = *pythonScriptFilePath
    }

    return []interface{}{result}
}

func flattenArmJobChainerSettings(input *batchaisdk.ChainerSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLineArgs := input.CommandLineArgs; commandLineArgs != nil {
        result["command_line_args"] = *commandLineArgs
    }
    if processCount := input.ProcessCount; processCount != nil {
        result["process_count"] = int(*processCount)
    }
    if pythonInterpreterPath := input.PythonInterpreterPath; pythonInterpreterPath != nil {
        result["python_interpreter_path"] = *pythonInterpreterPath
    }
    if pythonScriptFilePath := input.PythonScriptFilePath; pythonScriptFilePath != nil {
        result["python_script_file_path"] = *pythonScriptFilePath
    }

    return []interface{}{result}
}

func flattenArmJobResourceId(input *batchaisdk.ResourceId) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if id := input.ID; id != nil {
        result["id"] = *id
    }

    return []interface{}{result}
}

func flattenArmJobCNTKsettings(input *batchaisdk.CNTKsettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLineArgs := input.CommandLineArgs; commandLineArgs != nil {
        result["command_line_args"] = *commandLineArgs
    }
    if configFilePath := input.ConfigFilePath; configFilePath != nil {
        result["config_file_path"] = *configFilePath
    }
    if languageType := input.LanguageType; languageType != nil {
        result["language_type"] = *languageType
    }
    if processCount := input.ProcessCount; processCount != nil {
        result["process_count"] = int(*processCount)
    }
    if pythonInterpreterPath := input.PythonInterpreterPath; pythonInterpreterPath != nil {
        result["python_interpreter_path"] = *pythonInterpreterPath
    }
    if pythonScriptFilePath := input.PythonScriptFilePath; pythonScriptFilePath != nil {
        result["python_script_file_path"] = *pythonScriptFilePath
    }

    return []interface{}{result}
}

func flattenArmJobJobBaseProperties_constraints(input *batchaisdk.JobBaseProperties_constraints) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if maxWallClockTime := input.MaxWallClockTime; maxWallClockTime != nil {
        result["max_wall_clock_time"] = *maxWallClockTime
    }

    return []interface{}{result}
}

func flattenArmJobContainerSettings(input *batchaisdk.ContainerSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["image_source_registry"] = flattenArmJobImageSourceRegistry(input.ImageSourceRegistry)

    return []interface{}{result}
}

func flattenArmJobCustomToolkitSettings(input *batchaisdk.CustomToolkitSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLine := input.CommandLine; commandLine != nil {
        result["command_line"] = *commandLine
    }

    return []interface{}{result}
}

func flattenArmJobEnvironmentVariable(input *[]batchaisdk.EnvironmentVariable) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if value := item.Value; value != nil {
            v["value"] = *value
        }

        results = append(results, v)
    }

    return results
}

func flattenArmJobJobProperties_executionInfo(input *batchaisdk.JobProperties_executionInfo) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})


    return []interface{}{result}
}

func flattenArmJobInputDirectory(input *[]batchaisdk.InputDirectory) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }
        if path := item.Path; path != nil {
            v["path"] = *path
        }

        results = append(results, v)
    }

    return results
}

func flattenArmJobJobPreparation(input *batchaisdk.JobPreparation) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLine := input.CommandLine; commandLine != nil {
        result["command_line"] = *commandLine
    }

    return []interface{}{result}
}

func flattenArmJobMountVolumes(input *batchaisdk.MountVolumes) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["azure_blob_file_systems"] = flattenArmJobAzureBlobFileSystemReference(input.AzureBlobFileSystems)
    result["azure_file_shares"] = flattenArmJobAzureFileShareReference(input.AzureFileShares)
    result["file_servers"] = flattenArmJobFileServerReference(input.FileServers)
    result["unmanaged_file_systems"] = flattenArmJobUnmanagedFileSystemReference(input.UnmanagedFileSystems)

    return []interface{}{result}
}

func flattenArmJobOutputDirectory(input *[]batchaisdk.OutputDirectory) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if id := item.ID; id != nil {
            v["id"] = *id
        }
        if createNew := item.CreateNew; createNew != nil {
            v["create_new"] = *createNew
        }
        if pathPrefix := item.PathPrefix; pathPrefix != nil {
            v["path_prefix"] = *pathPrefix
        }
        if pathSuffix := item.PathSuffix; pathSuffix != nil {
            v["path_suffix"] = *pathSuffix
        }
        v["type"] = string(item.Type)

        results = append(results, v)
    }

    return results
}

func flattenArmJobPyTorchSettings(input *batchaisdk.PyTorchSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if commandLineArgs := input.CommandLineArgs; commandLineArgs != nil {
        result["command_line_args"] = *commandLineArgs
    }
    if communicationBackend := input.CommunicationBackend; communicationBackend != nil {
        result["communication_backend"] = *communicationBackend
    }
    if processCount := input.ProcessCount; processCount != nil {
        result["process_count"] = int(*processCount)
    }
    if pythonInterpreterPath := input.PythonInterpreterPath; pythonInterpreterPath != nil {
        result["python_interpreter_path"] = *pythonInterpreterPath
    }
    if pythonScriptFilePath := input.PythonScriptFilePath; pythonScriptFilePath != nil {
        result["python_script_file_path"] = *pythonScriptFilePath
    }

    return []interface{}{result}
}

func flattenArmJobEnvironmentVariableWithSecretValue(input *[]batchaisdk.EnvironmentVariableWithSecretValue) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if name := item.Name; name != nil {
            v["name"] = *name
        }
        if value := item.Value; value != nil {
            v["value"] = *value
        }
        v["value_secret_reference"] = flattenArmJobKeyVaultSecretReference(item.ValueSecretReference)

        results = append(results, v)
    }

    return results
}

func flattenArmJobTensorFlowSettings(input *batchaisdk.TensorFlowSettings) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if masterCommandLineArgs := input.MasterCommandLineArgs; masterCommandLineArgs != nil {
        result["master_command_line_args"] = *masterCommandLineArgs
    }
    if parameterServerCommandLineArgs := input.ParameterServerCommandLineArgs; parameterServerCommandLineArgs != nil {
        result["parameter_server_command_line_args"] = *parameterServerCommandLineArgs
    }
    if parameterServerCount := input.ParameterServerCount; parameterServerCount != nil {
        result["parameter_server_count"] = int(*parameterServerCount)
    }
    if pythonInterpreterPath := input.PythonInterpreterPath; pythonInterpreterPath != nil {
        result["python_interpreter_path"] = *pythonInterpreterPath
    }
    if pythonScriptFilePath := input.PythonScriptFilePath; pythonScriptFilePath != nil {
        result["python_script_file_path"] = *pythonScriptFilePath
    }
    if workerCommandLineArgs := input.WorkerCommandLineArgs; workerCommandLineArgs != nil {
        result["worker_command_line_args"] = *workerCommandLineArgs
    }
    if workerCount := input.WorkerCount; workerCount != nil {
        result["worker_count"] = int(*workerCount)
    }

    return []interface{}{result}
}

func flattenArmJobImageSourceRegistry(input *batchaisdk.ImageSourceRegistry) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    result["credentials"] = flattenArmJobPrivateRegistryCredentials(input.Credentials)
    if image := input.Image; image != nil {
        result["image"] = *image
    }
    if serverUrl := input.ServerURL; serverUrl != nil {
        result["server_url"] = *serverUrl
    }

    return []interface{}{result}
}

func flattenArmJobAzureBlobFileSystemReference(input *[]batchaisdk.AzureBlobFileSystemReference) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if accountName := item.AccountName; accountName != nil {
            v["account_name"] = *accountName
        }
        if containerName := item.ContainerName; containerName != nil {
            v["container_name"] = *containerName
        }
        v["credentials"] = flattenArmJobAzureStorageCredentialsInfo(item.Credentials)
        if mountOptions := item.MountOptions; mountOptions != nil {
            v["mount_options"] = *mountOptions
        }
        if relativeMountPath := item.RelativeMountPath; relativeMountPath != nil {
            v["relative_mount_path"] = *relativeMountPath
        }

        results = append(results, v)
    }

    return results
}

func flattenArmJobAzureFileShareReference(input *[]batchaisdk.AzureFileShareReference) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if accountName := item.AccountName; accountName != nil {
            v["account_name"] = *accountName
        }
        if azureFileUrl := item.AzureFileURL; azureFileUrl != nil {
            v["azure_file_url"] = *azureFileUrl
        }
        v["credentials"] = flattenArmJobAzureStorageCredentialsInfo(item.Credentials)
        if directoryMode := item.DirectoryMode; directoryMode != nil {
            v["directory_mode"] = *directoryMode
        }
        if fileMode := item.FileMode; fileMode != nil {
            v["file_mode"] = *fileMode
        }
        if relativeMountPath := item.RelativeMountPath; relativeMountPath != nil {
            v["relative_mount_path"] = *relativeMountPath
        }

        results = append(results, v)
    }

    return results
}

func flattenArmJobFileServerReference(input *[]batchaisdk.FileServerReference) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        v["file_server"] = flattenArmJobResourceId(item.FileServer)
        if mountOptions := item.MountOptions; mountOptions != nil {
            v["mount_options"] = *mountOptions
        }
        if relativeMountPath := item.RelativeMountPath; relativeMountPath != nil {
            v["relative_mount_path"] = *relativeMountPath
        }
        if sourceDirectory := item.SourceDirectory; sourceDirectory != nil {
            v["source_directory"] = *sourceDirectory
        }

        results = append(results, v)
    }

    return results
}

func flattenArmJobUnmanagedFileSystemReference(input *[]batchaisdk.UnmanagedFileSystemReference) []interface{} {
    results := make([]interface{}, 0)
    if input == nil {
        return results
    }

    for _, item := range *input {
        v := make(map[string]interface{})

        if mountCommand := item.MountCommand; mountCommand != nil {
            v["mount_command"] = *mountCommand
        }
        if relativeMountPath := item.RelativeMountPath; relativeMountPath != nil {
            v["relative_mount_path"] = *relativeMountPath
        }

        results = append(results, v)
    }

    return results
}

func flattenArmJobKeyVaultSecretReference(input *batchaisdk.KeyVaultSecretReference) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if secretUrl := input.SecretURL; secretUrl != nil {
        result["secret_url"] = *secretUrl
    }
    result["source_vault"] = flattenArmJobResourceId(input.SourceVault)

    return []interface{}{result}
}

func flattenArmJobPrivateRegistryCredentials(input *batchaisdk.PrivateRegistryCredentials) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if password := input.Password; password != nil {
        result["password"] = *password
    }
    if username := input.Username; username != nil {
        result["username"] = *username
    }

    return []interface{}{result}
}

func flattenArmJobAzureStorageCredentialsInfo(input *batchaisdk.AzureStorageCredentialsInfo) []interface{} {
    if input == nil {
        return make([]interface{}, 0)
    }

    result := make(map[string]interface{})

    if accountKey := input.AccountKey; accountKey != nil {
        result["account_key"] = *accountKey
    }

    return []interface{}{result}
}
